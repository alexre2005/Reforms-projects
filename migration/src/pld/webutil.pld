.META method_wrappers:false, package_separation:false END

FUNCTION CLIENT_GET_FILE_NAME (directory_name Varchar2 := NULL,
                               file_name      Varchar2 := NULL,
                               file_filter    Varchar2 := NULL,
                               message        Varchar2 := NULL,
                               dialog_type    Number   := OPEN_FILE,
                               select_file    Boolean  := TRUE) return Varchar2 is                              
/*********************************************************************************\
 * CLIENT_GET_FILE_NAME
 *   Client (Browser) side implementation of the standard GET_FILE_NAME Built-in
 *   Used to display File Open, Save  and directory listing dialogs
 *   Implemented using calls to WEBUTIL_FILE
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 23/DEC/2002 - Creation
 *
\*********************************************************************************/ 

BEGIN
  RETURN WEBUTIL_FILE.FILE_SELECTION_DIALOG( directory_name,
                                             file_name,
                                             file_filter,
                                             message,
                                             dialog_type,
                                             select_file);
END CLIENT_GET_FILE_NAME;


PROCEDURE CLIENT_HOST(syscmd Varchar2, kwd Number default NULL) IS
/*********************************************************************************\
 * CLIENT_HOST
 *   This procedure duplicates the action of the HOST Built-in, except that it 
 *   operates on the client (browser) tier rather than the application server tier.  
 *   Existing HOST code  can be re-directed to run on the client simply by 
 *   prefixing all the calls with "CLIENT_" 
 *   The oracle.forms.webutil.host.HostFunctions bean is needed in your 
 *   Form to use these functions
 *   Note 1) This version (like client server) is Blocking and will prevent
 *   re-draw of the Forms Screen whilst the Host command is active 
 *   Note 2) The kwd argument (e.g. NO_SCREEN etc) is ignored 
 *
 *   For more flexible "Host" commands see the WEBUTIL_HOST package
 *   That has facilities for Asynchronous callbacks and return codes
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 03/JAN/2003 - Creation 
 *
\*********************************************************************************/
BEGIN
  -- simply call through the to WEBUTIL_HOST.HOST() Function
  if WEBUTIL_HOST.HOST(syscmd) <> 0 then 
    raise form_trigger_failure;
  end if;
END CLIENT_HOST;


PACKAGE CLIENT_IMAGE IS
/*********************************************************************************\
 * CLIENT_IMAGE
 *   Client (Browser) side implementations of the standard READ_IMAGE_FILE and 
 *   WRITE_IMAGE_FILE built-ins.
 *   Used to read an image file off of or on to the browser machine to or from 
 *   s Forms Image Item.
 *   Implemented using calls to WEBUTIL_FILE_TRANSFER.
 *   Note that the transfer.appsrv.workAreaRoot property must be set in the 
 *   webutil.cfg file so that this routine has a server side work area available
 *   for temporary files.
 *   These calls are in a package rather than in individual CLIENT_ versions 
 *   because PL/SQL only allows overloading (Item ID and Item Name versions) from 
 *   Within Packages.
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 11/FEB/2003 - Creation
 *
\*********************************************************************************/     
  
  PROCEDURE READ_IMAGE_FILE(   file_name           in VARCHAR2,
                               file_type           in VARCHAR2 := NULL,
                               i_name              in VARCHAR2);

  PROCEDURE READ_IMAGE_FILE(   file_name           in VARCHAR2,
                               file_type           in VARCHAR2 := NULL,
                               item_id             in ITEM);
                          
  PROCEDURE  WRITE_IMAGE_FILE (file_name           in VARCHAR2, 
                               file_type           in VARCHAR2,
                               item_id             in ITEM,
                               compression_quality in NUMBER := MINIMIZE_COMPRESSION,
                               image_depth         in NUMBER := ORIGINAL_DEPTH);
                               
  PROCEDURE  WRITE_IMAGE_FILE (file_name           in VARCHAR2, 
                               file_type           in VARCHAR2,
                               item_name           in VARCHAR2,
                               compression_quality in NUMBER := MINIMIZE_COMPRESSION,
                               image_depth         in NUMBER := ORIGINAL_DEPTH);
                          

END CLIENT_IMAGE;


PACKAGE BODY CLIENT_IMAGE IS
  -- internal exceptions
  CLIENT_FILE_NULL   EXCEPTION;
  INVALID_CLIENT_FILE_DIR EXCEPTION;

  PROCEDURE READ_IMAGE_FILE(file_name in VARCHAR2,
                            file_type in VARCHAR2 := NULL,
                            i_name    in VARCHAR2) IS
    workArea   VARCHAR2(512 char);
    imageName  VARCHAR2(256 char);
    iLoc       PLS_INTEGER;
    cSep       CHAR(1) := WebUtil_Core.getClientFileSep;
    jFile      ORA_JAVA.JOBJECT;
  BEGIN
    -- Step 1. Extract the actual file name from the supplied name
    iLoc := instr(file_name,cSep,-1);
    if iLoc = 0 then 
      imageName := file_name;
    else
      imageName := substr(file_name,iLoc+1);
    end if;
    
    -- Step 2. Get the WorkArea on the application server, creating 
    --         the directory if required
    workArea := WebUtil_File_Transfer.get_Work_Area(true);
    
    -- Step 3. Do an upload to the workaArea
    if WebUtil_File_Transfer.Client_To_AS(file_name, workArea||imageName, false, null) then 
      -- Step 4. If that worked we can do a conventional READ_IMAGE_FILE from the 
      --         workarea
      -- Note that we have to prefix the internal package that Forms has R_I_F in 
      -- because of name collisions
      -- This will break if Forms ever internally re-organises it's packages
      -- and so this should not normally be done.
      FORMS40.READ_IMAGE_FILE(workArea||imageName, file_type, i_name);
      if NOT FORM_SUCCESS then 
        RAISE FORM_TRIGGER_FAILURE;
      end if;    

      -- Step 5. If the read succeeded then erase the workarea copy
      --         (If it failed then we leave it for the Admin to 
      --          see what the problem with the file was)
      jFile := JAVA_FILE.NEW(workArea||imageName);
      if not JAVA_FILE.Delete_(jFile) then 
        -- not a really bad error just log it
        WebUtil_Core.log('CLIENT_IMAGE.READ_IMAGE_FILE: Failed to delete '||imageName||'  from workarea',true);
      end if;
    else
      RAISE FORM_TRIGGER_FAILURE;
    end if;        
  END READ_IMAGE_FILE;

  PROCEDURE READ_IMAGE_FILE(file_name in VARCHAR2,
                            file_type in VARCHAR2 := NULL,
                            item_id in ITEM) IS
  BEGIN
    --hItem := FIND_ITEM(item_name);
    if not ID_NULL(item_id) then 
      CLIENT_IMAGE.READ_IMAGE_FILE(file_name, file_type, get_item_property(item_id, BLOCK_NAME)||
                                   '.'||get_item_property (item_id, ITEM_NAME));
    end if;
  END READ_IMAGE_FILE; 
  
  PROCEDURE  WRITE_IMAGE_FILE (file_name           in VARCHAR2, 
                               file_type           in VARCHAR2,
                               item_name           in VARCHAR2,
                               compression_quality in NUMBER := MINIMIZE_COMPRESSION,
                               image_depth         in NUMBER := ORIGINAL_DEPTH) is
    workArea   VARCHAR2(512 char);
    imageName  VARCHAR2(512 char);
    iLoc       PLS_INTEGER;
    cSep       CHAR(1) := WebUtil_Core.getClientFileSep;
    jFile      ORA_JAVA.JOBJECT;
    jDir       ORA_JAVA.JOBJECT;
    tFile      TEXT_IO.file_type;
    parent_dir VARCHAR2(1000);
    dummyB     boolean;
  BEGIN
    if file_name is null then
      raise CLIENT_FILE_NULL;
    end if;
    
      -- Make sure that the given client file path is not a directory and parent directory exists
      parent_dir := substr(file_name, 1, instr(file_name, WebUtil_Core.getClientFileSep, -1));
      if WEBUTIL_FILE.file_is_directory(file_name)
           OR NOT WEBUTIL_FILE.file_is_directory (parent_dir) then
          raise INVALID_CLIENT_FILE_DIR;
      end if;

      -- Step 1. Extract the actual file name from the supplied name
      iLoc := instr(file_name,cSep,-1);
      if iLoc = 0 then 
        imageName := file_name;
      else
        imageName := substr(file_name,iLoc+1);
      end if;
    
      -- Step 2. Get the WorkArea on the application server, creating 
      --         the directory if required
      workArea := WebUtil_File_Transfer.get_Work_Area(true);
      -- Workaround to make sure that we can create temp file on the application server
      -- This will help in catching invalid file names or permission denied kind of errors
      begin -- subloop
        jFile := JAVA_FILE.NEW(workArea||imageName);
        if not JAVA_FILE.EXISTS_(jFile) then
          tFile := TEXT_IO.FOPEN(workArea||imageName, 'A');
          if NOT FORM_SUCCESS then
            raise INVALID_CLIENT_FILE_DIR;
          end if;
          TEXT_IO.FCLOSE(tFile);
        end if;
        -- Delete the file even if it existed before. We are anyway going to overwrite.
        -- FORMS40.WRITE_IMAGE_FILE will not create file if image item does not contain
        -- any image. But if the file already exists, we won't know whether the call
        -- created any image file or not.
        dummyB := JAVA_FILE.Delete_(jFile);
      exception
        when others then
          raise INVALID_CLIENT_FILE_DIR;
      end; -- subloop
      
      -- Step 3. Use conventional WRITE_IMAGE_FILE to dump the image to 
      --         the workarea
      -- Note that we have to prefix the internal package that Forms has W_I_F in 
      -- because of name collisions
      -- This will break if Forms ever internally re-organises it's packages
      -- and so this should not normally be done.
      FORMS40.WRITE_IMAGE_FILE(workArea||imageName, file_type, item_name, compression_quality, image_depth);
      if NOT FORM_SUCCESS then 
        RAISE FORM_TRIGGER_FAILURE;
      end if;          
    
      -- Step 4. Do an download from the workArea to the client
      if not JAVA_FILE.EXISTS_(jFile) then
        -- It could be because there is no image in the image item holder.
        -- Return quietly.
        return;
      end if;

      if WebUtil_File_Transfer.AS_To_Client(file_name, workArea||imageName) then       
        -- Step 5. If that all worked then erase the workarea copy
        if not JAVA_FILE.Delete_(jFile) then 
          -- not a really bad error just log it
          WebUtil_Core.log('CLIENT_IMAGE.WRITE_IMAGE_FILE: Failed to delete '||imageName||'  from workarea',true);
        end if;
      else
        RAISE FORM_TRIGGER_FAILURE;
      end if;
    exception
      when CLIENT_FILE_NULL then
        WebUtil_Core.Error(Webutil_Core.WUF_PACKAGE,130,'CLIENT_IMAGE.WRITE_IMAGE_FILE');
      when INVALID_CLIENT_FILE_DIR then
        WebUtil_Core.Error(Webutil_Core.WUF_PACKAGE,131,'CLIENT_IMAGE.WRITE_IMAGE_FILE', file_name);
      when others then
        raise;
  END WRITE_IMAGE_FILE;                               
                               
                               
  PROCEDURE  WRITE_IMAGE_FILE (file_name           in VARCHAR2, 
                               file_type           in VARCHAR2,
                               item_id             in ITEM,
                               compression_quality in NUMBER := MINIMIZE_COMPRESSION,
                               image_depth         in NUMBER := ORIGINAL_DEPTH) IS
    hItem  ITEM;
  BEGIN
    --hItem := FIND_ITEM(item_name);
    if not ID_NULL(hItem) then 
      CLIENT_IMAGE.WRITE_IMAGE_FILE(file_name,
                                    file_type,
                                    get_item_property(item_id, BLOCK_NAME)||'.'||get_item_property (item_id, ITEM_NAME),
                                                                  compression_quality,
                                                                  image_depth);
    end if;
  END WRITE_IMAGE_FILE;                               
 
END CLIENT_IMAGE;


PACKAGE CLIENT_OLE2 IS
/*********************************************************************************\
 * CLIENT_OLE2
 *   This package duplicates the action of the OLE2 package, except that it 
 *   operates on the client (browser) tier rather than the application server tier.  
 *   Existing OLE2 code can be re-directed to run on the client simply by 
 *   prefixing all the calls with "CLIENT_" 
 *   The functions in this package will work only with Windows clients.
 *   The oracle.forms.webutil.ole.OleFunctions bean is needed in your 
 *   Form to use these functions
  *********************************************************************************
 * Version 1.0.2
 *********************************************************************************
 * Change History
 *   1.0.0  KPRAKASH 21/DEC/2002 - Creation 
 *   1.0.1  DRMILLS  27/FEB/2003 - Commented
 *   1.0.2  DRMILLS  12/MAY/2003 - Added Explicit call to WebUtil_Core.Init;
\*********************************************************************************/


  /**
   * OLE Types
   */
  SUBTYPE obj_type IS pls_integer;
  SUBTYPE list_type IS pls_integer;

  /**
   * OLE Exceptions
   */
  ole_error  EXCEPTION;
  PRAGMA exception_init(ole_error, -305500);

  ole_not_supported  EXCEPTION;
  PRAGMA exception_init(ole_not_supported, -305501);

  /**
   * Argument List Functions
   */
  FUNCTION create_arglist RETURN list_type;

  PROCEDURE add_arg(list IN list_type, value IN VARCHAR2);

  PROCEDURE add_arg(list IN list_type, value IN NUMBER);

  PROCEDURE add_arg(list IN list_type, value IN BOOLEAN);

  PROCEDURE add_arg_obj(list IN list_type, value IN OBJ_TYPE);

  PROCEDURE destroy_arglist(list IN list_type);
        
  /**
   * Create Objects
   */
  FUNCTION create_obj(object IN VARCHAR2) RETURN obj_type;

  /**
   * Invoke Methods
   */
  PROCEDURE invoke(object IN obj_type,
                   method IN VARCHAR2,
                   arglist IN list_type := 0);
                
  FUNCTION invoke_num (object IN obj_type, 
                       method IN VARCHAR2, 
                       arglist IN list_type := 0) return NUMBER;
               
  FUNCTION invoke_char (object IN obj_type, 
                        method IN VARCHAR2, 
                        arglist IN list_type := 0) return VARCHAR2;
        
  FUNCTION invoke_obj (object IN obj_type, 
                       method IN VARCHAR2, 
                       arglist IN list_type := 0) return obj_type;

  /**
   * Set And Get OLE Properties
   */
  PROCEDURE set_property (object IN obj_type, 
                          property IN VARCHAR2, 
                          value IN VARCHAR2,
                          arglist IN list_type := 0);
               
  PROCEDURE set_property (object IN obj_type, 
                          property IN VARCHAR2, 
                          value IN NUMBER,
                          arglist IN list_type := 0);
               
  PROCEDURE set_property (object IN obj_type, 
                          property IN VARCHAR2, 
                          value IN BOOLEAN,
                          arglist IN list_type := 0);

  FUNCTION get_num_property (object IN obj_type, 
                             property IN VARCHAR2, 
                             arglist IN list_type := 0) return NUMBER;
  
  FUNCTION get_char_property (object IN obj_type, 
                              property IN VARCHAR2, 
                              arglist IN list_type := 0) return VARCHAR2;
        
  FUNCTION get_obj_property (object IN obj_type, 
                             property IN VARCHAR2, 
                             arglist IN list_type := 0) return obj_type;
        
  FUNCTION get_bool_property (object IN obj_type, 
                             property IN VARCHAR2, 
                             arglist IN list_type := 0) return BOOLEAN;

  /**
   * Release OLE Obj
   */
  PROCEDURE release_obj (object IN obj_type);
        
  /**
   * Is OLE Supported on this client?
   */
  function IsSupported return boolean;


  /**
   * Error handling
   */
  FUNCTION last_exception return NUMBER;

  FUNCTION last_exception(message OUT VARCHAR2) return NUMBER;

  /**
   * New Function For WebUtil - this persists an Object 
   * Reference so that it can be passed between Forms
   * If this is not used then the Object ref will be 
   * Cleaned up as soon as the Form is closed
   */
  PROCEDURE persist_ole_handle(object OBJ_TYPE);
  

  OLE_NULL_COMPATIBILITY BOOLEAN := FALSE;

END CLIENT_OLE2;


PACKAGE BODY CLIENT_OLE2 IS


  /* Function used to create an argument list */


  FUNCTION create_arglist RETURN LIST_TYPE IS
    v_argList LIST_TYPE;
    v_javaHandle VARCHAR2(6);
  BEGIN
    v_javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_CREATE_ARGLIST');
    -- Check if the handle is valid
    if (v_javaHandle is null) or (v_javaHandle='') or (v_javaHandle='-1') then
      raise OLE_ERROR;
    end if;
    v_argList := to_number(v_javaHandle);
    return(v_arglist);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.create_arglist will not work');
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;  
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;
  END create_arglist;    


  /* Overloaded procedure used to add a numeric argument to an argument list */
  PROCEDURE add_arg (list IN LIST_TYPE, value IN NUMBER)IS
    v_str VARCHAR2(4000 char);
  BEGIN
    -- Check if argument list is valid
    if (list is null) or (list='') or (list=0)then
      raise OLE_ERROR;
    end if;  

    if (value is null) or (value='') then
      RAISE OLE_ERROR;
    else
      -- Prefix argument with 'N' as an indicator to the OLE bean that it is a numeric argument
      v_str := 'N'||to_char(value);
    end if;    
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',list);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ADD_ARG',v_str);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.add_arg will not work');
      RAISE OLE_ERROR;
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END add_arg; 


  /* Overloaded procedure used to add a boolean argument to an argument list */
  PROCEDURE add_arg (list IN LIST_TYPE, value IN BOOLEAN)IS
    v_str VARCHAR2(4000 char);
  BEGIN
    -- check if argument list is valid        
    if (list is null) or (list='') or (list=0) then
      raise OLE_ERROR;
    end if;  

    if (value is null) then
      raise OLE_ERROR;
    else
      -- Prefix boolean arguments with 'B' as an indicator to the OLE bean
      v_str := 'B'||Webutil_util.BoolToStr(value);
    end if;  

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',list);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ADD_ARG',v_str);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.add_arg will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END add_arg;


  /* Overloaded procedure used to add a string argument to an argument list */
  PROCEDURE add_arg (list IN LIST_TYPE, value IN VARCHAR2)IS
    v_str varchar2(4000 char);
  BEGIN
    -- Check if argument list is valid
    if (list is null) or (list='') or (list=0)then
      raise OLE_ERROR;
    end if; 
      if (value is null) or (value ='') then
      v_str := null;
    else
      -- Prefix string arguments with 'S' as an indicator to the OLE bean
      v_str := 'S'||value;
    end if;    

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',list);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ADD_ARG',v_str);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.add_arg will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END add_arg; 


  /* procedure used to add an object handle to an argument list */
  PROCEDURE add_arg_obj (list IN LIST_TYPE, value IN OBJ_TYPE)IS
  BEGIN
    if (list is null) or (list='') or (list=0) then
      raise OLE_ERROR;
    end if;  
    if ((value is null ) or (value = '') or (value = -1)) then
      raise OLE_ERROR;
    end if;    

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',list);
    -- Prefix OLE Object handles with "O" as an indicator to the OLE bean
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ADD_ARG','O'||value);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.add_arg_obj will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END add_arg_obj; 


  /* procedure used to destroy an argument list */
  PROCEDURE destroy_arglist(list IN LIST_TYPE)IS
  BEGIN
    if (list is null) or (list='') or (list = -1) then
      raise OLE_ERROR;
    end if;  
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_DESTROY_ARGLIST',list);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.destroy_arglist will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END destroy_arglist;



  /* Function used to create a new instance of an OLE Server */
  FUNCTION create_obj(object IN VARCHAR2) RETURN OBJ_TYPE is
    v_objHandle OBJ_TYPE;
    v_javaHandle varchar2(6);
  BEGIN
    -- check if OLE object name is valid
    if  ((object is null) or (object = '')) then
      raise OLE_ERROR;
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_OBJNAME',object);
    v_javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_CREATE_OBJ');
    -- check if the OLE Object handle is valid
    if (v_javaHandle is null) or (v_javaHandle='') or (v_javaHandle='-1') then
      raise OLE_ERROR;
    end if;

    v_objHandle := to_number(v_javaHandle);
    return(v_objHandle);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.create_obj will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END create_obj;


  /* Procedure used to invoke a method in an OLE Server */
  PROCEDURE invoke(object IN obj_type, method IN VARCHAR2,arglist IN list_type := 0) IS
    v_arglist LIST_TYPE;
  BEGIN
    if ((object is null) or (object = '')) then
      raise OLE_ERROR;
    end if;
    if ((method is null) or (method = '') ) then
      raise OLE_ERROR;
    end if;

    -- If argument list is not specified, then create an empty argument list and invoke
    -- the method using the emtpy list. This is required because the OLE bean requires
    -- an argument list. If no arguments are required, we just pass an empty argument list.
    if (arglist = 0) or (arglist is null) or (arglist='') then
      v_arglist := create_arglist;
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',v_arglist);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',method);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_INVOKE','');

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.invoke will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END invoke;


  /* Function used to invoke a method in an OLE Server, which returns a numeric value */
  FUNCTION invoke_num(object IN obj_type, method IN VARCHAR2,arglist IN list_type := 0) RETURN NUMBER IS
    v_arglist LIST_TYPE;
    v_javares varchar2(4000 char);
  BEGIN
    if ((object is null) or (object = '')) then
      raise OLE_ERROR;
    end if;
    if ((method is null) or (method = '') ) then
      raise OLE_ERROR;
    end if;
    -- If argument list is not specified, then create an empty argument list and invoke
    -- the method using the emtpy list. This is required because the OLE bean requires
    -- an argument list. If no arguments are required, we just pass an empty argument list.
    if (arglist = 0) or (arglist is null) or (arglist='') then
      v_arglist := create_arglist;
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',v_arglist);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',method);
    v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_INVOKE_STR');
    if (v_javares is null) or (v_javares ='') then
      raise OLE_ERROR;
    end if;    
    return(to_number(v_javares));

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.invoke_num will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END invoke_num;        


  /* Function used to invoke a method in an OLE Server, which returns a string value */
  FUNCTION invoke_char(object IN obj_type, method IN VARCHAR2,arglist IN list_type := 0) RETURN VARCHAR2 IS
    v_arglist LIST_TYPE;
    v_javares varchar2(4000 char);
  BEGIN
    if ((object is null) or (object = '')) then
      raise OLE_ERROR;
    end if;
    if ((method is null) or (method = '') ) then
      raise OLE_ERROR;
    end if;

    -- If argument list is not specified, then create an empty argument list and invoke
    -- the method using the emtpy list. This is required because the OLE2 bean requires
    -- an argument list. If no arguments are required, we just pass an empty argument list.
    if (arglist = 0) or (arglist is null) or (arglist='') then
      v_arglist := create_arglist;
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',v_arglist);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',method);
    v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_INVOKE_STR');
    return(v_javares);

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.invoke_char will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END invoke_char;        


  /* Function used to invoke a method in an OLE Server, which returns an OLE object handle */
  FUNCTION invoke_obj(object IN obj_type, method IN VARCHAR2,arglist IN list_type := 0) RETURN OBJ_TYPE IS
    v_arglist LIST_TYPE;
    v_javaHandle  varchar2(6);
    v_objHandle OBJ_TYPE;
  BEGIN
    if ((object is null) or (object = '')) then
      raise OLE_ERROR;
    end if;

    if ((method is null) or (method = '') ) then
      raise OLE_ERROR;
    end if;

    -- If argument list is not specified, then create an empty argument list and invoke
    -- the method using the emtpy list. This is required because the OLE2 bean requires
    -- an argument list. If no arguments are required, we just pass an empty argument list.
    if (arglist = 0) or (arglist is null) or (arglist='') then
      v_arglist := create_arglist;
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',v_arglist);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',method);
    v_javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_INVOKE_OBJ');
    if (v_javaHandle='') or (v_javaHandle=-1) or (v_javaHandle is null) then
      raise OLE_ERROR;
    end if;    

    v_objHandle := to_number(v_javaHandle);
    return(v_objHandle);

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.invoke_obj will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END invoke_obj;        


  /* Overloaded procedure used to set the property of an OLE Server to a String value */
  PROCEDURE set_property (object IN obj_type,property IN VARCHAR2,value IN VARCHAR2,arglist IN list_type := 0) IS
    v_str varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;

    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    if (value is null) or (value = '') then
       if (OLE_NULL_COMPATIBILITY) then
       v_str := value;
     else
       RAISE OLE_ERROR;
     end if;    
    else
      -- Prefix string property values with 'S' as an indicator to the OLE bean
      v_str := 'S'||value;
    end if;    

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist=0) then
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY',v_str);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY_ARGS',v_str);
    end if;    

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.set_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END set_property;        


  /* Overloaded procedure used to set a property in an OLE Server to a numeric value */
  PROCEDURE set_property (object IN obj_type,property IN VARCHAR2,value IN NUMBER,arglist IN list_type := 0) IS
    v_str varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    if (value is null) or (value='') then
      RAISE OLE_ERROR;
    else
      -- Prefix numeric property values with 'N' as an indicator to the OLE bean
      v_str := 'N'||to_char(value);
    end if;    

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist=0) then
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY',v_str);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY_ARGS',v_str);
    end if;    

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.set_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END set_property;        


  /* Overloaded procedure used to set the value of an OLE server to true or false */
  PROCEDURE set_property (object IN obj_type,property IN VARCHAR2,value IN BOOLEAN,arglist IN list_type := 0) IS
    v_str varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;

    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;     

    if (value is null) then
      RAISE OLE_ERROR;
    else    
      -- Prefix boolean property values with 'B' as an indicator to the OLE bean
      v_str := 'B'||Webutil_util.BoolToStr(value);
    end if;    

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist=0) then
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY',v_str);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_SET_PROPERTY_ARGS',v_str);
    end if;    

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.set_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END set_property;        



  /* Function used to get the numeric value of a property */
  FUNCTION get_num_property (object IN obj_type, property IN VARCHAR2, arglist IN list_type := 0) return NUMBER IS
    v_javares varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;
    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;     

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist = 0) then
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY');
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY_ARGS');
    end if;

    if (v_javares is null) or (v_javares ='') then
      raise OLE_ERROR;
    else     
      return(to_number(v_javares));
    end if; 

  EXCEPTION 
  when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                            ||' bean not found. CLIENT_OLE2.get_num_property will not work');
    RAISE OLE_ERROR; 
  when WebUtil_Core.PROPERTY_ERROR then 
    RAISE OLE_ERROR;
  when VALUE_ERROR then
    RAISE OLE_ERROR; 
  when OLE_ERROR then 
    RAISE FORM_TRIGGER_FAILURE;

  END get_num_property;    


  /* Function used to get the string value of a property */
  FUNCTION get_char_property (object IN obj_type, property IN VARCHAR2, arglist IN list_type := 0) return VARCHAR2 IS
    v_javares varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;
    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;     

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist = 0) then
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY');
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY_ARGS');
    end if;

    return(v_javares);

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.get_char_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END get_char_property;        


  /* Function used to get the object handle value of a property */
  FUNCTION get_obj_property (object IN obj_type, property IN VARCHAR2, arglist IN list_type := 0) return OBJ_TYPE IS
    v_javaHandle varchar2(6);
    v_objectHandle OBJ_TYPE;
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;

    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;     

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist = 0) then
      v_javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_OBJ_PROPERTY');
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      v_javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_OBJ_PROPERTY_ARGS');
    end if;

    if (v_javaHandle = 0) or (v_javaHandle='') or (v_javaHandle=-1) then
      raise OLE_ERROR;
    end if;    

    v_objectHandle := to_number(v_javaHandle);
    return(v_objectHandle);

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.get_obj_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END get_obj_property;        


  /* Function used to get the boolean value of a property */
  FUNCTION get_bool_property (object IN obj_type, property IN VARCHAR2, arglist IN list_type := 0) return BOOLEAN IS
    v_javares varchar2(4000 char);
  BEGIN
    if (object is null) or (object = '') then
      raise OLE_ERROR;
    end if;

    if (property is null) or (property = '') then
      raise OLE_ERROR;
    end if;     

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',object);
    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_PROPNAME',property);
    if (arglist is null) or (arglist = '') or (arglist = 0) then
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY');
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_HANDLE',arglist);
      v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_GET_PROPERTY_ARGS');
    end if; 

    if (v_javares is null) or (v_javares = '')  then
      raise OLE_ERROR;
    end if;

    if (v_javares = 'true') or (v_javares = '-1') then
      return true;
    else
      return false;
    end if;

  EXCEPTION 
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.get_bool_property will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END get_bool_property;    


  /* Procedure used to destroy an OLE Object */
  PROCEDURE release_obj(object IN OBJ_TYPE)IS
  BEGIN
    if (object is null) or (object='')or (object = -1) then
      raise OLE_ERROR;
    end if;  

    WebUtil_Core.setProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_RELEASE_OBJ',object);

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUO_PACKAGE)
                              ||' bean not found. CLIENT_OLE2.release_obj will not work');
      RAISE OLE_ERROR; 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE OLE_ERROR;
    when VALUE_ERROR then
      RAISE OLE_ERROR; 
    when OLE_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;

  END release_obj;


  /* Function which checks whether OLE is supported on the platform or not */
  FUNCTION IsSupported return BOOLEAN is
    v_os_family PLS_INTEGER;
  BEGIN
    v_os_family := WebUtil_Core.GetClientOsFamily();
    if ( v_os_family = WebUtil_Core.CLIENT_PLATFORM_WIN32) then
      return true;
    else
      return false;
    end if;

  END IsSupported;


  /* This procedure is not available in conventional OLE2. It is used to persist the OLE Object when the
  OLE2 bean gets destroyed. This allows you to use the OLE Object across multiple forms */
  PROCEDURE persist_ole_handle(object OBJ_TYPE) IS
  BEGIN
    if (object is null) or (object ='') or (object = -1) then
      raise OLE_ERROR;
    end if;        

    WebUtil_Core.PersistReference(WebUtil_Core.WUO_PACKAGE,object);
  EXCEPTION
    WHEN OLE_ERROR THEN
      raise FORM_TRIGGER_FAILURE;    

  END persist_ole_handle;    


  /* Function returns the OLE error number generated by the last OLE exception */
  FUNCTION last_exception return NUMBER IS
    v_javares VARCHAR2(4000 char);
    v_errnum number;
  BEGIN
    v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ERROR');
    v_errnum := delimstr.getnumber(v_javares,1);
    return(v_errnum);

  END last_exception;    


  /* Function returns the OLE error number and error message generated by the last OLE exception */
  FUNCTION last_exception(message OUT VARCHAR2) return NUMBER IS
    v_javares VARCHAR2(4000 char);
    v_errnum number;
    v_errmsg VARCHAR2(4000 char);
  BEGIN
    v_javares := WebUtil_Core.getProperty(WebUtil_Core.WUO_PACKAGE,'WUO_OLE2_ERROR');
    v_errnum := delimstr.getstring(v_javares,1);
    v_errmsg := delimstr.getstring(v_javares,2);
    message := v_errmsg;
    return(v_errnum);
  END last_exception;    


BEGIN
  -- Added DRMILLS - Force explicit instanciation of the CORE package
  WebUtil_Core.Init;     
END;


PACKAGE CLIENT_TEXT_IO IS
/*********************************************************************************\
 * CLIENT_TEXT_IO
 *   This package duplicates the action of the TEXT_IO package, except that it 
 *   operates on the client (browser) tier rather than the application server tier.  
 *   Existing TEXT_IO code can be re-directed to run on the client simply by 
 *   prefixing all the calls with "CLIENT_" 
 *   The functions in this package will work with any client type - not just 
 *   Windows clients.
 *   The oracle.forms.webutil.file.FileFunctions bean is needed in your 
 *   Form to use these functions
  *********************************************************************************
 * Version 1.0.2
 *********************************************************************************
 * Change History
 *   1.0.0  DRMILLS 21/DEC/2002 - Creation 
 *   1.0.1  DRMILLS 31/JAN/2003 - Added function to allow a File_Type to
 *                                be persisted across Forms
 *                                (fclose will still clean it up)
 *   1.0.2  DRMILLS 13/MAY/2003 - Added Call to WebUtil_Core.Init
\*********************************************************************************/

  /** 
   * The TEXT_IO file type
   */
  TYPE file_type IS RECORD (handle PLS_INTEGER);
  
  /** 
   * File lifetime functions
   */
  FUNCTION fopen(spec VARCHAR2, filemode VARCHAR2, charSet VARCHAR2 := null) RETURN file_type;
  
  FUNCTION is_open(file file_type) RETURN BOOLEAN;
 
  PROCEDURE fclose (file IN OUT file_type);
  
  -- ## This is not part of traditional TEXT_IO ##
  PROCEDURE persist_file_handle(file file_type);
  
  /**
   * File reading functions
   */
  PROCEDURE get_line (file file_type, item OUT VARCHAR2);
  
  /**
   * File writing functions
   */
  PROCEDURE put (file file_type, item VARCHAR2);
  PROCEDURE put (file file_type, item DATE);
  PROCEDURE put (file file_type, item NUMBER);
  
  PROCEDURE new_line (file file_type, n PLS_INTEGER := 1);

  PROCEDURE put_line (file file_type, item VARCHAR2);
  
  
  procedure putf (file   file_type, 
                  arg    VARCHAR2);
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2);
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2);
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2);
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2);
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2,
                  arg5   VARCHAR2);
   
 /** 
  * Console writing functions.
  * In client server versions of Forms these only write to the debug console
  * when running in debug mode.
  * To provide parity, when running on the web these get sent to the Java Console 
  * of the Client Side JVM, which is actually more useful than the client server 
  * behaviour
  */   
  PROCEDURE put (item VARCHAR2);
  PROCEDURE put (item DATE);
  PROCEDURE put (item NUMBER);
  
  PROCEDURE new_line (n PLS_INTEGER := 1);

  PROCEDURE put_line (item VARCHAR2);
  
  
  procedure putf (arg    VARCHAR2);
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2);
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2);
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2);
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2);
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2,
                  arg5   VARCHAR2);
END CLIENT_TEXT_IO;


PACKAGE BODY CLIENT_TEXT_IO IS
  -- PACKAGE Vars
  CONSOLE FILE_TYPE;

  /** 
   * File lifetime functions
   */
  FUNCTION fopen(spec VARCHAR2, filemode VARCHAR2, charSet VARCHAR2 := null) RETURN file_type is
    clientFile file_type;
    javaHandle VARCHAR2(6);
  BEGIN
    -- check the mode is valid
    if (lower(filemode) not in ('r','w','a')) then 
      raise TOOL_ERR.TOOL_ERROR;
    end if;

    -- make sure a file name has been specified      
    if (spec is null) or (spec='') then
      raise TOOL_ERR.TOOL_ERROR;
    end if;
      
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',spec, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_FILEMODE',filemode, true);        
    if (charSet is null) then
        WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_CHARSET','(null)', true);
    else
        WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_CHARSET',charSet, true);
    end if;
    javaHandle := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_OPEN');

    -- If the return is null then the file was not opened      
    if (javaHandle is null) or (javaHandle='') or (javaHandle='-1') then
      raise TOOL_ERR.TOOL_ERROR;
    end if;

    -- if we are this far convert the handle to the correct format and return it.      
    clientFile.handle := to_number(javaHandle);
    return clientFile;

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.fopen will not work');
    RAISE TOOL_ERR.TOOL_ERROR;                                 
      return null;
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE;
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
    when TOOL_ERR.TOOL_ERROR then 
      RAISE;
  END fopen; 
  
  FUNCTION is_open(file file_type) RETURN BOOLEAN IS
  BEGIN
    IF file.handle IS NULL THEN
      RETURN(FALSE);
    ELSE
      RETURN(TRUE);
    END IF;
  END is_open;
 
  PROCEDURE fclose (file IN OUT file_type) is 
  BEGIN 
    if (file.handle IS NOT NULL) then 
      WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_CLOSE',file.handle);        
      file.handle := NULL;
    end if;
 
 EXCEPTION
  when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                            ||' bean not found. CLIENT_TEXT_IO.fclose will not work');
    RAISE TOOL_ERR.TOOL_ERROR;                                                                 
  when WebUtil_Core.PROPERTY_ERROR then 
    RAISE TOOL_ERR.TOOL_ERROR;
  END fclose;
  
  
  PROCEDURE persist_file_handle(file file_type) is
  BEGIN
    WebUtil_Core.PersistReference(WebUtil_Core.WUF_PACKAGE,file.handle);
  END persist_file_handle;  
  
  /**
   * File reading functions
   */
  PROCEDURE get_line (file file_type, item OUT VARCHAR2) is
    buffer VARCHAR2(4000 char);
  BEGIN 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);        
    buffer := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_GETLINE');
    -- We can't easily tell the difference between an empty line and a line beyond then 
    -- end of the file so to get around this, the exception handling code in the PJC 
    -- places a newline into the buffer when the end of file is passed.
    -- The rational being that get_line would never normally return a newline because 
    -- it normally uses that to tell it where to read up *to*.
    if buffer = chr(10) then 
      raise NO_DATA_FOUND;
    else
      item := buffer;
    end if;

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.get_line will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END get_line;
  
  /**
   * File writing functions
   */
  PROCEDURE put (file file_type, item VARCHAR2) IS
  BEGIN 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUT',item);        
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.put will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END put;
  
  PROCEDURE put (file file_type, item DATE) is
  BEGIN
    -- rely in the setting of PLSQL_DATE_FORMAT to 
    -- define the output mask for the date.
    CLIENT_TEXT_IO.put(file, to_char(item));
  END put;
  
  PROCEDURE put (file file_type, item NUMBER) is
  BEGIN
    CLIENT_TEXT_IO.put(file, to_char(item));
  END put;
  
  
  PROCEDURE new_line (file file_type, n PLS_INTEGER := 1) is
  BEGIN 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_NEWLINE',n);      
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.new_line will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END new_line;
    

  PROCEDURE put_line (file file_type, item VARCHAR2) is
  BEGIN 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUT',item); 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_NEWLINE',1); 
  EXCEPTION
  when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                            ||' bean not found. CLIENT_TEXT_IO.put_line will not work');
    RAISE TOOL_ERR.TOOL_ERROR;                                                                 
  when WebUtil_Core.PROPERTY_ERROR then 
    RAISE TOOL_ERR.TOOL_ERROR;  
  END put_line;
   
  
  
  procedure putf (file   file_type, 
                  arg    VARCHAR2) is 
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',arg); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;
                  
  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg1);        
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',format); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;

  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg1);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg2);        
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',format); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;

  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg1);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg2);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg3);        
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',format); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;

  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg1);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg2);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg3);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg4);                
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',format); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;

  procedure putf (file   file_type, 
                  format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2,
                  arg5   VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_HANDLE',file.handle);              
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg1);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg2);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg3);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg4);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_ARG',arg5);                
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_TEXTIO_PUTF',format); 
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. CLIENT_TEXT_IO.putf will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                                                 
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE TOOL_ERR.TOOL_ERROR;  
  END putf;     
 
  -- Console functions - these reuse the above calls but using a "Magic" file handle
  PROCEDURE put (item VARCHAR2) is
  BEGIN
    put(CONSOLE,item);
  END put;
  
  PROCEDURE put (item DATE) is
  BEGIN
    put(CONSOLE,item);
  END put;
  
  PROCEDURE put (item NUMBER) is
  BEGIN
    put(CONSOLE,item);
  END put;
  
  PROCEDURE new_line (n PLS_INTEGER := 1) is
  BEGIN
    new_line(CONSOLE,n);
  END new_line;

  PROCEDURE put_line (item VARCHAR2) is
  BEGIN
    put_line(CONSOLE,item);
  END put_line;
  
  
  procedure putf (arg    VARCHAR2) is
  BEGIN
    putf(CONSOLE,arg);
  END putf;
  
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2) is
  BEGIN
    putf(CONSOLE,format,arg1);
  END putf;
  
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2) is
  BEGIN
    putf(CONSOLE,format,arg1,arg2);
  END putf;
  
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2) is
  BEGIN
    putf(CONSOLE,format,arg1,arg2,arg3);
  END putf;
  
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2) is
  BEGIN
    putf(CONSOLE,format,arg1,arg2,arg3,arg4);
  END putf;
  
  procedure putf (format VARCHAR2,
                  arg1   VARCHAR2,
                  arg2   VARCHAR2,
                  arg3   VARCHAR2,
                  arg4   VARCHAR2,
                  arg5   VARCHAR2) is
  BEGIN
    putf(CONSOLE,format,arg1,arg2,arg3,arg4,arg5);
  END putf;  
  
BEGIN
  -- Set up the magic file handle for writing to the Java Console      
  CONSOLE.handle := -2;      
  -- Explicitly instantiate the Core
  WebUtil_Core.Init;
END CLIENT_TEXT_IO;


PACKAGE CLIENT_TOOL_ENV IS
/*********************************************************************************\
 * CLIENT_TOOL_ENV
 *   This package duplicates the action of the TOOL_ENV package, except that it 
 *   operates on the client (browser) tier rather than the application server tier.  
 *   Existing TOOL_ENV code  can be re-directed to run on the client simply by 
 *   prefixing all the calls with "CLIENT_" 
 *********************************************************************************
 * Version 1.0.1
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 03/JAN/2003 - Creation
 *   1.0.1 DRMILLS 27/FEB/2003 - Added Windows Client Implementation   
 *
\*********************************************************************************/

/*-------------------------------------------------------------------------*\
 * GetVar -> Get environment variable
 * Arguments: 
 *  VARNAME     -> Variable name to be expanded
 *  VARVALUE    -> Expanded value of the variable. It will have null if the
 *                 variable is not defined or the value is too long.
 * Note:
 *  On Windows, it will raise ERROR 941 if the value of the variable
 *  exceeds the maximum length allowed as mentioned in the
 *  CLIENT_WIN_API_ENVIRONMENT.GET_ENVIRONMENT_STRING
\*-------------------------------------------------------------------------*/
  PROCEDURE GETVAR(VARNAME IN VARCHAR2, VARVALUE IN OUT VARCHAR2);
END;


PACKAGE BODY CLIENT_TOOL_ENV IS

  PROCEDURE GETVAR(VARNAME IN VARCHAR2, VARVALUE IN OUT VARCHAR2) is
    unixOutput WebUtil_HOST.OUTPUT_ARRAY;
    hostHandle WebUtil_HOST.PROCESS_ID;
    varKey     VARCHAR2(100);
    iPos       PLS_INTEGER;
  BEGIN
    if WebUtil_Core.GetClientOSFamily = WebUtil_Core.CLIENT_PLATFORM_WIN32 then 
      -- read the client Registry
      VARVALUE := Client_Win_API_Environment.read_registry('HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE',VARNAME,false);
      if VARVALUE is null OR VARVALUE = '' then
        -- Could not get an Oracle variable in registry. Try to get from environment varialble
        -- java desupported System.getenv method until they supported it again in 1.5.
        -- We can still get the environment variables in windows using
        -- CLIENT_WIN_API_ENVIRONMENT.GET_ENVIRONMENT_STRING
        VARVALUE := CLIENT_WIN_API_ENVIRONMENT.GET_ENVIRONMENT_STRING(VARNAME);
      end if;
    elsif WebUtil_Core.GetClientOSFamily in (WebUtil_Core.CLIENT_PLATFORM_MAC,WebUtil_Core.CLIENT_PLATFORM_UNKNOWN) then 
      -- do nothing 
      null;
    else
      -- Unix Ports - do a env to get the environment and parse that
      hostHandle := WebUtil_HOST.Blocking('env');
      unixOutput := WebUtil_HOST.Get_Standard_Output(hostHandle);
      WebUtil_HOST.Release_Process(hostHandle);
      for i in 1..unixOutput.count LOOP
        iPos := instr(unixOutput(i),'=');
        if iPos > 0 then 
          varKey := substr(unixOutput(i),1,iPos-1);
          if varKey = VARNAME then 
            VARVALUE := substr(unixOutput(i),iPos+1);
            EXIT;
          end if;
        end if;
      end LOOP;
    end if;

  exception
    when NO_DATA_FOUND then
      VARVALUE := null;
  END GETVAR;

END CLIENT_TOOL_ENV;


PACKAGE Client_Win_API IS
/*-------------------------------------------------------------------------------*\
 * WebUtil version of D2KWUTIL package WIN_API                                     
 * Note: Not all D2kWutil Functions are ported
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   DRMILLS 21/FEB/2003 - Port Creation
 *
 *********************************************************************************
 * WIN_API ->  This package defines the constants used throughout 
 *      the library as a whole, including versions of those 
 *      constants defined within WINDOWS.H/WINUSER.H that 
 *      we'll be using. Add more constants in here if required
 *      The package also contains Explicit Exception declarations,
 *      various status Flags and functions for Error Handling
 * NOTE:    In order to make this library portable across Forms
 *      and Reports we do not use any application 
 *      specific built-ins such as the Forms MESSAGE() 
 *      Built-in. Instead errors are recorded in a package
 *      variable which the programmer can examine if required
\*-------------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------------*\
 * Internal Version Number  ** Oracle Developer Release 6.0 Version
\*-------------------------------------------------------------------------------*/
  WIN_API_VERSION  CONSTANT  VARCHAR2(30) := '6.0.6.0 Production';
  DLL_NAME         CONSTANT  VARCHAR2(12) := 'd2kwut60.dll';
  DLL_PATH         VARCHAR2(256)          := NULL;


/*-------------------------------------------------------------------------------*\
 * General Window Classes of Common Applications for use with WIN_API_SESSION
 * ** WARNING ** These Window classes are out of our control and might change 
 *               when you upgrade the software in question,
\*-------------------------------------------------------------------------------*/

  -- Oracle Apps
  WINCLASS_DEVELOPER_2000_V1  CONSTANT  VARCHAR2(15)  := 'ui23MDIroot_W32';             /* Developer/2000 release 1.n / Toolkit 2.3 Apps on 32 bit */
  WINCLASS_DEVELOPER_2000_V2  CONSTANT  VARCHAR2(15)  := 'ui25MDIroot_W32';             /* Developer/2000 Release 2.0 / Toolkit 2.5 Apps on 32 bit */
  WINCLASS_DEVELOPER_2000_V6  CONSTANT  VARCHAR2(15)  := 'ui60MDIroot_W32';             /* Developer/2000 Release 6.0 / Toolkit 6.0 Apps on 32 bit */  
  D2K_WINDOW_CLASS            CONSTANT  VARCHAR2(15)  := WINCLASS_DEVELOPER_2000_V6;    /* Set to the "current" version */  
  WINCLASS_INTEROFFICE_40     CONSTANT  VARCHAR2(28)  := 'Afx:10000000:b:10008:6:5023b';/* Oracle Interoffice 4.0 Client 32 bit */
  WINCLASS_INTEROFFICE_41     CONSTANT  VARCHAR2(28)  := 'Afx:10000000:b:1496:6:3a17';  /* Oracle Interoffice 4.0 Client 32 bit */
  WINCLASS_SQLPLUS            CONSTANT  VARCHAR2(13)  := 'SqlplusWClass';               /* Sql*Plus 32 bit */
  WINCLASS_REPORTSSERVER_V1   CONSTANT  VARCHAR2(15)  := 'R25SRV_WINCLASS';             /* Reports Server Reports 2.5 */
  WINCLASS_REPORTSSERVER_V2   CONSTANT  VARCHAR2(15)  := 'R30SRV_WINCLASS';             /* Reports Server Reports 3.0 */
  WINCLASS_REPORTSSERVER_V6   CONSTANT  VARCHAR2(14)  := 'RWRBE_WINCLASS';              /* Reports Server Reports 6.0 */

  -- Microsoft Office Apps - Office97
  WINCLASS_MSWORD_97         CONSTANT  VARCHAR2(7) := 'OpusApp';                        /* Microsoft Word 97 */
  WINCLASS_MSEXCEL_97        CONSTANT  VARCHAR2(6) := 'XLMAIN';                         /* Microsoft Excel 97 */
  WINCLASS_MSPOWERPOINT_97   CONSTANT  VARCHAR2(14):= 'PP97FrameClass';                 /* Microsoft Power Point 97 */


  -- Microsoft Office Apps - Office95
  WINCLASS_MSWORD_7          CONSTANT  VARCHAR2(7) := 'OpusApp';                        /* Microsoft Word 7 */
  WINCLASS_MSEXCEL_7         CONSTANT  VARCHAR2(6) := 'XLMAIN';                         /* Microsoft Excel 7 */
  WINCLASS_MSPOWERPOINT_7    CONSTANT  VARCHAR2(13):= 'PP7FrameClass';                  /* Microsoft Power Point 7 */
  WINCLASS_MSSCHEDULE_7      CONSTANT  VARCHAR2(23):= 'MS Schedule+ 32 Panesdi';        /* Microsoft Schedule 7 */
  WINCLASS_MSEXCHANGE_4      CONSTANT  VARCHAR2(29):= 'Microsoft Exchange 4.0 Viewer';  /* Microsoft Exchange 4 in-tray */


  -- Microsoft O/S Utilities
  WINCLASS_INETEXPLORER      CONSTANT  VARCHAR2(7):= 'IEFrame';                         /* Internet Explorer */
  WINCLASS_OUTLOOK_EXPRESS   CONSTANT  VARCHAR2(29):= 'Outlook Express Browser Class';  /* Outlook Express */
  WINCLASS_EXPLORER          CONSTANT  VARCHAR2(13):= 'ExploreWClass';                  /* Explorer */
  WINCLASS_MYCOMPUTER        CONSTANT  VARCHAR2(13):= 'CabinetWClass';                  /* My Computer & Network Neighborhood*/
  WINCLASS_CALCULATOR        CONSTANT  VARCHAR2(7) := 'SciCalc';                        /* Windows Calculator */
  WINCLASS_NOTEPAD           CONSTANT  VARCHAR2(7) := 'Notepad';                        /* Windows Notepad */
  WINCLASS_WORDPAD           CONSTANT  VARCHAR2(12):= 'WordPadClass';                   /* Windows Wordpad/Write */
  WINCLASS_DOS               CONSTANT  VARCHAR2(18):= 'ConsoleWindowClass';             /* Dos Window */

  -- Other
  WINCLASS_NETSCAPE_3        CONSTANT  VARCHAR2(27):= 'Afx:40000000:b:150e:6:38cfe';    /* Netscape Navigator 3.0 */
  WINCLASS_NETSCAPE_4        CONSTANT  VARCHAR2(28):= 'Afx:40000000:b:10008:6:6063e';   /* Netscape Communicator 4.0 */
  WINCLASS_PFE_7             CONSTANT  VARCHAR2(11):= 'PFE32_Frame';                    /* Programmers File Editor */
  WINCLASS_REGEDIT           CONSTANT  VARCHAR2(15):= 'RegEdit_RegEdit';                /* Registry Editor */


  -- Window Style Constants (from WINUSER.H)
  --  Any PU's that use these constants will explain 
  --  their use.  For further information consult the
  --  Windows SDK.

  SW_HIDE              CONSTANT  PLS_INTEGER := 0;
  SW_SHOWNORMAL        CONSTANT  PLS_INTEGER := 1;
  SW_SHOWMINIMIZED     CONSTANT  PLS_INTEGER := 2;
  SW_SHOWMAXIMIZED     CONSTANT  PLS_INTEGER := 3;
  SW_SHOWNOACTIVATE    CONSTANT  PLS_INTEGER := 4;
  SW_SHOW              CONSTANT  PLS_INTEGER := 5;
  SW_MINIMIZE          CONSTANT  PLS_INTEGER := 6;
  SW_SHOWMINNOACTIVE   CONSTANT  PLS_INTEGER := 7;
  SW_SHOWNA            CONSTANT  PLS_INTEGER := 8;
  SW_RESTORE           CONSTANT  PLS_INTEGER := 9;
  SW_SHOWDEFAULT       CONSTANT  PLS_INTEGER := 10;

  -- Help Access Constants (From WINUSER.H)
  --  See WIN_API_SHELL.WinHelp

  HELP_CONTEXT         CONSTANT  PLS_INTEGER := 1;   /* 0x0001L */
  HELP_QUIT            CONSTANT  PLS_INTEGER := 2;   /* 0x0002L */
  HELP_INDEX           CONSTANT  PLS_INTEGER := 3;   /* 0x0003L */
  HELP_CONTENTS        CONSTANT  PLS_INTEGER := 3;   /* 0x0003L */
  HELP_HELPONHELP      CONSTANT  PLS_INTEGER := 4;   /* 0x0004L */
  HELP_SETINDEX        CONSTANT  PLS_INTEGER := 5;   /* 0x0005L */
  HELP_SETCONTENTS     CONSTANT  PLS_INTEGER := 5;   /* 0x0005L */
  HELP_CONTEXTPOPUP    CONSTANT  PLS_INTEGER := 8;   /* 0x0008L */
  HELP_FORCEFILE       CONSTANT  PLS_INTEGER := 9;   /* 0x0009L */
  HELP_KEY             CONSTANT  PLS_INTEGER := 257; /* 0x0101L */
  HELP_COMMAND         CONSTANT  PLS_INTEGER := 258; /* 0x0102L */
  HELP_PARTIALKEY      CONSTANT  PLS_INTEGER := 261; /* 0x0105L */
  HELP_MULTIKEY        CONSTANT  PLS_INTEGER := 513; /* 0x0201L */
  HELP_SETWINPOS       CONSTANT  PLS_INTEGER := 515; /* 0x0203L */
  -- Windows 4+
  HELP_CONTEXTMENU     CONSTANT  PLS_INTEGER := 10;  /* 0x000a  */
  HELP_FINDER          CONSTANT  PLS_INTEGER := 11;  /* 0x000b  */
  HELP_WM_HELP         CONSTANT  PLS_INTEGER := 12;  /* 0x000c  */
  HELP_SETPOPUP_POS    CONSTANT  PLS_INTEGER := 13;  /* 0x000d  */


  -- Windows Messages for use with SendMessage
  -- DO NOT utilise the Windows Sendmessage interface without being conversant
  -- with the Windows message handling mechanism
  -- Refer to the Microsoft Windows SDK for Messages and Parameter values
  WM_SYSCOMMAND        CONSTANT  PLS_INTEGER := 274;   /* 0x0112 */
  WM_MDITILE           CONSTANT  PLS_INTEGER := 550;   /* 0x0226 */
  WM_MDICASCADE        CONSTANT  PLS_INTEGER := 551;   /* 0x0227 */
  WM_MDIICONARRANGE    CONSTANT  PLS_INTEGER := 552;   /* 0x0228 */      
  SC_RESTORE           CONSTANT  PLS_INTEGER := 61728; /* 0xF120 */
  SC_MINIMIZE          CONSTANT  PLS_INTEGER := 61472; /* 0xF020 */
  SC_MAXIMIZE          CONSTANT  PLS_INTEGER := 61488; /* 0xF030 */
  


  -- Flags for use with File Dialog boxes ("Save As" or "Open")
  -- Refer to your Microsoft documentation for details on the 
  -- Exact usage and dependancies of each option
  OFN_READONLY           CONSTANT  PLS_INTEGER := 1;        /* 0x00000001 */
  OFN_OVERWRITEPROMPT    CONSTANT  PLS_INTEGER := 2;        /* 0x00000002 */
  OFN_HIDEREADONLY       CONSTANT  PLS_INTEGER := 4;        /* 0x00000004 */
  OFN_NOCHANGEDIR        CONSTANT  PLS_INTEGER := 8;        /* 0x00000008 */
  OFN_SHOWHELP           CONSTANT  PLS_INTEGER := 16;       /* 0x00000010 */
  OFN_NOVALIDATE         CONSTANT  PLS_INTEGER := 256;      /* 0x00000100 */
  OFN_ALLOWMULTISELECT   CONSTANT  PLS_INTEGER := 512;      /* 0x00000200 */
  OFN_EXTENSIONDIFFERENT CONSTANT  PLS_INTEGER := 1024;     /* 0x00000400 */
  OFN_PATHMUSTEXIST      CONSTANT  PLS_INTEGER := 2048;     /* 0x00000800 */
  OFN_FILEMUSTEXIST      CONSTANT  PLS_INTEGER := 4096;     /* 0x00001000 */
  OFN_CREATEPROMPT       CONSTANT  PLS_INTEGER := 8192;     /* 0x00002000 */
  OFN_SHAREAWARE         CONSTANT  PLS_INTEGER := 16384;    /* 0x00004000 */
  OFN_NOREADONLYRETURN   CONSTANT  PLS_INTEGER := 32768;    /* 0x00008000 */
  OFN_NOTESTFILECREATE   CONSTANT  PLS_INTEGER := 65536;    /* 0x00010000 */
  OFN_NONETWORKBUTTON    CONSTANT  PLS_INTEGER := 131072;   /* 0x00020000 */
  OFN_NOLONGNAMES        CONSTANT  PLS_INTEGER := 262144;   /* 0x00040000 */
  OFN_EXPLORER           CONSTANT  PLS_INTEGER := 524288;   /* 0x00080000 */
  OFN_NODEREFERENCELINKS CONSTANT  PLS_INTEGER := 1048576;  /* 0x00100000 */
  OFN_LONGNAMES          CONSTANT  PLS_INTEGER := 2097152;  /* 0x00200000 */

  -- The defaults used here (WIN_API.OFN_PATHMUSTEXIST|WIN_API.OFN_FILEMUSTEXIST|WIN_API.OFN_HIDEREADONLY|WIN_API.OFN_NOCHANGEDIR|WIN_API.OFN_EXPLORER)
  OFN_FLAG_DEFAULT       CONSTANT  PLS_INTEGER :=  530444;
  
  
  -- Registry Data types for Write_RegistryEx
  REG_EXPAND_SZ          CONSTANT  PLS_INTEGER := 0;
  REG_SZ                 CONSTANT  PLS_INTEGER := 1;
  REG_DWORD              CONSTANT  PLS_INTEGER := 2;
  
  -- Compatibility Flags - Used where I have changed behaviour and you might not like the new version
  -- Change these at runtime to FALSE to revert to "old" behaviour
  COMPAT_EXPAND_REG_VALUES    BOOLEAN := TRUE;

  
  
  -- Types
  TYPE aFunctionHandle is table of WEBUTIL_C_API.FUNCTIONHANDLE index by BINARY_INTEGER;  
  SUBTYPE FILE_TYPE is PLS_INTEGER;

  -- Public Variables
  ERROR_ENCOUNTERED  BOOLEAN := FALSE;  /* The Last Call resulted in an error */
  ERROR_STACK        VARCHAR2(2000);    /* Holds Text of Last error(s) */ 
  API_ENABLED        BOOLEAN := FALSE;   /* Are API functions usable ?*/
  DLL_HANDLE         ORA_FFI.LibHandleType;
  FunctionHandle     aFunctionHandle;
   

  -- Public Exceptions
  NOT_AVAILABLE      EXCEPTION;  /* A call to the API was made but API functions not currently available (e.g. not on Windows) */
     
  -- Error Constants
  UError             CONSTANT  VARCHAR2(30) := ' Caused an unexpected error: ';
  NoAPI              CONSTANT  VARCHAR2(31) := 'API Functions are not Available';
  MaxDWord           CONSTANT  VARCHAR2(33) := 'Integer Argument exceeds 32 bits ';
  MaxWord            CONSTANT  VARCHAR2(33) := 'Integer Argument exceeds 16 bits ';
  MaxByte            CONSTANT  VARCHAR2(32) := 'Integer Argument exceeds 8 bits ';
  MinBound           CONSTANT  VARCHAR2(27) := 'Integer Argument too Small ';
  MaxBound           CONSTANT  VARCHAR2(27) := 'Integer Argument too Large ';
  NullArg            CONSTANT  VARCHAR2(24) := 'Argument cannot be NULL ';

  /*----------------------------------------------------------------------------*\
  * PreLoad ->  Loads the d2kwut60.dll from the jvm bin directory into memory
  \*----------------------------------------------------------------------------*/    
  PROCEDURE PreLoad(RaiseExceptions IN BOOLEAN DEFAULT TRUE);

  /*----------------------------------------------------------------------------*\
  * DLLVersion ->  Returns the Version String of the DLL in use. 
  \*----------------------------------------------------------------------------*/    
  FUNCTION DLLVersion return varchar2; 

  /*----------------------------------------------------------------------------*\
  * Clean_Error_Stack ->  Re-initialises the error mechanism
  \*----------------------------------------------------------------------------*/    
  PROCEDURE Clean_Error_Stack;

  /*----------------------------------------------------------------------------*\
  * Add_Error ->  Adds the text of the specified error to the 
  *        ERROR_STACK variable and sets the error Flag 
  *        ERROR_ENCOUTERED.
  \*----------------------------------------------------------------------------*/    
  PROCEDURE Add_Error (CallingFunction in VARCHAR2, SetErrorText in VARCHAR2);

  /*----------------------------------------------------------------------------*\
  * Add_External_Errors ->  If we get an unexpected error this funtion will 
  *        return a sting containing the error text
  \*----------------------------------------------------------------------------*/    
  FUNCTION Add_External_Errors return varchar2;

  /*----------------------------------------------------------------------------*\
  * Register_Function_Call ->  Ensures that the DLL is still loaded and
  *                            registers the function if required
  *                            Raises NO_DATA_FOUND if the library 
  *                            cannot be loaded
  \*----------------------------------------------------------------------------*/    
  PROCEDURE Register_Function_Call (FunctionID in PLS_INTEGER, 
                                   FunctionName in VARCHAR2,
                                   FunctionReturn in VARCHAR2, 
                                   FunctionArgs in VARCHAR2);

  /*----------------------------------------------------------------------------*\
  * StripDirSep ->  Removes trailing directory separators or 
  *        SemiColons from paths, providing a known format
  \*----------------------------------------------------------------------------*/    
  FUNCTION StripDirSep ( INPath in varchar2) return varchar2; 

  /*----------------------------------------------------------------------------*\
  * GetResource ->  Returns the name of the Resource requested Prefixed with  
  *                 The name of the DLL in the Correct Format
  *                 If the resource being requested is a Cursor then 
  *                 the D2kwutil DLL file *Must* be on the O/S Path
  \*----------------------------------------------------------------------------*/    
  FUNCTION GetResource (ResourceName in VARCHAR2) return VARCHAR2;
   
END Client_Win_API; /* End Package Declaration */


PACKAGE BODY Client_Win_API is

-- Function and Procedure Bodies

  PROCEDURE PreLoad(RaiseExceptions IN BOOLEAN DEFAULT TRUE) is
    vcVersion VARCHAR2(40);
  begin
   CLIENT_WIN_API_DEBUG.DebugLog(99,'PreLoad','Args: (None)');      
    vcVersion := DLLVersion;
  exception
    when NO_DATA_FOUND then
      CLIENT_WIN_API.Add_error('D2KWUTIL (Pre-Load)', CLIENT_WIN_API.NoAPI);
      if RaiseExceptions then
        raise;    
      end if;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_WIN_API.Add_error('D2KWUTIL (Pre-Load)', CLIENT_WIN_API.NoAPI);
      if RaiseExceptions then
        raise;
      end if;
    when others then
      CLIENT_WIN_API.Add_error('D2KWUTIL (Pre-Load)', CLIENT_WIN_API.UError||CLIENT_WIN_API.Add_External_errors); 
      if RaiseExceptions then
        raise;
      end if;
  end PreLoad;
 
  FUNCTION DLLVersion return varchar2 is
    args      WEBUTIL_C_API.ParameterList;
    param     WEBUTIL_C_API.ParameterHandle;
    vcVersion VARCHAR2(42) := rpad(' ',40);
  begin
    CLIENT_WIN_API_DEBUG.DebugLog(99,'DLLVersion','Args: <No Arguments>'); 
    CLIENT_WIN_API.Clean_Error_Stack;
    Register_function_call(1,'d2kwutil_Version','VOID','*CHAR');
    args := WEBUTIL_C_API.Create_Parameter_List;
    param := WEBUTIL_C_API.Add_parameter(args,
                                         WEBUTIL_C_API.C_CHAR_PTR,
                                         WEBUTIL_C_API.param_INOUT,
                                         vcVersion,
                                         40);
    WEBUTIL_C_API.Invoke(CLIENT_WIN_API.FunctionHandle(1),args);
    vcVersion := WEBUTIL_C_API.Get_Parameter_String(args,param);
    WEBUTIL_C_API.Destroy_Parameter_List(args);
    CLIENT_WIN_API_DEBUG.DebugLog(99,'DLLVersion','Result: Version='||vcVersion); 
    return vcVersion;
  end DLLVersion;

  PROCEDURE Clean_Error_Stack is 
  begin 
    -- just empty the variables
    ERROR_ENCOUNTERED  := FALSE;
    ERROR_STACK        := NULL;
  end Clean_Error_Stack;

  PROCEDURE Add_Error (CallingFunction in VARCHAR2, SetErrorText in VARCHAR2) is
  begin 
    -- Just watch for value errors 
    ERROR_ENCOUNTERED  := TRUE;
    ERROR_STACK    := CallingFunction||': '||substr(SetErrorText,1,1968);
    CLIENT_WIN_API_DEBUG.DebugLog(99,'Add_Error',ERROR_STACK);
  end Add_Error;

  FUNCTION Add_External_Errors return varchar2 is
    iCounter   pls_integer;
    vcErrBuff  varchar2(1968);
  begin 
    if tool_err.nerrors > 0 then 
      for iCounter in 1..tool_err.nerrors LOOP
        begin 
          vcErrBuff := vcErrBuff||chr(10)||tool_err.message;
        exception
          when VALUE_ERROR then 
            exit; /* String exceeds allowable buffer */
        end;
        tool_err.pop;
      end loop;
    elsif SQLERRM is not null then 
      vcErrBuff := chr(10)||SQLERRM; 
    end if;
    return vcErrBuff;
  end Add_External_Errors;


  PROCEDURE Register_Function_Call ( FunctionID     in PLS_INTEGER, 
                                     FunctionName   in VARCHAR2,
                                     FunctionReturn in VARCHAR2, 
                                     FunctionArgs   in VARCHAR2) is
    vcArgs  VARCHAR2(200);
    vcFrag  VARCHAR2(10);
    iOffset PLS_INTEGER;   
  begin 
    if (not FunctionHandle.exists(FunctionId)) then
      -- We need to go through the registration process.      
      -- Register the function with the DLL
      FunctionHandle(FunctionId) := Webutil_C_API.register_function(DLL_NAME,FunctionName);
    end if;
  end Register_Function_Call; 

  Function StripDirSep ( InPath in varchar2) return varchar2 is 
    vcPath  varchar2(500) := InPath;
  begin 
    -- Check and Strip SemiColons, we take everything
    -- Before the first Semicolon as our path
    if instr(vcPath,';') > 0 then
      vcPath := substr(vcPath,1,instr(vcPath,';') -1);
    end if;

    -- Check and Strip '\'
    if substr(vcPath,-1,1) = '\' then 
      vcPath := substr(vcPath,1,length(vcPath)-1);
    end if;

    return vcPath;
  end StripDirSep;

  FUNCTION GetResource (ResourceName in VARCHAR2) return VARCHAR2 is
  begin 
    Return '<'||substr(DLL_NAME,1,(instr(DLL_NAME,'.')-1))||'>'||ResourceName;
  end GetResource;

BEGIN
  -- no need to pre-load the DLL for the web implemenation
  if WebUtil_core.GetClientOSFamily = WebUtil_core.CLIENT_PLATFORM_WIN32 then 
    CLIENT_WIN_API.API_ENABLED := true;
  end if;
END Client_Win_API; /* End Package Body Win API */


PACKAGE Client_Win_API_Debug IS
  /*----------------------------------------------------------------------------*\
  * Debugging Functions
  * WebUtil version of D2KWUTIL package WIN_API_DEBUG                                     
  * Note: All debugging Levels etc are ignored - all output goes to the 
  * webutil_core log file now
  *********************************************************************************
  * Version 1.0.0
  *********************************************************************************
  * Change History
  *   DRMILLS 21/FEB/2003 - Port to WebUtil
  * 
  \*----------------------------------------------------------------------------*/


  /*----------------------------------------------------------------------------*\        
  * SetDebug ->  Enables/Disables the D2kwutil Internal Debugging
  *              You can Also use this for Debugging your own apps
  * Arguments:
  *    DebugType  0 = Normal State - No Debugging
  *               1 = Log
  *               2 = Log 
  *    DebugFile  IGNORED
  *    DebugLevel A numerical argument that allows you to impose "levels" of
  *               Debugging within a App. Use Values < 99. Level 99 will switch 
  *               on the Debug Calls in D2kwutil.
  *               During Debugging all messages with a level < DebugLevel will
  *               be processed. Higher Debug levels will be ignored.
  *    TimeStamp  Defines if the Logged messages should be prefixed with
  *               the current time.
  \*----------------------------------------------------------------------------*/

  PROCEDURE SetDebug( DebugType   IN PLS_INTEGER, 
                     DebugFile   IN VARCHAR2 DEFAULT NULL, 
                     DebugLevel  IN PLS_INTEGER DEFAULT 98,                        
                     TimeStamp   IN BOOLEAN DEFAULT FALSE);

  /*----------------------------------------------------------------------------*\
  * DebugLog ->  Logs the Debug Output either to a Text File (appends)
  *              Or to a Windows Debugger - Depending on the 
  *              value set by SetDebug
  \*----------------------------------------------------------------------------*/    
  PROCEDURE DebugLog (DebugLevel  IN PLS_INTEGER, 
                     LoggingCall IN VARCHAR2, 
                     LogString   IN VARCHAR2); 

  /*----------------------------------------------------------------------------*\
  * DebugPause -> If you are debugging this just switches it off
  *               use DebugResume to restart.
  *               Using Pause and Resume, it doesn't matter if you are actually
  *               Debugging or not. It'll only take effect if you are 
  *               Currently Debugging.
  *               The LogPause argument just allows you to put the fact that you
  *               are pausing into the debug log. 
  *               If this is FALSE then you'll never know that debugging was 
  *               paused.
  \*----------------------------------------------------------------------------*/    
  PROCEDURE DebugPause(LogPause in BOOLEAN := FALSE); 

  /*----------------------------------------------------------------------------*\
  * DebugResume -> Resumes Debugging
  *               The LogResume argument just allows you to put the fact that you
  *               are resuming into the debug log. 
  *               If this is FALSE then you'll never know that debugging was 
  *               resumed.
  \*----------------------------------------------------------------------------*/    
  PROCEDURE DebugResume(LogResume in BOOLEAN := FALSE); 

  /*----------------------------------------------------------------------------*\
  * BoolToChar ->  A utility function that can be used to convert a Boolean value
  * to its String equivilent e.g. BoolToChar(TRUE) returns 'TRUE'
  \*----------------------------------------------------------------------------*/       
  FUNCTION  BoolToChar(ThisBoolean IN BOOLEAN) return VARCHAR2;

  /*-------------------------------------------------------------------------*\
  * WinDebug  ->  Sends a debug message to a windows Debugger
  *
  * Arguments: 
  *  Text        -> String to send  
  * Returns:
  *  (NONE)
  \*-------------------------------------------------------------------------*/

  PROCEDURE WinDebug   (  Text  IN   VARCHAR2);


  /*----------------------------------------------------------------------------*\
  * DEBUG_API_ENABLED - Do no alter this variable it is used internally by
  *                     d2kwutil.
  \*----------------------------------------------------------------------------*/
  DEBUG_API_ENABLED  BOOLEAN := FALSE;
END;


PACKAGE BODY Client_Win_API_Debug IS

  -- Private Variables
  iDebugState         PLS_INTEGER    := 0;
  iDebugLevel         PLS_INTEGER    := 98;
  bDebugTimeStamp     BOOLEAN        := FALSE;
  bDebugPaused        BOOLEAN        := FALSE;
   

  PROCEDURE SetDebug( DebugType   IN PLS_INTEGER, 
                      DebugFile   IN VARCHAR2 DEFAULT NULL, 
                      DebugLevel  IN PLS_INTEGER DEFAULT 98,                        
                      TimeStamp   IN BOOLEAN DEFAULT FALSE) is
  begin 
    bDebugTimeStamp := TimeStamp;
    iDebugLevel     := DebugLevel;
    if DebugType > 0 then 
      iDebugState := 1;
      DebugLog(0,'SetDebug','Logging to File '||DebugFile);
    else 
      DebugLog(0,'SetDebug','Logging Stopped');
      iDebugState := 0;
    end if;
  end SetDebug;
   
  PROCEDURE DebugLog (DebugLevel  IN PLS_INTEGER, 
                      LoggingCall IN VARCHAR2, 
                      LogString   IN VARCHAR2) is
    vcDateStamp   VARCHAR2(10);
    vcDebugString VARCHAR2(2000);
    hFile         TEXT_IO.FILE_TYPE;
  begin
    if iDebugState = 0 then 
      NULL;
    elsif bDebugPaused then 
      NULL;
    elsif DebugLevel > iDebugLevel then 
      NULL;
    else
      -- Sort out the Datestamp    
      if bDebugTimeStamp then 
          vcDateStamp := to_char(SYSDATE,'HH24:MI:SS')||'> ';
      end if;

      -- Construct the final String
      vcDebugString := '<'||lpad(to_char(DebugLevel),2,0)||'> '||vcDateStamp||rpad(LoggingCall||':',30);
      vcDebugString := vcDebugString||substr(LogString,1,(2000-length(vcDebugString)));

      WebUtil_core.log('D2KWUTIL '||vcDebugString,false);
    end if;
  end DebugLog;
  
  PROCEDURE DebugPause(LogPause in BOOLEAN := FALSE) is
  begin 
    if LogPause then 
      DebugLog(0,'DebugPause','Pausing Debug output');
    end if;    
    bDebugPaused := TRUE;
  end DebugPause;

  PROCEDURE DebugResume(LogResume in BOOLEAN := FALSE) is
  begin 
    bDebugPaused := FALSE;
    if LogResume then 
      DebugLog(0,'DebugResume','Resuming Debug output');
    end if;
  end DebugResume;
  
  PROCEDURE WinDebug  (  Text  IN   VARCHAR2) is
  begin 
    -- no-op
    null;
  end WinDebug;

  FUNCTION  BoolToChar(ThisBoolean IN BOOLEAN) return VARCHAR2 is
  begin
    if ThisBoolean then 
      RETURN 'TRUE';
    else
      RETURN 'FALSE';
    end if;
  end BoolToChar;

END;


PACKAGE CLIENT_WIN_API_ENVIRONMENT IS

/*-----------------------------------------------------------------------------------*\
 * WebUtil version of D2KWUTIL package WIN_API_Environment                                     
 * Note: Not all D2kWutil Functions are ported
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   DRMILLS 21/FEB/2003 - Port to WebUtil
 *
 *********************************************************************************
 * WIN_API_ENVIRONMENT -> This package is concerned with reading from and 
 *       writing to either INI files or the Win95/WinNT Registry.
 *       Or gleaning other useful nuggets of information from the system
 * Contents:
 *    Read_INI_File           -> Gets a Value from an INI file
 *    Write_INI_File          -> Sets a Value in an INI file
 *    Get_Windows_Username    -> Login of current Windows User
 *    Get_Windows_Version     -> Returns the O/S being used
 *    Get_Environment_string  -> Expands Environment Vars e.g %path%
 *    Get_Windows_Directory   -> Gets the Working Windows Dir
 *    Get_Temp_Directory      -> Gets the Temp Dir
 *    Get_Net_Connection      -> Expand Drive Letter into a Network Path
 *    Read_Registry           -> Reads a value from the Registry 
 *    Write_Registry          -> Writes a value to the Registry in REG_SZ fmt
 *    Write_RegistryEx        -> Extended version of Write_Registry which allows 
 *                               You to choose which format to Write in
 *    Create_Registry_Key     -> Creates a new subkey in the registry
 *    Delete_Registry_Key     -> Removes a subkey from the registry
 *    Get_Working_Directory   -> Get the name of the "Start In" / Current Directory
 *                               For this runtime
 *    Get_Computer_Name       -> Get the name of this PC if defined
 * Dependancies:
 *    WIN_API
 *    WIN_API_DIALOG
 *    WIN_API_DEBUG
\*------------------------------------------------------------------------------------*/ 

/*-------------------------------------------------------------------------*\
 * Read_INI_File    -> Read a Value from a named INI file 
 *                     If you need to read the ORACLE.INI file 
 *                     use TOOL_ENV.GETVAR() instead of this
 *                     package.
 *                     If using 32bit Developer/2000 you would 
 *                     probably rather use 
 *                     WIN_API_PROFILES.READ_REGISTRY() instead
 * Arguments: 
 *  FileName        -> Name of INI file e.g. WIN.INI. If the full
 *                     path is not supplied with this argument
 *                     then the DOS PATH will be searched for the
 *                     Specified INI file
 *  Section         -> Section in INI file where the entry is. 
 *                     This will be delimited using square brackets 
 *                     e.g. [printers]
 *  Entry           -> Name of Variable to read e.g. load (from win.ini)
 *  RaiseExceptions -> TRUE or FALSE(Default) If set to true, then if the 
 *                     requested variable is not found the explicit exception
 *                     NO_DATA_FOUND will be raised.
 * Returns:
 *  Value           -> A VARCHAR2 value containing the 
 *                     string (or number as a string) that the 
 *                     entry contains.
 *                     If the Entry is not found, NULL is returned in 
 *                     the return value. (see RaiseExceptions above)
\*-------------------------------------------------------------------------*/
 
FUNCTION Read_INI_File (  FileName        IN  VARCHAR2,
                          Section         IN  VARCHAR2,
                          Entry           IN  VARCHAR2,
                          RaiseExceptions IN  BOOLEAN DEFAULT FALSE) return VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Write_INI_File ->   Write a Value to a named INI file 
 *                     If using 32bit Developer/2000 you would 
 *                     probably rather use 
 *                     WIN_API_PROFILES.WRITE_REGISTRY_XXXX()
 * Arguments: 
 *  FileName        -> Name of INI file e.g. WIN.INI. If the full
 *                     path is not supplied with this argument
 *                     then the DOS PATH will be searched for the
 *                     Specified INI file
 *  Section         -> Section in INI file where the entry is. 
 *                     This will be delimited using square brackets 
 *                     e.g. [printers]. No need to supply the brackets
 *                     for the argument though
 *  Entry           -> Name of Variable to write e.g. load (from win.ini)
 *  Value           -> Value of the variable to write as a string.
 *  RaiseExceptions -> Set to TRUE or FALSE (default).  If this is set 
 *                     to TRUE, then errors such as not finding the 
 *                     INI file will raise NO_DATA_FOUND
 *                     If FALSE then all errors will be handled quietly
 * Returns:
 *  (NONE)
\*-------------------------------------------------------------------------*/

PROCEDURE Write_INI_File (  FileName        IN  VARCHAR2,
                            Section         IN  VARCHAR2,
                            Entry           IN  VARCHAR2,
                            Value           IN  VARCHAR2,
                            RaiseExceptions IN  BOOLEAN DEFAULT FALSE);

/*-------------------------------------------------------------------------*\
 * Get_Windows_Username -> The Username Supplied to log into Windows
 * Arguments: 
 *  RaiseExceptions     -> Set to TRUE or FALSE (default).  If this is set 
 *                         to TRUE, then Not finding the Username (or 
 *                         exceeding the buffer size) will raise
 *                         NO_DATA_FOUND
 * Returns:
 *  UserName ->    Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Windows_Username ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Get_Windows_Version -> The Version of Windows Being used.
 * Arguments: 
 *         NONE
 * Returns:
 *  Version            -> Varchar2 one of the following strings:
 *                        Windows95   -- for Windows 95
 *                        Windows98   -- for Windows 98
 *                        Windows2000 -- for Windows NT 5.0
 *                        WindowsXP   -- for Windows NT 5.1
 *                        Windows2003 -- for Windows NT 5.2
 *                        WindowsNT   -- any other Windows NT (4.0 so far)
\*-------------------------------------------------------------------------*/

FUNCTION Get_Windows_Version RETURN VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Get_Environment_String -> Expands a named environment variable
 * Arguments: 
 *  VariableName          -> Name of the variable e.g. PATH
 *  RaiseExceptions       -> Set to TRUE or FALSE (default).  If this is set 
 *                           to TRUE, then Not finding the Variable (or 
 *                           exceeding the buffer size) will raise
 *                           NO_DATA_FOUND
 * Returns:
 *  Expanded String       ->  Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Environment_string (VariableName      IN  VARCHAR2,
                                 RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;


/*-------------------------------------------------------------------------*\
 * Get_Windows_Directory -> Obtains the path to the windows directory 
 *                          on the machine
 * Arguments: 
 *  RaiseExceptions      -> Set to TRUE or FALSE (default).  If this is set 
 *                          to TRUE, then Not finding the directory (or 
 *                          exceeding the buffer size) will raise
 *                          NO_DATA_FOUND exception. If FALSE, a null value
 *                          will be returned. Whether it is TRUE or
 *                          FALSE, ERROR 941 will be raised if the returned
 *                          length is longer than 2000.
 * Returns:
 *  Path                 -> Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Windows_Directory ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Get_Temp_Directory -> Obtains the path to the directory that  
 *                       Windows is using for temp files
 * Arguments: 
 *  RaiseExceptions   -> Set to TRUE or FALSE (default).  If this is set 
 *                       to TRUE, then Not finding the directory (or 
 *                       exceeding the buffer size) will raise
 *                       NO_DATA_FOUND
 * Returns:
 *  Path              -> Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Temp_Directory ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Get_Net_Connection  -> Expands an attached drive letter to it's 
 *                        full network address
 * Arguments: 
 *  DriveLetter        -> Letter of the Drive to expand e.g. 'F:'
 *  RaiseExceptions    -> Set to TRUE or FALSE (default).  If this is set 
 *                        to TRUE, then Not finding the Drive (or 
 *                        exceeding the buffer size) will raise
 *                        NO_DATA_FOUND
 * Returns:
 *  Expanded Connection String ->  Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Net_Connection  (DriveLetter       IN  VARCHAR2,
                              RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;

/*-------------------------------------------------------------------------*\
 * Read_Registry    -> Read the value of a particular entry in the 
 *                     Win95/NT Registry
 *                     It wil read Registry Values Stored in the 
 *                     Following Formats
 *                        REG_EXPAND_SZ, REG_SZ, REG_DWORD
 *
 * Arguments: 
 *  RegPath         -> The Full path in the registry to the required
 *                     value e.g. HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE
 *  RegEntry        -> Name of the entry to read e.g. ORACLE_PATH
 *  RaiseExceptions -> Set to TRUE or FALSE (default).  If this is set 
 *                     to TRUE, then failing to find the entry raises
 *                     NO_DATA_FOUND. obtaining an entry of a datatype
 *                     that is not a string or a number raises
 *                     VALUE_ERROR.
 * Returns:
 *  Value           -> Both Number and String entries returned
 *                     as Varchar2.
 * NOTE:
 *  If you read a registry entry of type REG_EXPAND_SZ, this call will now 
 *  automatically attempt to expand any variables included in the string
 *  such as %path%.  If the total length of the expanded string exceeds 2000
 *  bytes then the unexpanded tring will be returned.
 *  To totally supress the expansion of such strings set the
 *  WIN_API.COMPAT_EXPAND_REG_VALUES flag to FALSE at runtime.
\*-------------------------------------------------------------------------*/

FUNCTION Read_Registry (RegPath         IN  VARCHAR2,
                        RegEntry        IN  VARCHAR2, 
                        RaiseExceptions IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;
/*-------------------------------------------------------------------------*\
 * Write_Registry   -> Set the value of a particular entry in the 
 *                     Win95/NT Registry in REG_EXPAND_SZ format
 *                     NOTE: The Path to the entry must already Exist
 *
 * Arguments: 
 *  RegPath         -> The Full path in the registry to the required
 *                     value e.g. HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE
 *  RegEntry        -> Name of the entry to set e.g. ORACLE_PATH
 *  RegValue        -> Value to set
 *  RaiseExceptions -> Set to TRUE or FALSE (default).  If this is set 
 *                     to TRUE, then failing to set  the entry raises
 *                     NO_DATA_FOUND. 
 * Returns:
 *  (NONE)
\*-------------------------------------------------------------------------*/

PROCEDURE Write_Registry(  RegPath         IN   VARCHAR2,
                           RegEntry        IN  VARCHAR2, 
                           RegValue        IN  VARCHAR2, 
                           RaiseExceptions IN  BOOLEAN DEFAULT FALSE);
        
/*-------------------------------------------------------------------------*\
 * Write_RegistryEx -> Set the value of a particular entry in the 
 *                     Win95/NT Registry Specifying the Format 
 *                     NOTE: The Path to the entry must already Exist
 *
 * Arguments: 
 *  RegPath         -> The Full path in the registry to the required
 *                     value e.g. HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE
 *  RegEntry        -> Name of the entry to set e.g. ORACLE_PATH
 *  RegValue        -> Value to set
 *  RegFormat       -> Format for Setting Supported Values REG_SZ, REG_EXPAND_SZ,
 *                     REG_DWORD
 *  RaiseExceptions -> Set to TRUE or FALSE (default).  If this is set 
 *                     to TRUE, then failing to set  the entry raises
 *                     NO_DATA_FOUND. 
 * Returns:
 *  (NONE)
\*-------------------------------------------------------------------------*/

PROCEDURE Write_RegistryEx( RegPath         IN  VARCHAR2,
                            RegEntry        IN  VARCHAR2, 
                            RegValue        IN  VARCHAR2, 
                            RegFormat       IN  PLS_INTEGER,
                            RaiseExceptions IN  BOOLEAN DEFAULT FALSE);

/*-------------------------------------------------------------------------*\
 * Create_Registry_Key  -> Create a new subkey on the Registry
 *                         NOTE: If this key already exists this call will 
 *                         be harmless and Will Succeed.
 *
 * Arguments: 
 *  RegPath             -> The Full path in the registry to the required
 *                         value e.g. HKEY_LOCAL_MACHINE\SOFTWARE\D2KWUTIL
 *  RaiseExceptions     -> Set to TRUE or FALSE (default).  If this is set 
 *                         to TRUE, then failing to create key raises
 *                         NO_DATA_FOUND. 
 * Returns:
 *  (NONE)
\*-------------------------------------------------------------------------*/

PROCEDURE Create_Registry_Key(  RegPath          IN  VARCHAR2,
                                RaiseExceptions  IN  BOOLEAN DEFAULT FALSE);        
                                
/*-------------------------------------------------------------------------*\
 * Delete_Registry_Key  ->  Removes a subkey and all it's children from 
 *                          the Registry
 *        NOTE: **** THIS CALL IS VERY DANGEROUS - YOU COULD SERIOUSLY ****
 *              **** DAMAGE YOUR SYSTEM USING THIS FUNCTION            ****
 *              **** EXERCISE CAUTION                                  ****
 *
 * Arguments: 
 *  RegPath             -> The Full path in the registry to be deleted
 *                         value e.g. HKEY_LOCAL_MACHINE\SOFTWARE\D2KWUTIL
 *  RaiseExceptions     -> Set to TRUE or FALSE (default).  If this is set 
 *                         to TRUE, then failing to delete the entry raises
 *                         NO_DATA_FOUND. 
 * Returns:
 *  (NONE)
\*-------------------------------------------------------------------------*/

PROCEDURE Delete_Registry_Key(  RegPath          IN  VARCHAR2,
                                RaiseExceptions  IN  BOOLEAN DEFAULT FALSE);        

                                
/*-------------------------------------------------------------------------*\
 * Get_Working_Directory -> Obtains the path of the current directory
 * Arguments: 
 *  RaiseExceptions      -> Set to TRUE or FALSE (default).  If this is set 
 *                          to TRUE, then Not finding the directory (or 
 *                          exceeding the buffer size) will raise
 *                          NO_DATA_FOUND
 * Returns:
 *  Path                 -> Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Working_Directory ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;
        
/*-------------------------------------------------------------------------*\
 * Get_Computer_name -> Obtains the name of the running PC
 * Arguments: 
 *  RaiseExceptions  ->  Set to TRUE or FALSE (default).  If this is set 
 *                       to TRUE, then Not finding the name (or 
 *                       exceeding the buffer size) will raise
 *                       NO_DATA_FOUND
 * Returns:
 *  Computer name ->     Varchar2 
\*-------------------------------------------------------------------------*/

FUNCTION Get_Computer_Name ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2;                          

END CLIENT_WIN_API_ENVIRONMENT;


PACKAGE BODY CLIENT_WIN_API_ENVIRONMENT is

  -- Constants for maintaining the Function Handle Array
  -- These should be unique through the Whole Library
  -- Environment has indexes in the range 300 - 399
  iReadINIFile          CONSTANT  PLS_INTEGER  := 300;
  iWriteINIFile         CONSTANT  PLS_INTEGER  := 301;
  iGetRegKey            CONSTANT  PLS_INTEGER  := 302;
  iSetRegKey            CONSTANT  PLS_INTEGER  := 303;
  iGetWinuser           CONSTANT  PLS_INTEGER  := 304;
  iGetDOSEnv            CONSTANT  PLS_INTEGER  := 305;
  iWinDir               CONSTANT  PLS_INTEGER  := 306;
  iTmpDir               CONSTANT  PLS_INTEGER  := 307;
  iWNetGetConnection    CONSTANT  PLS_INTEGER  := 308;
  iGetWorkingDirectory  CONSTANT  PLS_INTEGER  := 309;
  iSetWorkingDirectory  CONSTANT  PLS_INTEGER  := 310;
  iGetComputerName      CONSTANT  PLS_INTEGER  := 311;
  iGetWindowsVersion    CONSTANT  PLS_INTEGER  := 312;
  iMaintRegKey          CONSTANT  PLS_INTEGER  := 313;

  -- Private Program unit headers  
  PROCEDURE Wrap_Write_Registry( CalledBy        IN  VARCHAR2,
                                 RegPath         IN  VARCHAR2,
                                 RegEntry        IN  VARCHAR2, 
                                 RegValue        IN  VARCHAR2,                               
                                 RegFormat       IN  PLS_INTEGER,                                
                                 RaiseExceptions IN  BOOLEAN DEFAULT FALSE);

  PROCEDURE Wrap_Maint_Registry( CalledBy        IN  VARCHAR2,
                                 RegPath         IN  VARCHAR2,
                                 Opt             IN  PLS_INTEGER,                                
                                 RaiseExceptions IN  BOOLEAN DEFAULT FALSE);



  -- Public Bodies 
  FUNCTION Read_INI_File (  FileName        IN  VARCHAR2,
                            Section         IN  VARCHAR2,
                            Entry           IN  VARCHAR2,
                            RaiseExceptions IN  BOOLEAN DEFAULT FALSE) return VARCHAR2 is
    DEFAULT_PLACEHOLDER  constant varchar2(16):= 'D2KWUTIL_EMPTY';
    vcBuff1    VARCHAR2(512);
    vcBuff2    VARCHAR2(512);
    vcBuff3    VARCHAR2(512);
    vcBuff4    VARCHAR2(512);
    vcBuff5    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle; 
    param3    WEBUTIL_C_API.ParameterHandle;   
    param4    WEBUTIL_C_API.ParameterHandle;
    param5    WEBUTIL_C_API.ParameterHandle;
    param6    WEBUTIL_C_API.ParameterHandle;    
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iReadINIFile,'d2kwutil_ReadINIFile','INT','*CHAR,*CHAR,*CHAR,*CHAR,*CHAR,INT');
      vcBuff1    := FileName;
      vcBuff2    := Section;
      vcBuff3    := Entry;
      vcBuff4    := '';
      vcBuff5    := DEFAULT_PLACEHOLDER;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff2,
                                            512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff3,
                                            512);
      param4 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff4,
                                            512);
      param5 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff5,
                                            18);                                                                                                                                                        
      param6 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            512);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iReadINIFile),args);
      vcBuff4 := WEBUTIL_C_API.Get_Parameter_String(args,param4);
      WEBUTIL_C_API.Destroy_Parameter_List(args);                  
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 or vcBuff4 = DEFAULT_PLACEHOLDER then 
      CLIENT_Win_API.Add_error('Read_INI_File','Unable to obtain '||Entry||' from the ['||Section||'] section of '||FileName);
      if not RaiseExceptions then
        return NULL;
      else 
        raise NO_DATA_FOUND;
      end if;
    else
      return vcBuff4;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Read_INI_File',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Read_INI_File',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Read_INI_File;

  PROCEDURE Write_INI_File (  FileName        IN  VARCHAR2,
                              Section         IN  VARCHAR2,
                              Entry           IN  VARCHAR2,
                              Value           IN  VARCHAR2,
                              RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
    vcBuff1    VARCHAR2(512);
    vcBuff2    VARCHAR2(512);
    vcBuff3    VARCHAR2(512);
    vcBuff4    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle; 
    param3    WEBUTIL_C_API.ParameterHandle;   
    param4    WEBUTIL_C_API.ParameterHandle;
  begin

    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iWriteINIFile,'d2kwutil_WriteINIFile','INT','*CHAR,*CHAR,*CHAR,*CHAR');
      vcBuff1    := FileName;
      vcBuff2    := Section;
      vcBuff3    := Entry;
      vcBuff4    := Value;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff2,
                                            512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff3,
                                            512);
      param4 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff4,
                                            512);    
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iWriteINIFile),args);
      WEBUTIL_C_API.Destroy_Parameter_List(args);                                      
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0  then
      CLIENT_Win_API.Add_error('Write_INI_File','Unable to set the value of '||Entry||' in the ['||Section||'] section of '||FileName); 
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      end if;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Write_INI_File',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Write_INI_File',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Write_INI_File;

  FUNCTION Get_Windows_Username (RaiseExceptions IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;      
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iGetWinuser,'d2kwutil_GetWinuser','INT','*CHAR,INT');
      vcBuff1    := '';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            512);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iGetWinuser),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      WEBUTIL_C_API.Destroy_Parameter_List(args);                                        
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 then 
      CLIENT_Win_API.Add_error('Get_Windows_Username', 'No Value Returned');
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return vcBuff1;
      end if;
    else
      return vcBuff1;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Windows_Username',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Windows_Username',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Windows_Username;


  FUNCTION Get_Windows_Directory (RaiseExceptions IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;      
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iWinDir,'d2kwutil_WinDir','INT','*CHAR,INT');

      vcBuff1    := '';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            512);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iWinDir),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      WEBUTIL_C_API.Destroy_Parameter_List(args);                                            
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 then 
      CLIENT_Win_API.Add_error('Get_Windows_Directory','No Value Returned');
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return NULL;
      end if;
    else
      return CLIENT_WIN_API.StripDirSep(vcBuff1);
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Windows_Directory',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Windows_Directory',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Windows_Directory;


  FUNCTION Get_Temp_Directory (RaiseExceptions IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iTmpDir,'d2kwutil_TmpDir','INT','*CHAR,INT');
      vcBuff1    := '';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            512);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iTmpDir),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      WEBUTIL_C_API.Destroy_Parameter_List(args);                                                
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 then 
      CLIENT_Win_API.Add_error('Get_Temp_Directory','No Value Returned');
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return NULL;
      end if;
    else
      return CLIENT_WIN_API.StripDirSep(vcBuff1);
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Temp_Directory',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Temp_Directory',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Temp_Directory;


  FUNCTION Get_Environment_string (  VariableName      IN  VARCHAR2,
                                     RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iMaxOutBuff NUMBER := 2000;
    vcBuff2    VARCHAR2(2000); -- keep the length same as iMaxOutBuff
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
    param3    WEBUTIL_C_API.ParameterHandle;     
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then
      Client_win_api.Register_function_call(iGetDOSEnv,'d2kwutil_GetDOSEnv','LONG','*CHAR,*CHAR,LONG');
      vcBuff1    := '%'||ltrim(rtrim(VariableName))||'%';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_OUT,
                                            vcBuff2,
                                            iMaxOutBuff);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iMaxOutBuff);

      iRC := WebUtil_C_API.Invoke_int(Client_win_api.FunctionHandle(iGetDOSEnv),args);
      if iRC > iMaxOutBuff then
        -- expanded variable value is too long.
        Webutil_Core.Error(Webutil_Core.WUL_PACKAGE,941,
                           'CLIENT_WIN_API_ENVIRONMENT.GET_ENVIRONMENT_STRING', iMaxOutBuff, iRC);
      end if;
      vcBuff2 := WEBUTIL_C_API.Get_Parameter_String(args,param2);
      WEBUTIL_C_API.Destroy_Parameter_List(args);            
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0
        or iRC > iMaxOutBuff -- buffer is insufficient
        or vcBuff1 = vcBuff2 -- if not defined %VAR% will be returned as %VAR%
    then 
      CLIENT_Win_API.Add_error('Get_Environment_String','Unable to get the value of the variable '||VariableName);
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return NULL;
      end if;
    else
      return vcBuff2;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Environment_String',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Environment_String',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Environment_String;

  FUNCTION Get_Net_Connection ( DriveLetter     IN  VARCHAR2,
                                RaiseExceptions IN  BOOLEAN DEFAULT FALSE) return VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    vcBuff2    VARCHAR2(512);
    iBuff1    PLS_INTEGER;
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
    param3    WEBUTIL_C_API.ParameterHandle;    
  begin
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iWNetGetConnection,'d2kwutil_WNetGetConnection','INT','*CHAR,*CHAR,*LONG');
      vcBuff1   := substr(DriveLetter,1,instr(DriveLetter,':'));
      vcBuff2   := '';
      iBuff1    := 512;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            2);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff2,
                                            512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff1);
                                    
      iRC := WebUtil_C_API.Invoke_int(Client_win_api.FunctionHandle(iWNetGetConnection),args);
      vcBuff2 := WEBUTIL_C_API.Get_Parameter_String(args,param2);
      WEBUTIL_C_API.Destroy_Parameter_List(args);      
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC <> 0 then 
      CLIENT_Win_API.Add_error('Get_Net_Connection' ,'Unable to expand "'||vcBuff1||'" into a network path (Return Code='||to_char(iRC)||')');
      if not RaiseExceptions then
        return NULL;
      else 
        raise NO_DATA_FOUND;
      end if;
    else
      return vcBuff2;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Net_Connection',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Net_Connection',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Net_Connection;


  FUNCTION Read_Registry (RegPath         IN  VARCHAR2,
                          RegEntry        IN  VARCHAR2, 
                          RaiseExceptions IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    vcBuff2    VARCHAR2(512);
    vcBuff3    VARCHAR2(2000);                       
    vcRoot     VARCHAR2(20);
    iBuff1     PLS_INTEGER;
    iBuff2     PLS_INTEGER;
    iBuff3         PLS_INTEGER;
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
    param3    WEBUTIL_C_API.ParameterHandle;       
    param4    WEBUTIL_C_API.ParameterHandle;
    param5    WEBUTIL_C_API.ParameterHandle;   
    param6    WEBUTIL_C_API.ParameterHandle;       
  begin
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iGetRegKey,'d2kwutil_GetRegKey','INT','INT,*CHAR,*CHAR,*CHAR,INT,INT');  
      -- Which Root?
      vcRoot  := upper(substr(RegPath,1,instr(RegPath,'\')-1));
      if      vcRoot =  'HKEY_LOCAL_MACHINE' then 
        iBuff1 := 0;
      elsif   vcRoot =  'HKEY_CLASSES_ROOT' then 
        iBuff1 := 1;
      elsif   vcRoot =  'HKEY_CURRENT_USER' then 
        iBuff1 := 2;
      elsif   vcRoot =  'HKEY_USERS' then
        iBuff1 := 3;
      elsif   vcRoot =  'HKEY_CURRENT_CONFIG' then
        iBuff1 := 4;      
      else
        CLIENT_Win_API.Add_error('Read_Registry','Invalid Registry Key '||RegPath);
        if  RaiseExceptions then
          raise NO_DATA_FOUND;
        end if;  
      end if;

      iBuff2     := 2000; /* Length of buffer */
      vcBuff1    := substr(RegPath,instr(RegPath,'\')+1);
      vcBuff2    := RegEntry;
      vcBuff3    := '';
      if not CLIENT_WIN_API.COMPAT_EXPAND_REG_VALUES then 
        iBuff3 := 1;
      else
        iBuff3 := 0;
      end if;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff1);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff2,
                                            512);   
      param4 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff3,
                                            2000);                                    
      param5 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff2); 
      param6 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff3);                                     
      iRC := WebUtil_C_API.Invoke_int(Client_win_api.FunctionHandle(iGetRegKey),args);
      vcBuff3 := WEBUTIL_C_API.Get_Parameter_String(args,param4);
      WEBUTIL_C_API.Destroy_Parameter_List(args);      
    
      --iRC        := d2kwutil_GetRegKey(Client_win_api.FunctionHandle(iGetRegKey),iBuff1,vcBuff1,vcBuff2,vcBuff3,iBuff2,iBuff3);      
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = -1  then 
      CLIENT_Win_API.Add_error('Read_Registry','Cannot read  entry '||RegPath||'->'||RegEntry);
      if not RaiseExceptions then
        return NULL;
      else 
        raise NO_DATA_FOUND;
      end if;
    elsif iRC = -2 then
      CLIENT_Win_API.Add_error('Read_Registry', RegPath||'->'||RegEntry||' is an unsupported datatype');
      if not RaiseExceptions then
        return NULL;
      else 
        raise NO_DATA_FOUND;
      end if;
    elsif iRC = -3 then
      CLIENT_Win_API.Add_error('Read_Registry',RegPath||'->'||RegEntry||' is longer than '||to_char(iBuff2)||' Bytes');
      if not RaiseExceptions then
        return NULL;
      else 
        raise VALUE_ERROR;
      end if;
    elsif iRC = -4 then
      CLIENT_Win_API.Add_error('Read_Registry', RegPath||'->'||RegEntry||' Failed to expand environment string');
      if not RaiseExceptions then
        return NULL;
      else 
        raise NO_DATA_FOUND;
      end if;    
    end if;
    return vcBuff3;
  exception
    when NO_DATA_FOUND then 
      raise;
    when VALUE_ERROR then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Read_Registry',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Read_Registry',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Read_Registry;

  PROCEDURE Wrap_Write_Registry(  CalledBy        IN  VARCHAR2,
                                  RegPath         IN  VARCHAR2,
                                  RegEntry        IN  VARCHAR2, 
                                  RegValue        IN  VARCHAR2, 
                                  RegFormat       IN  PLS_INTEGER,
                                  RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
    vcBuff1    VARCHAR2(512);
    vcBuff2    VARCHAR2(512);
    vcBuff3    VARCHAR2(512);
    vcRoot     VARCHAR2(20);
    iBuff1     PLS_INTEGER;
    iBuff2     PLS_INTEGER;
    iBuff3     PLS_INTEGER := 0;
    iRC        PLS_INTEGER;
    iNullInd     PLS_INTEGER := 0;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
    param3    WEBUTIL_C_API.ParameterHandle;       
    param4    WEBUTIL_C_API.ParameterHandle;
    param5    WEBUTIL_C_API.ParameterHandle;   
    param6    WEBUTIL_C_API.ParameterHandle;
    param7    WEBUTIL_C_API.ParameterHandle;     
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iSetRegKey,'d2kwutil_SetRegKey','INT','INT,*CHAR,*CHAR,INT,*CHAR,LONG,INT');  
      -- Which Root?
      vcRoot  := upper(substr(RegPath,1,instr(RegPath,'\')-1));
      if      vcRoot =  'HKEY_LOCAL_MACHINE' then 
        iBuff1 := 0;
      elsif   vcRoot =  'HKEY_CLASSES_ROOT' then 
        iBuff1 := 1;
      elsif   vcRoot =  'HKEY_CURRENT_USER' then 
        iBuff1 := 2;
      elsif   vcRoot =  'HKEY_USERS' then
        iBuff1 := 3;
      elsif   vcRoot =  'HKEY_CURRENT_CONFIG' then
        iBuff1 := 4;            
      else
        CLIENT_Win_API.Add_error(CalledBy,'Invalid Registry Key '||RegPath);
        if  RaiseExceptions then
          raise NO_DATA_FOUND;
        end if;  
      end if;

      iBuff2    := RegFormat;
      if RegValue is NULL then 
        iBuff3 := 0;
        vcBuff3 := ' ';
        iNullInd := 1;
      else
        if RegFormat = CLIENT_WIN_API.REG_DWORD then 
          iBuff3 := trunc(abs(to_number(RegValue)));
          vcBuff3 := ' ';
          if iBuff3 > 4294967295 then 
            Raise VALUE_ERROR; /* larger than a DWORD */
          end if;
        else
          vcBuff3    := RegValue;
        end if;
      end if;

      vcBuff1    := substr(RegPath,instr(RegPath,'\')+1);
      vcBuff2    := RegEntry;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff1);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff1,
                                            512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff2,
                                            512);   
      param4 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff2);                                    
      param5 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_IN,
                                            vcBuff3,
                                            512);   

      param6 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iBuff3); 
      param7 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            iNullInd);                                     
      iRC := WebUtil_C_API.Invoke_int(Client_win_api.FunctionHandle(iSetRegKey),args);
      WEBUTIL_C_API.Destroy_Parameter_List(args);      
      --iRC   := d2kwutil_SetRegKey(Client_win_api.FunctionHandle(iSetRegKey),iBuff1,vcBuff1,vcBuff2,iBuff2,vcBuff3,iBuff3,iNullInd);
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC <> 0  then 
      CLIENT_Win_API.Add_error(CalledBy,'Cannot set Registry Entry '||RegPath||'->'||RegEntry||' to '||RegValue);
      if  RaiseExceptions then
        raise NO_DATA_FOUND;
      end if;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when VALUE_ERROR then 
      CLIENT_Win_API.Add_error(CalledBy,'The value being set exceeded the maximum for a DWORD (4,294,967,295)');
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error(CalledBy,CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error(CalledBy,CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Wrap_Write_Registry;

  PROCEDURE Write_Registry( RegPath         IN   VARCHAR2,
                            RegEntry        IN   VARCHAR2, 
                            RegValue        IN   VARCHAR2, 
                            RaiseExceptions IN   BOOLEAN DEFAULT FALSE) is
  begin
    Wrap_Write_Registry('Write_Registry',RegPath, RegEntry,RegValue,CLIENT_WIN_API.REG_SZ, RaiseExceptions);
  end Write_Registry;

  PROCEDURE Write_RegistryEx(  RegPath         IN  VARCHAR2,
                               RegEntry        IN  VARCHAR2, 
                               RegValue        IN  VARCHAR2, 
                               RegFormat       IN  PLS_INTEGER,
                               RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
  begin
    Wrap_Write_Registry('Write_RegistryEx',RegPath, RegEntry,RegValue,RegFormat, RaiseExceptions);
  end Write_RegistryEx;

  PROCEDURE Wrap_Maint_Registry(  CalledBy        IN   VARCHAR2,
                                  RegPath         IN   VARCHAR2,
                                  Opt             IN  PLS_INTEGER,
                                  RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
    vcOp       VARCHAR2(10);
    vcBuff1    VARCHAR2(512);
    vcRoot     VARCHAR2(20);
    iBuff1     PLS_INTEGER;
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
    param3    WEBUTIL_C_API.ParameterHandle;   
  begin 
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iMaintRegKey,'d2kwutil_MaintRegKey','INT','INT,*CHAR,INT');  
      -- Which Root?
      vcRoot  := upper(substr(RegPath,1,instr(RegPath,'\')-1));
      if      vcRoot =  'HKEY_LOCAL_MACHINE' then 
        iBuff1 := 0;
      elsif   vcRoot =  'HKEY_CLASSES_ROOT' then 
        iBuff1 := 1;
      elsif   vcRoot =  'HKEY_CURRENT_USER' then 
        iBuff1 := 2;
      elsif   vcRoot =  'HKEY_USERS' then
        iBuff1 := 3;
      else
        CLIENT_Win_API.Add_error(CalledBy,'Invalid Registry Key '||RegPath);
        if  RaiseExceptions then
          raise NO_DATA_FOUND;
        end if;  
      end if;

      vcBuff1    := substr(RegPath,instr(RegPath,'\')+1);

      if opt = 0 then
        vcOp := 'Create';
      else
        vcOp := 'Delete';
        if (instr(vcBuff1,'\') = 0) and iBuff1 <> 1 then
              CLIENT_Win_API.Add_error(CalledBy,'You Probably don''t want to delete something this high in the Registry hierachy: '||RegPath);
              raise NO_DATA_FOUND;
        end if;
      end if;
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                      WEBUTIL_C_API.C_INT,
                                      WEBUTIL_C_API.param_IN,
                                      iBuff1);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                      WEBUTIL_C_API.C_CHAR_PTR,
                                      WEBUTIL_C_API.param_IN,
                                      vcBuff1,
                                      512);
      param3 := WEBUTIL_C_API.Add_Parameter(args,
                                      WEBUTIL_C_API.C_INT,
                                      WEBUTIL_C_API.param_IN,
                                      opt);   
      iRC := WebUtil_C_API.Invoke_int(Client_win_api.FunctionHandle(iMaintRegKey),args);
      WEBUTIL_C_API.Destroy_Parameter_List(args);  
      --iRC   := d2kwutil_MaintRegKey(Client_win_api.FunctionHandle(iMaintRegKey),iBuff1,vcBuff1,opt);
    else 
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC <> 0  then 
      CLIENT_Win_API.Add_error(CalledBy,'Cannot '||vcOp||' Registry Key '||RegPath|| ' (Error code = '||to_char(iRC)||')');
      if  RaiseExceptions then
        raise NO_DATA_FOUND;
      end if;
    end if;
  exception
    when NO_DATA_FOUND then 
      if RaiseExceptions then 
        raise;
      end if;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error(CalledBy,CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error(CalledBy,CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Wrap_Maint_Registry;

  PROCEDURE Create_Registry_Key(  RegPath         IN   VARCHAR2,
                                  RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
  begin
    Wrap_Maint_Registry('Create_Registry_Key',RegPath,0,RaiseExceptions);
  end;


  PROCEDURE Delete_Registry_Key(  RegPath         IN   VARCHAR2,
                                  RaiseExceptions IN  BOOLEAN DEFAULT FALSE) is
  begin
    Wrap_Maint_Registry('Delete_Registry_Key',RegPath,1,RaiseExceptions);
  end;


  FUNCTION Get_Working_Directory ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iRC        PLS_INTEGER;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;    
  begin
    Client_Win_API.Clean_Error_Stack;
    iRC  := 0;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iGetWorkingDirectory,'d2kwutil_GetWorkingDirectory','INT','*CHAR,INT');

      vcBuff1    := '';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT,
                                            WEBUTIL_C_API.param_IN,
                                            512);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iGetWorkingDirectory),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      WEBUTIL_C_API.Destroy_Parameter_List(args);          
      --iRC   := d2kwutil_GetWorkingDirectory(Client_win_api.FunctionHandle(iGetWorkingDirectory),vcBuff1,512);          
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 then 
      CLIENT_Win_API.Add_error('Get_Working_Directory','No Value Returned');
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return NULL;
      end if;
    else
      return CLIENT_WIN_API.StripDirSep(vcBuff1);
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Working_Directory',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Working_Directory',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Working_Directory;

  FUNCTION Get_Computer_Name ( RaiseExceptions   IN  BOOLEAN DEFAULT FALSE)  RETURN VARCHAR2 is
    vcBuff1    VARCHAR2(512);
    iBuff1     PLS_INTEGER := 512;
    iRC        PLS_INTEGER := 0;
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
  begin 
    Client_Win_API.Clean_Error_Stack;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iGetComputerName,'d2kwutil_GetComputerName','INT','*CHAR,*LONG');

      vcBuff1    := '';
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            512);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_INT_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            iBuff1);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iGetComputerName),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      WEBUTIL_C_API.Destroy_Parameter_List(args);     
      --iRC   := d2kwutil_GetComputerName(Client_win_api.FunctionHandle(iGetComputerName),vcBuff1,iBuff1);
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if;  
    if iRC = 0 then 
      CLIENT_Win_API.Add_error('Get_Computer_Name','No Value Returned');
      if RaiseExceptions then
        raise NO_DATA_FOUND;
      else
        return NULL;
      end if;
    else
      return vcBuff1;
    end if;
  exception
    when NO_DATA_FOUND then 
      raise;
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('GetComputer_Name',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Computer_Name',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Computer_Name;

  FUNCTION Get_Windows_Version RETURN VARCHAR2 is
    iRC        PLS_INTEGER := 0;
    rcBuff     VARCHAR2(30);
    vcBuff1    VARCHAR2(30) := ''; 
    vcBuff2    VARCHAR2(16) := '';
    args      WEBUTIL_C_API.ParameterList;
    param1    WEBUTIL_C_API.ParameterHandle;
    param2    WEBUTIL_C_API.ParameterHandle;   
  begin 
    Client_Win_API.Clean_Error_Stack;
    if Client_Win_API.API_ENABLED then 
      Client_win_api.Register_function_call(iGetWindowsVersion,'d2kwutil_GetWindowsVersion','INT','*CHAR,*CHAR');
      args := WEBUTIL_C_API.Create_Parameter_List;
      param1 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff1,
                                            30);
      param2 := WEBUTIL_C_API.Add_Parameter(args,
                                            WEBUTIL_C_API.C_CHAR_PTR,
                                            WEBUTIL_C_API.param_INOUT,
                                            vcBuff2,
                                            16);
      iRC := WebUtil_C_API.Invoke_Int(Client_win_api.FunctionHandle(iGetWindowsVersion),args);
      vcBuff1 := WEBUTIL_C_API.Get_Parameter_String(args,param1);
      vcBuff2 := WEBUTIL_C_API.Get_Parameter_String(args,param2);    
      WEBUTIL_C_API.Destroy_Parameter_List(args);     
    
      --iRC   := d2kwutil_GetWindowsVersion(Client_win_api.FunctionHandle(iGetWindowsVersion),vcBuff1,vcBuff2);
    else
      raise CLIENT_WIN_API.NOT_AVAILABLE;
    end if; 

    if iRC = 1 and vcBuff2 = '1998' then
      rcBuff := 'Windows98';
    elsif iRC = 1 then 
      rcBuff := 'Windows95';
    elsif iRC = 2 then
      if substr(vcBuff1,1,3) = '5.0' then
        rcBuff := 'Windows2000';
      elsif iRC = 2  and substr(vcBuff1,1,3) = '5.1' then
        rcBuff := 'WindowsXP';
      elsif iRC = 2  and substr(vcBuff1,1,3) = '5.2' then
        rcBuff := 'Windows2003';
      else
        rcBuff := 'WindowsNT';
      end if;
    else
      rcBuff := 'Unknown Type: '||to_char(iRC)||' BuildInfo: '||vcBuff1;
    end if;

    return rcBuff;
  exception
    when CLIENT_WIN_API.NOT_AVAILABLE then
      CLIENT_Win_API.Add_error('Get_Windows_Version',CLIENT_Win_API.NoAPI);
      raise;
    when others then 
      CLIENT_Win_API.Add_error('Get_Windows_Version',CLIENT_Win_API.UError||CLIENT_WIN_API.Add_External_errors); 
      raise;
  end Get_Windows_Version;

END CLIENT_WIN_API_ENVIRONMENT;


PACKAGE CLIENT_WIN_API_PRELOAD IS
  PROCEDURE SET_LOAD_LOC (Location IN VARCHAR2);
  FUNCTION GET_LOAD_LOC RETURN VARCHAR2;
END CLIENT_WIN_API_PRELOAD;


PACKAGE BODY CLIENT_WIN_API_PRELOAD IS


  PROCEDURE SET_LOAD_LOC (Location IN VARCHAR2) is
  BEGIN 
    -- No-Op on the Web
    null;
  END SET_LOAD_LOC;
  
  FUNCTION GET_LOAD_LOC RETURN VARCHAR2 IS
  BEGIN 
    -- location is nowClient Side JVM /bin directory
    RETURN null;
  END GET_LOAD_LOC;

END CLIENT_WIN_API_PRELOAD;


PACKAGE DelimStr IS
/*********************************************************************************\
 * DELIMSTR
 *   A series of handy functions for Parsing and handling delimited strings
 *   e.g. comma separated values 
 *   in the format <field1><delimiter><field2><delimiter> etc.
 *   The delimiter will default to a comma if not specified
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   DRMILLS 23/DEC/2002 - Creation
 *
\*********************************************************************************/ 

  /**
   * Functions are:
   *        COUNTER    -> Returns the number of "fields" in the string
   *        PUT        -> Adds (or replaces) a Number, string or date 
   *                      to the string at the specified position
   *                      (dates are stored with full precision)
   *        GETSTRING  -> Returns the String value of the nth field
   *        GETNUMBER  -> Returns the number value of the nth field
   *        GETDATE    -> Returns the Date value of the nth field
   *        LOCATE     -> Returns the Field number of a particular 
   *                      String
   * All the functions are overloaded where required
  \*-----------------------------------------------------------------*/
 
  function  Counter(   Source_string     in varchar2,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return number;
  
  Procedure Put    (   Source_string     in out varchar2,
                       String_to_add     in varchar2,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  Procedure Put    (   Source_string     in out varchar2,
                       number_to_add     in number,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  Procedure Put    (   Source_string     in out varchar2,
                       Date_to_add       in date,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  Procedure PutString( Source_string     in out varchar2,
                       String_to_add     in varchar2,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  Procedure PutNumber( Source_string     in out varchar2,
                       number_to_add     in number,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  Procedure PutDate(   Source_string     in out varchar2,
                       Date_to_add       in date,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',');
  
  function  GetString( Source_string     in varchar2,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return varchar2;
  
  function  GetNumber( Source_string     in varchar2,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return number;
  
  function  GetDate(   Source_string     in varchar2,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return date;
  
  function  Locate(    Source_string     in varchar2,
                       Search_String     in varchar2,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return number;
  
  function  Locate(    Source_string     in varchar2,
                       Search_date       in date,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return number;
  
  function  Locate(    Source_string     in varchar2,
                       Search_number     in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') return number;
END DelimStr;


PACKAGE BODY DelimStr IS
  function  Counter(Source_string     in varchar2,
                    UnTerminated      in Boolean default FALSE,
                    Delimiter         in varchar2 default ',') return number is
    iModifier    pls_integer := 0;
    iOldSize    pls_integer := length(Source_string);
    db3    pls_integer;
    db2    NUMBER;   -- DCN change to number
    db1    varchar2(32000);
  begin
    if Unterminated then iModifier := 1; end if;
    db1 := replace(Source_string,Delimiter);
    db2 := length(db1);
    db3 := (iOldSize - db2) + iModifier;
    return db3; 
  end Counter;

  Procedure PutString   (Source_string     in out varchar2,
                         String_to_add     in varchar2,
                         Field_position    in number,
                         UnTerminated      in Boolean  default FALSE,
                         Delimiter         in varchar2 default ',') is
    iStrLen        NUMBER := length(Source_String);
    iStrFragLen    NUMBER := Length(String_to_add);
    iPtrStart    NUMBER := 0;
    iPtrEnd        NUMBER := 0;
    vcSepBuffer    varchar2(2000);
    iCounter    NUMBER;
  begin
    -- 1. is the string Zero Length?
    if iStrLen = 0 then
      if Field_Position > 1 then 
        for iCounter in 2..Field_Position loop
          vcSepBuffer := vcSepBuffer||Delimiter;
        end loop;
      end if;
      Source_string := vcSepBuffer||String_to_add;
      if Not UnTerminated then 
        Source_string := Source_String||Delimiter;
        iStrLen          := length(Source_string);
      end if;
    else            
    -- 2. Cope with unterminated strings 
      if UnTerminated then 
          Source_string := Source_string||Delimiter;
      end if;
    -- 3. Locate the nth-1 separator
      if Field_Position > 1 then 
        LOOP
          iPtrStart := (instr(Source_string||vcSepBuffer,Delimiter,1,Field_Position-1)-1) + length(Delimiter);
          EXIT when iPtrStart > 0;
          vcSepBuffer    := vcSepBuffer||Delimiter;
        END LOOP;
        if vcSepBuffer is not null then     
          iPtrEnd := iStrLen;
        else 
          iPtrEnd := instr(Source_string,Delimiter,1,Field_Position);
          if iPtrEnd = 0 then 
              iPtrEnd := iStrLen;
          end if;
        end if;
      else     iPtrStart := 0;
        iPtrEnd := instr(Source_string,Delimiter,1,Field_Position);
        if iPtrEnd = 0 then 
            iPtrEnd := iStrLen;
        end if;
      end if;
    -- 3. Rebuild the string
      Source_string := substr(Source_string,1,iPtrStart)||vcSepBuffer||
                              String_to_add||Delimiter||substr(Source_string,iPtrEnd+length(Delimiter));
    -- 4. Sort out termination
      if UnTerminated then 
          Source_string := substr(Source_String,1,(length(Source_string)-length(Delimiter)));
      end if;
    end if;
  end PutString;

  Procedure PutNumber   (Source_string     in out varchar2,
                         number_to_add     in number,
                         Field_position    in number,
                         UnTerminated      in Boolean  default FALSE,
                         Delimiter         in varchar2 default ',') is
    
  begin
    -- 1. Just do datatype conversions and call the varchar2 varsion of put..
    DelimStr.PutString(Source_string, to_char(number_to_add), Field_position, UnTerminated, Delimiter);
  end PutNumber;

  Procedure PutDate   (Source_string     in out varchar2,
                       Date_to_add       in date,
                       Field_position    in number,
                       UnTerminated      in Boolean  default FALSE,
                       Delimiter         in varchar2 default ',') is

  begin
    -- 1. Just do datatype conversions and call the varchar2 varsion of put..
    DelimStr.PutString(Source_string, to_char(date_to_add,'DD-MON-YYYY HH24:MI:SS'), Field_position, UnTerminated, Delimiter);
  end PutDate;

  -- Overloaded versions of the "Puts"
  Procedure Put   (Source_string     in out varchar2,
                   String_to_add     in varchar2,
                   Field_position    in number,
                   UnTerminated      in Boolean  default FALSE,
                   Delimiter         in varchar2 default ',') is
  begin
    -- 1. Just do datatype conversions and call the varchar2 varsion of put..
    DelimStr.PutString(Source_string, string_to_add, Field_position, UnTerminated, Delimiter);
  end Put;

  Procedure Put   (Source_string     in out varchar2,
                   number_to_add     in number,
                   Field_position    in number,
                   UnTerminated      in Boolean  default FALSE,
                   Delimiter         in varchar2 default ',') is
  begin
    -- 1. Just do datatype conversions and call the varchar2 varsion of put..
    DelimStr.PutString(Source_string, to_char(number_to_add), Field_position, UnTerminated, Delimiter);
  end Put;

  Procedure Put   (Source_string     in out varchar2,
                   Date_to_add       in date,
                   Field_position    in number,
                   UnTerminated      in Boolean  default FALSE,
                   Delimiter         in varchar2 default ',') is
  begin
    -- 1. Just do datatype conversions and call the varchar2 varsion of put..
    DelimStr.PutString(Source_string, to_char(date_to_add,'DD-MON-YYYY HH24:MI:SS'), Field_position, UnTerminated, Delimiter);
  end Put;


  function  GetString (Source_string    in varchar2,
                       Field_position   in number,
                       UnTerminated     in Boolean  default FALSE,
                       Delimiter        in varchar2 default ',') return varchar2 is
                       iPtrEnd          pls_integer     := 0;
                       iPtrStart        pls_integer     := 0;
                       vcSourceStrCopy  varchar2(32000)     := Source_string;
  begin
    if UnTerminated then 
      vcSourceStrCopy := vcSourceStrCopy||Delimiter;
    end if;

    if Field_Position > 1 then 
      iPtrStart := instr(vcSourceStrCopy,Delimiter,1,Field_Position-1)+ length(Delimiter);
    else
      iPtrStart := 1;
    end if ; 

    iPtrEnd     := instr(vcSourceStrCopy,Delimiter,1,Field_Position);
    return substr(vcSourceStrCopy,iPtrStart,(iPtrEnd-iPtrStart));
  end GetString; /* String Version */

    
  function  GetNumber (Source_string    in varchar2,
                       Field_position   in number,
                       UnTerminated     in Boolean  default FALSE,
                       Delimiter        in varchar2 default ',') return number is
                       iRc              pls_integer;
  begin 
    Return to_number(GetString(Source_string, Field_Position, UnTerminated, Delimiter));
  end GetNumber; /* Number Version */

  function  GetDate (Source_string    in varchar2,
                     Field_position   in number,
                     UnTerminated     in Boolean  default FALSE,
                     Delimiter        in varchar2 default ',') return date is
  begin 
    return to_date(GetString(Source_string, Field_Position, UnTerminated, Delimiter),'DD-MON-YYYY HH24:MI:SS');
  end GetDate; /* Date Version */

  function  Locate  (Source_string    in varchar2,
                     Search_String    in varchar2,
                     UnTerminated     in Boolean  default FALSE,
                     Delimiter        in varchar2 default ',') return number is 
                     iHit             pls_integer := 0;
                     iCounter         pls_integer;
                     vcCompare        varchar2(32000);
  begin 
    for iCounter in 1..Counter(Source_String, UnTerminated, Delimiter) LOOP
      if GetString(Source_String,iCounter, UnTerminated, Delimiter) = Search_String then 
          iHit := iCounter;
          Exit;
      end if;
    end loop;
    Return iHit;
  end Locate;

  function  Locate(Source_string    in varchar2,
                   Search_date      in date,
                   UnTerminated     in Boolean  default FALSE,
                   Delimiter        in varchar2 default ',') return number is
  begin
    return Locate( Source_string, to_char(Search_date,'DD-MON-YYYY HH24:MI:SS'), UnTerminated, Delimiter);
  end Locate; /* Date Version */

  function  Locate(Source_string    in varchar2,
                   Search_number    in number,
                   UnTerminated     in Boolean  default FALSE,
                   Delimiter        in varchar2 default ',') return number is
  begin
    return Locate( Source_string, to_char(Search_number), UnTerminated, Delimiter);
  end Locate; /* Number Version */

END DelimStr; /* Body */


PACKAGE JAVA_APPSERV_READER /* oracle.forms.webutil.fileTransfer.AppServerFileReader */ IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 


  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT;

  -- Method: getSeparator ()Ljava/lang/String;
  FUNCTION getSeparator RETURN VARCHAR2;

  -- Method: openFile (Ljava/lang/String;I)Z
  FUNCTION openFile(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2,
    a1    NUMBER) RETURN BOOLEAN;

  -- Method: readData ()Ljava/lang/String;
  FUNCTION readData(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: closeFile ()Z
  FUNCTION closeFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: getSourceLength ()I
  FUNCTION getSourceLength(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getSourceChunks ()I
  FUNCTION getSourceChunks(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getLastError ()I
  FUNCTION getLastError(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getLastErrorArgs ()Ljava/lang/String;
  FUNCTION getLastErrorArgs(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: encodeBASE64File (Ljava/lang/String;)Z
  FUNCTION encodeBASE64File(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN;

END;


PACKAGE BODY JAVA_APPSERV_READER IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 

  args   JNI.ARGLIST;

  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN (JNI.NEW_OBJECT('oracle/forms/webutil/fileTransfer/AppServerFileReader', '()V', args));
  END;

  -- Method: getSeparator ()Ljava/lang/String;
  FUNCTION getSeparator RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'getSeparator', '()Ljava/lang/String;', args); 
  END;

  -- Method: openFile (Ljava/lang/String;I)Z
  FUNCTION openFile(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2,
    a1    NUMBER) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_INT_ARG(args, a1);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'openFile', '(Ljava/lang/String;I)Z', args); 
  END;

  -- Method: readData ()Ljava/lang/String;
  FUNCTION readData(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'readData', '()Ljava/lang/String;', args); 
  END;

  -- Method: closeFile ()Z
  FUNCTION closeFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'closeFile', '()Z', args); 
  END;

  -- Method: getSourceLength ()I
  FUNCTION getSourceLength(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'getSourceLength', '()I', args); 
  END;

  -- Method: getSourceChunks ()I
  FUNCTION getSourceChunks(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'getSourceChunks', '()I', args); 
  END;

  -- Method: getLastError ()I
  FUNCTION getLastError(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'getLastError', '()I', args); 
  END;

  -- Method: getLastErrorArgs ()Ljava/lang/String;
  FUNCTION getLastErrorArgs(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'getLastErrorArgs', '()Ljava/lang/String;', args); 
  END;

  -- Method: encodeBASE64File (Ljava/lang/String;)Z
  FUNCTION encodeBASE64File(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileReader', 'encodeBASE64File', '(Ljava/lang/String;)Z', args); 
  END;


BEGIN
  NULL;
END;


PACKAGE JAVA_APPSERV_WRITER /* oracle.forms.webutil.fileTransfer.AppServerFileWriter */ IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 


  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT;

  -- Method: openFile (Ljava/lang/String;)Z
  FUNCTION openFile(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN;

  -- Method: WriteData (Ljava/lang/String;)Z
  FUNCTION WriteData(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN;

  -- Method: closeFile (I)Z
  FUNCTION closeFile(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) RETURN BOOLEAN;

  -- Method: getLastError ()I
  FUNCTION getLastError(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getLastErrorArgs ()Ljava/lang/String;
  FUNCTION getLastErrorArgs(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: decodeBASE64File (Ljava/lang/String;)Z
  FUNCTION decodeBASE64File(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER);

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT);

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER);

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT);

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT);

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

END;


PACKAGE BODY JAVA_APPSERV_WRITER IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 

  args   JNI.ARGLIST;

  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN (JNI.NEW_OBJECT('oracle/forms/webutil/fileTransfer/AppServerFileWriter', '()V', args));
  END;

  -- Method: openFile (Ljava/lang/String;)Z
  FUNCTION openFile(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'openFile', '(Ljava/lang/String;)Z', args); 
  END;

  -- Method: WriteData (Ljava/lang/String;)Z
  FUNCTION WriteData(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'WriteData', '(Ljava/lang/String;)Z', args); 
  END;

  -- Method: closeFile (I)Z
  FUNCTION closeFile(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_INT_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'closeFile', '(I)Z', args); 
  END;

  -- Method: getLastError ()I
  FUNCTION getLastError(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'getLastError', '()I', args); 
  END;

  -- Method: getLastErrorArgs ()Ljava/lang/String;
  FUNCTION getLastErrorArgs(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'getLastErrorArgs', '()Ljava/lang/String;', args); 
  END;

  -- Method: decodeBASE64File (Ljava/lang/String;)Z
  FUNCTION decodeBASE64File(
    obj   ORA_JAVA.JOBJECT,
    a0    VARCHAR2) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'decodeBASE64File', '(Ljava/lang/String;)Z', args); 
  END;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'hashCode', '()I', args); 
  END;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'getClass', '()Ljava/lang/Class;', args); 
  END;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.ADD_INT_ARG(args, a1);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'wait', '(JI)V', args); 
  END;

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'wait', '()V', args); 
  END;

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'wait', '(J)V', args); 
  END;

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'equals', '(Ljava/lang/Object;)Z', args); 
  END;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'notify', '()V', args); 
  END;

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'notifyAll', '()V', args); 
  END;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'oracle/forms/webutil/fileTransfer/AppServerFileWriter', 'toString', '()Ljava/lang/String;', args); 
  END;


BEGIN
  NULL;
END;


PACKAGE JAVA_EXCEPTION /* java.lang.Exception */ IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 


  -- Constructor for signature (Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature (Ljava/lang/Throwable;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature (Ljava/lang/String;Ljava/lang/Throwable;)V
  FUNCTION new(
    a0    VARCHAR2,
    a1    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT;

  -- Method: printStackTrace (Ljava/io/PrintWriter;)V
  PROCEDURE printStackTrace_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT);

  -- Method: printStackTrace (Ljava/io/PrintStream;)V
  PROCEDURE printStackTrace_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT);

  -- Method: printStackTrace ()V
  PROCEDURE printStackTrace(
    obj   ORA_JAVA.JOBJECT);

  -- Method: fillInStackTrace ()Ljava/lang/Throwable;
  FUNCTION fillInStackTrace(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: initCause (Ljava/lang/Throwable;)Ljava/lang/Throwable;
  FUNCTION initCause(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: getCause ()Ljava/lang/Throwable;
  FUNCTION getCause(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: getLocalizedMessage ()Ljava/lang/String;
  FUNCTION getLocalizedMessage(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: getMessage ()Ljava/lang/String;
  FUNCTION getMessage(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: getStackTrace ()[Ljava/lang/StackTraceElement;
  FUNCTION getStackTrace(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: setStackTrace ([Ljava/lang/StackTraceElement;)V
  PROCEDURE setStackTrace(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JARRAY);

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER);

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT);

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER);

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT);

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT);

END;


PACKAGE BODY JAVA_EXCEPTION IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 

  args   JNI.ARGLIST;

  -- Constructor for signature (Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN (JNI.NEW_OBJECT('java/lang/Exception', '(Ljava/lang/String;)V', args));
  END;

  -- Constructor for signature (Ljava/lang/Throwable;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Throwable');
    RETURN (JNI.NEW_OBJECT('java/lang/Exception', '(Ljava/lang/Throwable;)V', args));
  END;

  -- Constructor for signature (Ljava/lang/String;Ljava/lang/Throwable;)V
  FUNCTION new(
    a0    VARCHAR2,
    a1    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_OBJECT_ARG(args, a1, 'java/lang/Throwable');
    RETURN (JNI.NEW_OBJECT('java/lang/Exception', '(Ljava/lang/String;Ljava/lang/Throwable;)V', args));
  END;

  -- Constructor for signature ()V
  FUNCTION new RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN (JNI.NEW_OBJECT('java/lang/Exception', '()V', args));
  END;

  -- Method: printStackTrace (Ljava/io/PrintWriter;)V
  PROCEDURE printStackTrace_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/PrintWriter');
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'printStackTrace', '(Ljava/io/PrintWriter;)V', args); 
  END;

  -- Method: printStackTrace (Ljava/io/PrintStream;)V
  PROCEDURE printStackTrace_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/PrintStream');
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'printStackTrace', '(Ljava/io/PrintStream;)V', args); 
  END;

  -- Method: printStackTrace ()V
  PROCEDURE printStackTrace(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'printStackTrace', '()V', args); 
  END;

  -- Method: fillInStackTrace ()Ljava/lang/Throwable;
  FUNCTION fillInStackTrace(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/Exception', 'fillInStackTrace', '()Ljava/lang/Throwable;', args); 
  END;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/lang/Exception', 'toString', '()Ljava/lang/String;', args); 
  END;

  -- Method: initCause (Ljava/lang/Throwable;)Ljava/lang/Throwable;
  FUNCTION initCause(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Throwable');
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/Exception', 'initCause', '(Ljava/lang/Throwable;)Ljava/lang/Throwable;', args); 
  END;

  -- Method: getCause ()Ljava/lang/Throwable;
  FUNCTION getCause(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/Exception', 'getCause', '()Ljava/lang/Throwable;', args); 
  END;

  -- Method: getLocalizedMessage ()Ljava/lang/String;
  FUNCTION getLocalizedMessage(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/lang/Exception', 'getLocalizedMessage', '()Ljava/lang/String;', args); 
  END;

  -- Method: getMessage ()Ljava/lang/String;
  FUNCTION getMessage(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/lang/Exception', 'getMessage', '()Ljava/lang/String;', args); 
  END;

  -- Method: getStackTrace ()[Ljava/lang/StackTraceElement;
  FUNCTION getStackTrace(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/Exception', 'getStackTrace', '()[Ljava/lang/StackTraceElement;', args); 
  END;

  -- Method: setStackTrace ([Ljava/lang/StackTraceElement;)V
  PROCEDURE setStackTrace(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JARRAY) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, '[Ljava/lang/StackTraceElement;');
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'setStackTrace', '([Ljava/lang/StackTraceElement;)V', args); 
  END;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'java/lang/Exception', 'hashCode', '()I', args); 
  END;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/Exception', 'getClass', '()Ljava/lang/Class;', args); 
  END;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.ADD_INT_ARG(args, a1);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'wait', '(JI)V', args); 
  END;

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'wait', '()V', args); 
  END;

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'wait', '(J)V', args); 
  END;

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/lang/Exception', 'equals', '(Ljava/lang/Object;)Z', args); 
  END;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'notify', '()V', args); 
  END;

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/Exception', 'notifyAll', '()V', args); 
  END;


BEGIN
  NULL;
END;


PACKAGE JAVA_FILE /* java.io.File */ IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 
  separatorChar  PLS_INTEGER;  -- separatorChar
  separator  VARCHAR2(256);  -- separator
  pathSeparatorChar  PLS_INTEGER;  -- pathSeparatorChar
  pathSeparator  VARCHAR2(256);  -- pathSeparator


  -- Constructor for signature (Ljava/io/File;Ljava/lang/String;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature (Ljava/net/URI;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature (Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2) RETURN ORA_JAVA.JOBJECT;

  -- Constructor for signature (Ljava/lang/String;Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: compareTo (Ljava/io/File;)I
  FUNCTION compareTo_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: compareTo (Ljava/lang/Object;)I
  FUNCTION compareTo_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: getName ()Ljava/lang/String;
  FUNCTION getName(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: length ()J
  FUNCTION length(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getCanonicalPath ()Ljava/lang/String;
  FUNCTION getCanonicalPath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: getParent ()Ljava/lang/String;
  FUNCTION getParent(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: isAbsolute ()Z
  FUNCTION isAbsolute(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: setReadOnly ()Z
  FUNCTION setReadOnly(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: list ()[Ljava/lang/String;
  FUNCTION list(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: list (Ljava/io/FilenameFilter;)[Ljava/lang/String;
  FUNCTION list(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: delete ()Z
  FUNCTION delete_(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: getPath ()Ljava/lang/String;
  FUNCTION getPath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: canRead ()Z
  FUNCTION canRead(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: canWrite ()Z
  FUNCTION canWrite(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: createNewFile ()Z
  FUNCTION createNewFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: createTempFile (Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;
  FUNCTION createTempFile(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT;

  -- Method: createTempFile (Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;
  FUNCTION createTempFile(
    a0    VARCHAR2,
    a1    VARCHAR2,
    a2    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: deleteOnExit ()V
  PROCEDURE deleteOnExit(
    obj   ORA_JAVA.JOBJECT);

  -- Method: exists ()Z
  FUNCTION exists_(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: getAbsoluteFile ()Ljava/io/File;
  FUNCTION getAbsoluteFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: getAbsolutePath ()Ljava/lang/String;
  FUNCTION getAbsolutePath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

  -- Method: getCanonicalFile ()Ljava/io/File;
  FUNCTION getCanonicalFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: getParentFile ()Ljava/io/File;
  FUNCTION getParentFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: isDirectory ()Z
  FUNCTION isDirectory(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: isFile ()Z
  FUNCTION isFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: isHidden ()Z
  FUNCTION isHidden(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: lastModified ()J
  FUNCTION lastModified(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: listFiles (Ljava/io/FileFilter;)[Ljava/io/File;
  FUNCTION listFiles_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: listFiles (Ljava/io/FilenameFilter;)[Ljava/io/File;
  FUNCTION listFiles_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: listFiles ()[Ljava/io/File;
  FUNCTION listFiles(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY;

  -- Method: listRoots ()[Ljava/io/File;
  FUNCTION listRoots RETURN ORA_JAVA.JARRAY;

  -- Method: mkdir ()Z
  FUNCTION mkdir(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: mkdirs ()Z
  FUNCTION mkdirs(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: renameTo (Ljava/io/File;)Z
  FUNCTION renameTo(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: setLastModified (J)Z
  FUNCTION setLastModified(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) RETURN BOOLEAN;

  -- Method: toURI ()Ljava/net/URI;
  FUNCTION toURI(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: toURL ()Ljava/net/URL;
  FUNCTION toURL(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER);

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT);

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER);

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT);

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT);

END;


PACKAGE BODY JAVA_FILE IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 

  args   JNI.ARGLIST;

  -- Constructor for signature (Ljava/io/File;Ljava/lang/String;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/File');
    JNI.ADD_STRING_ARG(args, a1);
    RETURN (JNI.NEW_OBJECT('java/io/File', '(Ljava/io/File;Ljava/lang/String;)V', args));
  END;

  -- Constructor for signature (Ljava/net/URI;)V
  FUNCTION new(
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/net/URI');
    RETURN (JNI.NEW_OBJECT('java/io/File', '(Ljava/net/URI;)V', args));
  END;

  -- Constructor for signature (Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN (JNI.NEW_OBJECT('java/io/File', '(Ljava/lang/String;)V', args));
  END;

  -- Constructor for signature (Ljava/lang/String;Ljava/lang/String;)V
  FUNCTION new(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_STRING_ARG(args, a1);
    RETURN (JNI.NEW_OBJECT('java/io/File', '(Ljava/lang/String;Ljava/lang/String;)V', args));
  END;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'java/io/File', 'hashCode', '()I', args); 
  END;

  -- Method: compareTo (Ljava/io/File;)I
  FUNCTION compareTo_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/File');
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'java/io/File', 'compareTo', '(Ljava/io/File;)I', args); 
  END;

  -- Method: compareTo (Ljava/lang/Object;)I
  FUNCTION compareTo_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'java/io/File', 'compareTo', '(Ljava/lang/Object;)I', args); 
  END;

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'equals', '(Ljava/lang/Object;)Z', args); 
  END;

  -- Method: getName ()Ljava/lang/String;
  FUNCTION getName(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'getName', '()Ljava/lang/String;', args); 
  END;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'toString', '()Ljava/lang/String;', args); 
  END;

  -- Method: length ()J
  FUNCTION length(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_LONG_METHOD(FALSE, obj, 'java/io/File', 'length', '()J', args); 
  END;

  -- Method: getCanonicalPath ()Ljava/lang/String;
  FUNCTION getCanonicalPath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'getCanonicalPath', '()Ljava/lang/String;', args); 
  END;

  -- Method: getParent ()Ljava/lang/String;
  FUNCTION getParent(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'getParent', '()Ljava/lang/String;', args); 
  END;

  -- Method: isAbsolute ()Z
  FUNCTION isAbsolute(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'isAbsolute', '()Z', args); 
  END;

  -- Method: setReadOnly ()Z
  FUNCTION setReadOnly(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'setReadOnly', '()Z', args); 
  END;

  -- Method: list ()[Ljava/lang/String;
  FUNCTION list(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'list', '()[Ljava/lang/String;', args); 
  END;

  -- Method: list (Ljava/io/FilenameFilter;)[Ljava/lang/String;
  FUNCTION list(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/FilenameFilter');
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'list', '(Ljava/io/FilenameFilter;)[Ljava/lang/String;', args); 
  END;

  -- Method: delete ()Z
  FUNCTION delete_(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'delete', '()Z', args); 
  END;

  -- Method: getPath ()Ljava/lang/String;
  FUNCTION getPath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'getPath', '()Ljava/lang/String;', args); 
  END;

  -- Method: canRead ()Z
  FUNCTION canRead(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'canRead', '()Z', args); 
  END;

  -- Method: canWrite ()Z
  FUNCTION canWrite(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'canWrite', '()Z', args); 
  END;

  -- Method: createNewFile ()Z
  FUNCTION createNewFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'createNewFile', '()Z', args); 
  END;

  -- Method: createTempFile (Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;
  FUNCTION createTempFile(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_STRING_ARG(args, a1);
    RETURN JNI.CALL_OBJECT_METHOD(TRUE, NULL, 'java/io/File', 'createTempFile', '(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;', args); 
  END;

  -- Method: createTempFile (Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;
  FUNCTION createTempFile(
    a0    VARCHAR2,
    a1    VARCHAR2,
    a2    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(3);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_STRING_ARG(args, a1);
    JNI.ADD_OBJECT_ARG(args, a2, 'java/io/File');
    RETURN JNI.CALL_OBJECT_METHOD(TRUE, NULL, 'java/io/File', 'createTempFile', '(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;', args); 
  END;

  -- Method: deleteOnExit ()V
  PROCEDURE deleteOnExit(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'deleteOnExit', '()V', args); 
  END;

  -- Method: exists ()Z
  FUNCTION exists_(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'exists', '()Z', args); 
  END;

  -- Method: getAbsoluteFile ()Ljava/io/File;
  FUNCTION getAbsoluteFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'getAbsoluteFile', '()Ljava/io/File;', args); 
  END;

  -- Method: getAbsolutePath ()Ljava/lang/String;
  FUNCTION getAbsolutePath(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/io/File', 'getAbsolutePath', '()Ljava/lang/String;', args); 
  END;

  -- Method: getCanonicalFile ()Ljava/io/File;
  FUNCTION getCanonicalFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'getCanonicalFile', '()Ljava/io/File;', args); 
  END;

  -- Method: getParentFile ()Ljava/io/File;
  FUNCTION getParentFile(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'getParentFile', '()Ljava/io/File;', args); 
  END;

  -- Method: isDirectory ()Z
  FUNCTION isDirectory(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'isDirectory', '()Z', args); 
  END;

  -- Method: isFile ()Z
  FUNCTION isFile(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'isFile', '()Z', args); 
  END;

  -- Method: isHidden ()Z
  FUNCTION isHidden(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'isHidden', '()Z', args); 
  END;

  -- Method: lastModified ()J
  FUNCTION lastModified(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_LONG_METHOD(FALSE, obj, 'java/io/File', 'lastModified', '()J', args); 
  END;

  -- Method: listFiles (Ljava/io/FileFilter;)[Ljava/io/File;
  FUNCTION listFiles_0(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/FileFilter');
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'listFiles', '(Ljava/io/FileFilter;)[Ljava/io/File;', args); 
  END;

  -- Method: listFiles (Ljava/io/FilenameFilter;)[Ljava/io/File;
  FUNCTION listFiles_1(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/FilenameFilter');
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'listFiles', '(Ljava/io/FilenameFilter;)[Ljava/io/File;', args); 
  END;

  -- Method: listFiles ()[Ljava/io/File;
  FUNCTION listFiles(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'listFiles', '()[Ljava/io/File;', args); 
  END;

  -- Method: listRoots ()[Ljava/io/File;
  FUNCTION listRoots RETURN ORA_JAVA.JARRAY IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(TRUE, NULL, 'java/io/File', 'listRoots', '()[Ljava/io/File;', args); 
  END;

  -- Method: mkdir ()Z
  FUNCTION mkdir(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'mkdir', '()Z', args); 
  END;

  -- Method: mkdirs ()Z
  FUNCTION mkdirs(
    obj   ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'mkdirs', '()Z', args); 
  END;

  -- Method: renameTo (Ljava/io/File;)Z
  FUNCTION renameTo(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/File');
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'renameTo', '(Ljava/io/File;)Z', args); 
  END;

  -- Method: setLastModified (J)Z
  FUNCTION setLastModified(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_LONG_ARG(args, a0);
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/io/File', 'setLastModified', '(J)Z', args); 
  END;

  -- Method: toURI ()Ljava/net/URI;
  FUNCTION toURI(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'toURI', '()Ljava/net/URI;', args); 
  END;

  -- Method: toURL ()Ljava/net/URL;
  FUNCTION toURL(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'toURL', '()Ljava/net/URL;', args); 
  END;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/io/File', 'getClass', '()Ljava/lang/Class;', args); 
  END;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.ADD_INT_ARG(args, a1);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'wait', '(JI)V', args); 
  END;

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'wait', '()V', args); 
  END;

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'wait', '(J)V', args); 
  END;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'notify', '()V', args); 
  END;

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/io/File', 'notifyAll', '()V', args); 
  END;


BEGIN
  -- separatorChar (C)
  separatorChar := JNI.GET_CHAR_FIELD(TRUE, NULL, 'java/io/File', 'separatorChar', 'C');

  -- separator (Ljava/lang/String;)
  separator := JNI.GET_STRING_FIELD(TRUE, NULL, 'java/io/File', 'separator', 'Ljava/lang/String;');

  -- pathSeparatorChar (C)
  pathSeparatorChar := JNI.GET_CHAR_FIELD(TRUE, NULL, 'java/io/File', 'pathSeparatorChar', 'C');

  -- pathSeparator (Ljava/lang/String;)
  pathSeparator := JNI.GET_STRING_FIELD(TRUE, NULL, 'java/io/File', 'pathSeparator', 'Ljava/lang/String;');

END;


PACKAGE JAVA_SYSTEM /* java.lang.System */ IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 
  in_  ORA_JAVA.JOBJECT;  -- in
  out_  ORA_JAVA.JOBJECT;  -- out
  err  ORA_JAVA.JOBJECT;  -- err


  -- Method: arraycopy (Ljava/lang/Object;ILjava/lang/Object;II)V
  PROCEDURE arraycopy(
    a0    ORA_JAVA.JOBJECT,
    a1    NUMBER,
    a2    ORA_JAVA.JOBJECT,
    a3    NUMBER,
    a4    NUMBER);

  -- Method: currentTimeMillis ()J
  FUNCTION currentTimeMillis RETURN NUMBER;

  -- Method: identityHashCode (Ljava/lang/Object;)I
  FUNCTION identityHashCode(
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: exit (I)V
  PROCEDURE exit_(
    a0    NUMBER);

  -- Method: runFinalizersOnExit (Z)V
  PROCEDURE runFinalizersOnExit(
    a0    BOOLEAN);

  -- Method: setProperty (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  FUNCTION setProperty(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN VARCHAR2;

  -- Method: getProperty (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getProperty(
    a0    VARCHAR2) RETURN VARCHAR2;

  -- Method: getProperty (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getProperty(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN VARCHAR2;

  -- Method: getSecurityManager ()Ljava/lang/SecurityManager;
  FUNCTION getSecurityManager RETURN ORA_JAVA.JOBJECT;

  -- Method: load (Ljava/lang/String;)V
  PROCEDURE load(
    a0    VARCHAR2);

  -- Method: loadLibrary (Ljava/lang/String;)V
  PROCEDURE loadLibrary(
    a0    VARCHAR2);

  -- Method: mapLibraryName (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION mapLibraryName(
    a0    VARCHAR2) RETURN VARCHAR2;

  -- Method: gc ()V
  PROCEDURE gc;

  -- Method: getProperties ()Ljava/util/Properties;
  FUNCTION getProperties RETURN ORA_JAVA.JOBJECT;

  -- Method: getenv (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getenv(
    a0    VARCHAR2) RETURN VARCHAR2;

  -- Method: runFinalization ()V
  PROCEDURE runFinalization;

  -- Method: setErr (Ljava/io/PrintStream;)V
  PROCEDURE setErr(
    a0    ORA_JAVA.JOBJECT);

  -- Method: setIn (Ljava/io/InputStream;)V
  PROCEDURE setIn(
    a0    ORA_JAVA.JOBJECT);

  -- Method: setOut (Ljava/io/PrintStream;)V
  PROCEDURE setOut(
    a0    ORA_JAVA.JOBJECT);

  -- Method: setProperties (Ljava/util/Properties;)V
  PROCEDURE setProperties(
    a0    ORA_JAVA.JOBJECT);

  -- Method: setSecurityManager (Ljava/lang/SecurityManager;)V
  PROCEDURE setSecurityManager(
    a0    ORA_JAVA.JOBJECT);

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER);

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT);

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER);

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT);

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT);

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2;

END;


PACKAGE BODY JAVA_SYSTEM IS

  -- 
  -- DO NOT EDIT THIS FILE - it is machine generated!
  -- 

  args   JNI.ARGLIST;

  -- Method: arraycopy (Ljava/lang/Object;ILjava/lang/Object;II)V
  PROCEDURE arraycopy(
    a0    ORA_JAVA.JOBJECT,
    a1    NUMBER,
    a2    ORA_JAVA.JOBJECT,
    a3    NUMBER,
    a4    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(5);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    JNI.ADD_INT_ARG(args, a1);
    JNI.ADD_OBJECT_ARG(args, a2, 'java/lang/Object');
    JNI.ADD_INT_ARG(args, a3);
    JNI.ADD_INT_ARG(args, a4);
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'arraycopy', '(Ljava/lang/Object;ILjava/lang/Object;II)V', args); 
  END;

  -- Method: currentTimeMillis ()J
  FUNCTION currentTimeMillis RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_LONG_METHOD(TRUE, NULL, 'java/lang/System', 'currentTimeMillis', '()J', args); 
  END;

  -- Method: identityHashCode (Ljava/lang/Object;)I
  FUNCTION identityHashCode(
    a0    ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_INT_METHOD(TRUE, NULL, 'java/lang/System', 'identityHashCode', '(Ljava/lang/Object;)I', args); 
  END;

  -- Method: exit (I)V
  PROCEDURE exit_(
    a0    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_INT_ARG(args, a0);
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'exit', '(I)V', args); 
  END;

  -- Method: runFinalizersOnExit (Z)V
  PROCEDURE runFinalizersOnExit(
    a0    BOOLEAN) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_BOOLEAN_ARG(args, a0);
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'runFinalizersOnExit', '(Z)V', args); 
  END;

  -- Method: setProperty (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  FUNCTION setProperty(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_STRING_ARG(args, a1);
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'java/lang/System', 'setProperty', '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;', args); 
  END;

  -- Method: getProperty (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getProperty(
    a0    VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'java/lang/System', 'getProperty', '(Ljava/lang/String;)Ljava/lang/String;', args); 
  END;

  -- Method: getProperty (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getProperty(
    a0    VARCHAR2,
    a1    VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.ADD_STRING_ARG(args, a1);
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'java/lang/System', 'getProperty', '(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;', args); 
  END;

  -- Method: getSecurityManager ()Ljava/lang/SecurityManager;
  FUNCTION getSecurityManager RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(TRUE, NULL, 'java/lang/System', 'getSecurityManager', '()Ljava/lang/SecurityManager;', args); 
  END;

  -- Method: load (Ljava/lang/String;)V
  PROCEDURE load(
    a0    VARCHAR2) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'load', '(Ljava/lang/String;)V', args); 
  END;

  -- Method: loadLibrary (Ljava/lang/String;)V
  PROCEDURE loadLibrary(
    a0    VARCHAR2) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'loadLibrary', '(Ljava/lang/String;)V', args); 
  END;

  -- Method: mapLibraryName (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION mapLibraryName(
    a0    VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'java/lang/System', 'mapLibraryName', '(Ljava/lang/String;)Ljava/lang/String;', args); 
  END;

  -- Method: gc ()V
  PROCEDURE gc IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'gc', '()V', args); 
  END;

  -- Method: getProperties ()Ljava/util/Properties;
  FUNCTION getProperties RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(TRUE, NULL, 'java/lang/System', 'getProperties', '()Ljava/util/Properties;', args); 
  END;

  -- Method: getenv (Ljava/lang/String;)Ljava/lang/String;
  FUNCTION getenv(
    a0    VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_STRING_ARG(args, a0);
    RETURN JNI.CALL_STRING_METHOD(TRUE, NULL, 'java/lang/System', 'getenv', '(Ljava/lang/String;)Ljava/lang/String;', args); 
  END;

  -- Method: runFinalization ()V
  PROCEDURE runFinalization IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'runFinalization', '()V', args); 
  END;

  -- Method: setErr (Ljava/io/PrintStream;)V
  PROCEDURE setErr(
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/PrintStream');
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'setErr', '(Ljava/io/PrintStream;)V', args); 
  END;

  -- Method: setIn (Ljava/io/InputStream;)V
  PROCEDURE setIn(
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/InputStream');
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'setIn', '(Ljava/io/InputStream;)V', args); 
  END;

  -- Method: setOut (Ljava/io/PrintStream;)V
  PROCEDURE setOut(
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/io/PrintStream');
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'setOut', '(Ljava/io/PrintStream;)V', args); 
  END;

  -- Method: setProperties (Ljava/util/Properties;)V
  PROCEDURE setProperties(
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/util/Properties');
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'setProperties', '(Ljava/util/Properties;)V', args); 
  END;

  -- Method: setSecurityManager (Ljava/lang/SecurityManager;)V
  PROCEDURE setSecurityManager(
    a0    ORA_JAVA.JOBJECT) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/SecurityManager');
    JNI.CALL_VOID_METHOD(TRUE, NULL, 'java/lang/System', 'setSecurityManager', '(Ljava/lang/SecurityManager;)V', args); 
  END;

  -- Method: hashCode ()I
  FUNCTION hashCode(
    obj   ORA_JAVA.JOBJECT) RETURN NUMBER IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_INT_METHOD(FALSE, obj, 'java/lang/System', 'hashCode', '()I', args); 
  END;

  -- Method: getClass ()Ljava/lang/Class;
  FUNCTION getClass(
    obj   ORA_JAVA.JOBJECT) RETURN ORA_JAVA.JOBJECT IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_OBJECT_METHOD(FALSE, obj, 'java/lang/System', 'getClass', '()Ljava/lang/Class;', args); 
  END;

  -- Method: wait (JI)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER,
    a1    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(2);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.ADD_INT_ARG(args, a1);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/System', 'wait', '(JI)V', args); 
  END;

  -- Method: wait ()V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/System', 'wait', '()V', args); 
  END;

  -- Method: wait (J)V
  PROCEDURE wait(
    obj   ORA_JAVA.JOBJECT,
    a0    NUMBER) IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_LONG_ARG(args, a0);
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/System', 'wait', '(J)V', args); 
  END;

  -- Method: equals (Ljava/lang/Object;)Z
  FUNCTION equals(
    obj   ORA_JAVA.JOBJECT,
    a0    ORA_JAVA.JOBJECT) RETURN BOOLEAN IS
  BEGIN
    args := JNI.CREATE_ARG_LIST(1);
    JNI.ADD_OBJECT_ARG(args, a0, 'java/lang/Object');
    RETURN JNI.CALL_BOOLEAN_METHOD(FALSE, obj, 'java/lang/System', 'equals', '(Ljava/lang/Object;)Z', args); 
  END;

  -- Method: notify ()V
  PROCEDURE notify(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/System', 'notify', '()V', args); 
  END;

  -- Method: notifyAll ()V
  PROCEDURE notifyAll(
    obj   ORA_JAVA.JOBJECT) IS
  BEGIN
    args := NULL;
    JNI.CALL_VOID_METHOD(FALSE, obj, 'java/lang/System', 'notifyAll', '()V', args); 
  END;

  -- Method: toString ()Ljava/lang/String;
  FUNCTION toString(
    obj   ORA_JAVA.JOBJECT) RETURN VARCHAR2 IS
  BEGIN
    args := NULL;
    RETURN JNI.CALL_STRING_METHOD(FALSE, obj, 'java/lang/System', 'toString', '()Ljava/lang/String;', args); 
  END;


BEGIN
  -- in (Ljava/io/InputStream;)
  in_ := JNI.GET_OBJECT_FIELD(TRUE, NULL, 'java/lang/System', 'in', 'Ljava/io/InputStream;');

  -- out (Ljava/io/PrintStream;)
  out_ := JNI.GET_OBJECT_FIELD(TRUE, NULL, 'java/lang/System', 'out', 'Ljava/io/PrintStream;');

  -- err (Ljava/io/PrintStream;)
  err := JNI.GET_OBJECT_FIELD(TRUE, NULL, 'java/lang/System', 'err', 'Ljava/io/PrintStream;');

END;


PROCEDURE SHOW_WEBUTIL_INFORMATION(display in BOOLEAN default TRUE) IS
/*********************************************************************************\
 * SHOW_WEBUTIL_INFORMATION
 *   Causes the WebUtil Hidden Window to display and gives access to the version 
 *   numbers of each of the components
 *   Setting the display argument to false hides the window again
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   DRMILLS 26/FEB/2003 - Creation
 *
\*********************************************************************************/ 
BEGIN
  WebUtil_Core.ShowBeans(display);
END;


PACKAGE WEBUTIL_BROWSER IS
/*********************************************************************************\
 * WEBUTIL_BROWSER
 *   This Package contains routines to interact with the hosting Browser or
 *   The functions in this package will work with any client type - not just 
 *   Windows clients.
 *   The oracle.forms.webutil.browser.BrowserFunctions bean is needed in your 
 *   Form to use these functions
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 25/MAY/2003 - Creation
 *   1.0.1 DRMILLS 27/MAY/2003 - Added call to get Applet Size & Applet Parameters
 *
\*********************************************************************************/

  -- Browser Functions

  /**
   *  ShowMenuBar - Hide or show the Forms menu Bar
   *                Note this only works when the Menu property in the Form 
   *                is set to null - e.g only the "Window" menu shows.
   *                As such this call allows you to create a menuless form
   *                For best effect also set logo=no in the FormsWeb.cfg or
   *                you'll still have the space at the top of the screen allocated
   *                for that
   */ 
   
   PROCEDURE ShowMenuBar(showBar BOOLEAN);
   
  /**
   *  ShowStatusBar - Hide or show the Forms status Bar
   *                This is just like setting the console window property
   *                but can be done dynamically rather than at design time
   */ 
   
   PROCEDURE ShowStatusBar(showBar BOOLEAN);
   
  /**
   *  BrowserMessage - Sends a message to the Browser status line
   */   
   PROCEDURE BrowserMessage(msg VARCHAR2);
   
  /**
   *  GetAppletSize - returns the available size of the Applet Area as a
   *                  width,height pair - measured in Pixels
   */   
   FUNCTION GetAppletSize return VARCHAR2;
   
  /**
   * GetAppletParameter - returns the value of the specified parameter to the Applet
   */ 
  FUNCTION GetAppletParameter(parameter in VARCHAR2) return VARCHAR2;       
 
END WEBUTIL_BROWSER;


PACKAGE BODY WEBUTIL_BROWSER IS

  -- Implemenations   
  PROCEDURE ShowMenuBar(showBar BOOLEAN) is 
  BEGIN 
    WebUtil_SeparateFrame.ShowMenuBar(showBar);
  END ShowMenuBar;
  
  PROCEDURE ShowStatusBar(showBar BOOLEAN) is
  BEGIN 
    WebUtil_SeparateFrame.ShowStatusBar(showBar);
  END ShowStatusBar;
  
  PROCEDURE BrowserMessage(msg VARCHAR2) is
  BEGIN
    if msg is null OR msg = '' then
      WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_BROWSER_MESSAGE',' ', true);
    else
      WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_BROWSER_MESSAGE',msg, true);
    end if;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_BROWSER.BrowserMessage will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;        
  END BrowserMessage;  
  
  FUNCTION GetAppletSize return VARCHAR2 is
  BEGIN 
    return WebUtil_SeparateFrame.GetSeparateFrameSize;
  END GetAppletSize;
  
  FUNCTION GetAppletParameter(parameter in VARCHAR2) return VARCHAR2 is  
  begin
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_APPLET_PARAMETER',parameter); 
    return WebUtil_Core.getProperty(WebUtil_Core.WUB_PACKAGE,'WUB_APPLET_PARAMETER');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_BROWSER.GetAppletParameter will not work');
      return null;
   when WebUtil_Core.PROPERTY_ERROR then 
     RAISE FORM_TRIGGER_FAILURE;  
  END GetAppletParameter;  
  
BEGIN 
  -- Explicitly instanciate CORE
  WebUtil_Core.Init; 
END WEBUTIL_BROWSER;


PACKAGE WEBUTIL_CLIENTINFO IS
/*********************************************************************************\
 * WEBUTIL_CLIENTINFO
 *   This Package contains routines to get basic information about the Client
 *   browser machine
 *   The functions in this package will work with any client type - not just 
 *   Windows clients.
 *   The oracle.forms.webutil.clientInfo.GetClientInfo bean is needed in your 
 *   Form to use these functions
 *********************************************************************************
 * Version 1.0.1
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 20/DEC/2002 - Creation
 *   1.0.1 DRMILLS 13/MAY/2003 - Added call to WebUtil_Core.Init
 *   1.0.3 OSINGH  06/NOV/2003 - Corrected the spelling of SEPARATOR
 *
\*********************************************************************************/

  /**
   * GET_USER_NAME - returns the name of the O/S user of the Browser client
   */ 
  FUNCTION GET_USER_NAME return VARCHAR2;

  /**
   * GET_IP_ADDRESS - returns the IP Address of the Browser client
   */ 
  FUNCTION GET_IP_ADDRESS return VARCHAR2;
  
  /**
   * GET_HOST_NAME - returns the Hostname of the Browser client
   */ 
  FUNCTION GET_HOST_NAME return VARCHAR2;  

  /**
   * GET_OPERATING_SYSTEM - returns the Operating system of the Browser client
   */ 
  FUNCTION GET_OPERATING_SYSTEM return VARCHAR2;

  /**
   * GET_JAVA_VERSION - returns the version of the operating JVM in the Browser client
   */ 
  FUNCTION GET_JAVA_VERSION return VARCHAR2;
  
  /**
   * GET_PATH_SEPARATOR - returns the path separator used by the client OS
   * e.g. ";" on a Windows Client, ":" on Unix/Linux
   */ 
  FUNCTION GET_PATH_SEPARATOR return VARCHAR2;
  
  /**
   * GET_FILE_SEPARATOR - returns the file separator used by the client OS
   * e.g. "\" on a Windows Client, "/" on Unix/Linux   
   */ 
  FUNCTION GET_FILE_SEPARATOR return VARCHAR2;
  
  /**
   * GET_LANGUAGE - returns the language country code of the client
   */ 
  FUNCTION GET_LANGUAGE return VARCHAR2;  

  /**
   * GET_TIME_ZONE - returns the Timezone being used by the client
   */ 
  FUNCTION GET_TIME_ZONE return VARCHAR2;  

  /**
   * GET_DATE_TIME - returns the date and time as it stands on the client
   */ 
  FUNCTION GET_DATE_TIME return DATE;  
  
  /**
   * GET_SYSTEM_PROPERTY - returns the value of the specified Java System Property
   */ 
  FUNCTION GET_SYSTEM_PROPERTY(property in VARCHAR2) return VARCHAR2;    
 
END WEBUTIL_CLIENTINFO;


PACKAGE BODY WEBUTIL_CLIENTINFO IS

  FUNCTION GET_USER_NAME return VARCHAR2 is
  begin
    return WebUtil_Core.getClientUserName;
  end GET_USER_NAME;
  
  FUNCTION GET_IP_ADDRESS return VARCHAR2 is
  begin
    return WebUtil_Core.getClientIPAddress;
  end GET_IP_ADDRESS;
  
  FUNCTION GET_HOST_NAME return VARCHAR2 is
  begin
    return WebUtil_Core.getProperty(WebUtil_Core.WUI_PACKAGE,'WUI_HOSTNAME');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REBIND_PARAMETER will not work');
      return null;
  end GET_HOST_NAME;
  
  FUNCTION GET_OPERATING_SYSTEM return VARCHAR2 is
  begin
    return WebUtil_Core.getClientOS;
  end GET_OPERATING_SYSTEM;
  
  FUNCTION GET_JAVA_VERSION return VARCHAR2 is
  begin
    return WebUtil_Core.getProperty(WebUtil_Core.WUI_PACKAGE,'WUI_CLIENT_JAVA_VERSION');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUI_PACKAGE)
                              ||' bean not found. WEBUTIL_CLIENTINFO.GET_JAVA_VERSION will not work');
      return null;
  end GET_JAVA_VERSION;
  
  FUNCTION GET_PATH_SEPARATOR return VARCHAR2 is
  begin
    return WebUtil_Core.getClientPathSep;
  end GET_PATH_SEPARATOR;
  
  FUNCTION GET_FILE_SEPARATOR return VARCHAR2 is
  begin
    return WebUtil_Core.getClientFileSep;
  end GET_FILE_SEPARATOR;
  
  FUNCTION GET_LANGUAGE return VARCHAR2 is
  begin
    return WebUtil_Core.getClientLocale;
  end GET_LANGUAGE;
  
  FUNCTION GET_TIME_ZONE return VARCHAR2 is
  begin
    return WebUtil_Core.getProperty(WebUtil_Core.WUI_PACKAGE,'WUI_CLIENT_TZ');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUI_PACKAGE)
                            ||' bean not found. WEBUTIL_CLIENTINFO.GET_TIME_ZONE will not work');
    return null;
  end GET_TIME_ZONE;
   
  FUNCTION GET_DATE_TIME return DATE is
    dateString VARCHAR2(40 char);
  begin
    dateString := WebUtil_Core.getProperty(WebUtil_Core.WUI_PACKAGE,'WUI_CLIENT_DATE');
    return to_date(dateString,'YYYY MM DD HH24:MI:SS');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUI_PACKAGE)
              ||' bean not found. WEBUTIL_CLIENTINFO.GET_DATE_TIME will not work');
      return null;
  end GET_DATE_TIME;
   
  FUNCTION GET_SYSTEM_PROPERTY(property in VARCHAR2) return VARCHAR2 is
  begin
    WebUtil_Core.setProperty(WebUtil_Core.WUI_PACKAGE,'WUI_SYSTEM_PROPERTY',property); 
    return WebUtil_Core.getProperty(WebUtil_Core.WUI_PACKAGE,'WUI_SYSTEM_PROPERTY');
  exception
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUI_PACKAGE)
                              ||' bean not found. WEBUTIL_CLIENTINFO.GET_SYSTEM_PROPERTY will not work');
      return null;
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE;
  end GET_SYSTEM_PROPERTY;
  
  
BEGIN 
  -- Explicitly instanciate CORE
  WebUtil_Core.Init;
END WEBUTIL_CLIENTINFO;


PACKAGE WEBUTIL_CORE IS
/*********************************************************************************\
 * WEBUTIL_CORE
 *   This Package contains core WebUtil Routines.
 *   In general you should not call methods in this package directly unless
 *   you are actually extending the WebUtil utility as a whole
 *   Do not make changes in the package unless you are adding 
 *   You own functions - in which case make sure you read about how to 
 *   extend WebUtil in the doc.
 *********************************************************************************
 * Version 1.0.9
 *********************************************************************************
 * Change History
 * 1.0.0  DRMILLS 01/NOV/2002 - Creation & Registering of Core, File and ClientInfo
 * 1.0.1  DRMILLS 24/JAN/2003 - Made Alert handling more robust and added self 
 *                              initialisation in the form of InitWebUtil proc.
 *                              Added WUL contants and packages for ORA_FFI interface.
 * 1.0.2  DRMILLS 28/JAN/2003 - Added the Callback trigger list functionality for 
 *                              WEBUTIL_HOST
 *                              Added the new calls Get/SetClientSetting() to 
 *                              persist information on the client machine in 
 *                              webutil.properties
 *                              Added downloadFromURL() to push things like 
 *                              DLLs onto the client machine
 * 1.0.3  DRMILLS 31/JAN/2003 - Added routines PersistReference() and 
 *                              FreeReference() to handle cross-Form/Session 
 *                              object persistance
 * 1.0.4  DRMILLS 10/FEB/2003 - Added error() to allow non-client side
 *                              routines to set the error info and pop up an
 *                              alert all in one function
 * 1.0.5  DRMILLS 21/FEB/2003 - Added support for auto download of user libraries 
 * 1.0.6  DRMILLS 12/MAR/2003 - Fixed 2839033 now only handle WebUtil events
 *                              Fixed the timing issue in 2836929
 *                              Moved CheckJava into this package from file 
 *                              transfer and made it more comprehensive
 *                              so that it actually checks that the frmwebutil.jar
 *                              is were the classpath says it is.  This will help 
 *                              to detect typos in the classpath
 * 1.0.7  DRMILLS 13/MAY/2003 - Fixed 2955789 navigation to instanciate the 
 *                              webutil block was causing a problem in 
 *                              Enter-Query mode 
 *                              Added the Flag FLAG_EXPICIT_INSTANCIATE to 
 *                              allow explicit instanciation if it's really 
 *                              needed.
 *                              Added the INIT procedure for the other WebUtil 
 *                              Programs to explicitly invoke Core to instanciate 
 *                              rather than just relying on ad-hoc references 
 *                              to do the calls.
 * 1.0.8 DRMILLS 25/MAY/2003  - Added the Browser functions WUB implementation class
 *                              package 6
 * 1.0.9 DRMILLS 03/JUN/2003  - Fixed a problem with Host callbacks not being
 *                              processed due to typo on the event handler
\*********************************************************************************/
  /**
   * The PLL Version as a whole
   */
   WEBUTIL_VERSION VARCHAR2(30);
   
  /**
   * Flag to indicate that syslib should be redownloaded to client, irrespective
   * of the version numbers.
   */
   REDOWNLOAD_SYSLIB BOOLEAN;

  /**
   * Constants used throughout webutil
   */
   WUC_PACKAGE CONSTANT PLS_INTEGER := 0;
   WUT_PACKAGE CONSTANT PLS_INTEGER := 1;
   WUF_PACKAGE CONSTANT PLS_INTEGER := 2;
   WUI_PACKAGE CONSTANT PLS_INTEGER := 3;
   WUH_PACKAGE CONSTANT PLS_INTEGER := 4;
   WUS_PACKAGE CONSTANT PLS_INTEGER := 5;   
   WUB_PACKAGE CONSTANT PLS_INTEGER := 6;
   WUO_PACKAGE CONSTANT PLS_INTEGER := 7;
   WUU_PACKAGE CONSTANT PLS_INTEGER := 8;
   WUL_PACKAGE CONSTANT PLS_INTEGER := 9;   
   
  /**
   * Hold a list of constants for the O/S family
   */
  CLIENT_PLATFORM_WIN32   CONSTANT PLS_INTEGER := 0;
  CLIENT_PLATFORM_LINUX   CONSTANT PLS_INTEGER := 1;
  CLIENT_PLATFORM_SOLARIS CONSTANT PLS_INTEGER := 2;
  CLIENT_PLATFORM_HP      CONSTANT PLS_INTEGER := 3;  
  CLIENT_PLATFORM_AIX     CONSTANT PLS_INTEGER := 4;  
  CLIENT_PLATFORM_MAC     CONSTANT PLS_INTEGER := 5;
  CLIENT_PLATFORM_UNKNOWN CONSTANT PLS_INTEGER := 9;   

  /**
   * List of build architecture
   */
  CLIENT_OS_ARCH_32 CONSTANT PLS_INTEGER := 0;
  CLIENT_OS_ARCH_64 CONSTANT PLS_INTEGER := 1;

  /** 
   * Important Objects 
   */
  WEBUTIL_CONFIG_PARAM    CONSTANT VARCHAR2(23) := 'PARAMETER.WEBUTILCONFIG';
  WEBUTIL_CONFIG_GLOBAL   CONSTANT VARCHAR2(20) := 'GLOBAL.WEBUTILCONFIG';      
  WEBUTIL_CONFIG_ENV      CONSTANT VARCHAR2(20) := 'WEBUTIL_CONFIG';       
  
   
  /**
   * Exceptions
   */
  BEAN_NOT_REGISTERED EXCEPTION;
  PROPERTY_ERROR      EXCEPTION;
  UNEXPECTED_ERROR    EXCEPTION;    
  
  /**
   * Special Flags - the following switches change the behaviour of the utility in 
   * Some way - you may be asked by support to set these.
   * If these are defined as CONSTANT they will need to be set here in the code rather than from 
   * some calling procedure 
   */
  -- If this flag is set, the first call to WebUtil will navigate to the 
  -- WebUtil block to ensure that the PJCs on the client have all been created.
  -- Normally Forms will handle this without the navigation being required.
  -- Setting this flag will have side effects see Bug 2955789 
  FLAG_EXPICIT_INSTANCIATE CONSTANT BOOLEAN := FALSE;

  -- Error code from last setProperty or getProperty with bypassErrorCheck := false
  m_lastError     PLS_INTEGER := 0;

  /**
   * Core procedures
   */ 
   
  /**
   * CustomEventHandler - used from the When-Custom-Item-Event trigger 
   * of all the webutil beans
   * Handles all of the messages that those beans can raise
   */ 
  PROCEDURE CustomEventHandler(EventName in VARCHAR2, EventParameters in VARCHAR2);  

  /**
   * SetProperty - Wrapper for SET_CUSTOM_PROPERTY - has the 
   * advantage that you don't have to worry about which item 
   * to set the property on as the registration process will 
   * implicitly know which item to use 
   * If the SetProperty fails then PROPERTY_ERROR will 
   * be raised
   */ 
  PROCEDURE SetProperty(packageID        in PLS_INTEGER, 
                        propertyName     in VARCHAR2, 
                        propertyValue    in VARCHAR2,
                        bypassErrorCheck in BOOLEAN DEFAULT true);

  PROCEDURE SetProperty(packageID        in PLS_INTEGER, 
                        propertyName     in VARCHAR2, 
                        propertyValue    in BOOLEAN,
                        bypassErrorCheck in BOOLEAN DEFAULT true);                                                

  /**
   * GetProperty - Wrapper for GET_CUSTOM_PROPERTY - has the 
   * advantage that you don't have to worry about which item 
   * to set the property on as the registration process will 
   * implicitly know which item to use 
   * Returns the value of the requested property or null
   */ 
  FUNCTION GetProperty(packageID in PLS_INTEGER, 
                       propertyName in VARCHAR2,
                       bypassErrorCheck in BOOLEAN DEFAULT true) return VARCHAR2;
                       
                       
  /**
   * GetClientSetting - queries the value in the webutil.properties
   * file on the client used for system settings such as DLL versions
   * but also available for personalisation
   */                       
  FUNCTION GetClientSetting(propertyName in VARCHAR2) return VARCHAR2;

  /**
   * SetClientSetting - sets a value in the webutil.properties
   * file on the client used for system settings such as DLL versions
   * but also available for personalisation
   */                       
  PROCEDURE SetClientSetting(propertyName  in VARCHAR2,
                             propertyValue in VARCHAR2);   
                       
  /**
   * Log - Writes a message to the Webutil server side log file
   * This is mainly used by the Core Log and Error functions 
   * used by the WebUtil Beans, but is available here to 
   * allow Other Webutil packages to write further messages
   * if required.
   * The name and location of the log file is defined in the
   * webutil config file.
   */ 
  PROCEDURE Log(msg in VARCHAR2, isError BOOLEAN);
  
  /**
   * ReadFromPropertyBundle - Reads the value of a name=value
   * pair from the config file used by the utility
   */ 
  FUNCTION ReadFromPropertyBundle(propertyKey in VARCHAR2) return VARCHAR2;

  /**
   * ReadTranslatableFromMsgBundle - Reads the translated message string
   * from the java list resource MsgBundle using the propertyKey. args
   * is the format arguments, if any, delimited by '|'
   * This function is no longer used for getting error messages. It is
   * still there mainly for getting the title of self-install URL-downloads
   * progress dialog.
   */ 
  FUNCTION ReadTransFromMsgBundle(propertyKey in VARCHAR2, args in VARCHAR2 := null) return VARCHAR2;

  /**
   * ErrorAlert - pops up an alert with the specified raw error message.
   * There is no translation done for this. This is used mainly for throwing
   * errors when beans are not initialised. Without beans, we cannot get
   * translated message from java list resource bundle.
   */ 
  PROCEDURE ErrorAlert(errText in VARCHAR2);

  -- Functions to access the last Error raised.
  -- It must be called to check the last setProperty call with bypassErrorCheck = false
  FUNCTION isError   return BOOLEAN;
  
  -- Function to do all the error stuff for non client side functions
  PROCEDURE Error(packageID in PLS_INTEGER, code in PLS_INTEGER, pu_name in VARCHAR2,
                  arg1 in VARCHAR2 := null, arg2 in VARCHAR2 := null, arg3 in VARCHAR2 := null);

  /**
   * getImplClass - returns the implementation class for this package 
   */ 
  FUNCTION getImplClass(packageID PLS_INTEGER) return VARCHAR2;

  -- Various informational functions returning info about the client ---------------

  /**
   * GetClientUsername - returns the name of the O/S user of the Browser client
   */ 
  FUNCTION GetClientUsername return VARCHAR2;

  /**
   * GetClientIPAddress - returns the IP Address of the Browser client
   */ 
  FUNCTION GetClientIPAddress return VARCHAR2;

  /**
   * GetClientOS - returns the Operating system of the Browser client
   */ 
  FUNCTION GetClientOS return VARCHAR2;

  /**
   * GetClientOSFamily - returns a constant representing the Client OS
   * All windows platforms come out as CLIENT_PLATFORM_WIN32,
   * both MAC and MAC OS X come out as CLIENT_PLATFORM_MAC
   * For the exact OS use GetClientOS
   */ 
  FUNCTION GetClientOSFamily return PLS_INTEGER;

  /**
   * GetClientPathSep - returns the path separator used by the client OS
   */ 
  FUNCTION GetClientPathSep return VARCHAR2;
  
  /**
   * GetClientFileSep - returns the file separator used by the client OS
   */ 
  FUNCTION GetClientFileSep return VARCHAR2;
  
  /**
   * GetServerFileSep - returns the file separator used by the application
   * server O/S 
   */ 
  FUNCTION GetServerFileSep return VARCHAR2;  
  
  /**
   * GetClientLocale - returns the country code of the client locale
   */ 
  FUNCTION GetClientLocale return VARCHAR2;  
 
  /**
   * ShowBeans - displays or hides the window that actually holds the 
   * WebUtil Bean areas - use to debug the bean versions being used
   */
  PROCEDURE ShowBeans(show BOOLEAN);
  
  /**
   * SetCallbackTrigger - Stores the name of a trigger to execute 
   * when a particular callback is made
   */
  PROCEDURE SetCallbackTrigger(callbackKey in PLS_INTEGER, triggerName in VARCHAR2);
  
  /**
   * GetCallbackTrigger - gets the name of a trigger to execute 
   * when a particular callback is made
   */
  FUNCTION GetCallbackTrigger(callbackKey in PLS_INTEGER) return VARCHAR2;  
  
  /**
   * ClearCallbackTrigger - Cleans this entry from the callback cache
   */
  PROCEDURE ClearCallbackTrigger(callbackKey in PLS_INTEGER);
  
  /**
   * GetLastCallbackId - returns the ID of the object passed with the callback
   */
  FUNCTION GetLastCallbackId return  PLS_INTEGER;
  
  /**
   * DownLoadFromURL - pulls a file from the specified URL on the server and 
   * sends it via http to the specified destination on the client
   * If you specify file size we can so a comparison after download to ensure 
   * that the sizes match
   * Additionally of you specify withProgress and size you will get a progress
   * bar
   * Note that the Title, subtitle and message strings cannot contain the '|'
   * character
   */
  FUNCTION DownLoadFromURL(sourceURL         in VARCHAR2, 
                           clientDestination in VARCHAR2, 
                           fileSize          in PLS_INTEGER default 0) return BOOLEAN;
                           
  FUNCTION DownLoadFromURLWithProgress(sourceURL         in VARCHAR2, 
                           clientDestination in VARCHAR2, 
                           fileSize          in PLS_INTEGER,
                           progressTitle     in VARCHAR2,
                           progressSubTitle  in VARCHAR2,
                           progressMessage   in VARCHAR2) return BOOLEAN;                           
                           
  /**
   * PersistReference - Prevents a Java Object Refrence from being automatically 
   * removed when the Bean Area is destroyed
   * - This is for the use of other WebUtil packages and generally should not be used
   *   directly
   */          
  PROCEDURE PersistReference(packageID in PLS_INTEGER, objectHandle in PLS_INTEGER);
  
  /**
   * FreeReference - Explicitly removes an object from the client side cache.
   * Use this to clean up Persisted references
   * - This is for the use of other WebUtil packages and generally should not be used
   *   directly
   */          
  PROCEDURE FreeReference(packageID in PLS_INTEGER, objectHandle in PLS_INTEGER);
  
  /**
   * CheckJava - Function to check that server side java is configured to run OK and 
   * That the frmwebutil.jar is where it is supposed to be 
   * - This is for the use of other WebUtil packages and generally should not be used
   *   directly
   */          
  FUNCTION checkJava return BOOLEAN;     
  
  /**
   * Init - procedure used internally to ensure that the various WebUtil calls all 
   * instanciate this package 
   */          
  PROCEDURE Init;  
   
END WEBUTIL_CORE;


PACKAGE BODY WEBUTIL_CORE IS
  -- internal exceptions
  CLIENT_FILE_NULL   EXCEPTION;
  URL_NULL           EXCEPTION;

  -- Types
  TYPE arrRegistered     is table of VARCHAR2(61 char) index by BINARY_INTEGER;
  TYPE recPropertyBundle is record (propertyKey VARCHAR2(120 char), propertyValue VARCHAR2(1000));
  TYPE arrPropertyBundle is table of recPropertyBundle index by BINARY_INTEGER;  
  TYPE arrImplClass      is table of VARCHAR2(60 char) index by BINARY_INTEGER;
  TYPE arrCallbacks      is table of VARCHAR2(30 char) index by BINARY_INTEGER;  
  
  -- Private package variables -------------------------------------
  /**
   * Hold the list of all the beans that have made themselves known 
   * to the form
   */
  m_registeredPackages arrRegistered;

  /**
   * Hold the list of callbacks 
   * and the ID of the last callback
   */
  m_callbacks arrCallbacks;   
  m_lastCallback PLS_INTEGER;
  
  
  /**
   * Hold the names of the pre-packaged webutil objects 
   * The Alert is the most important and must be avaiable
   * See InitWebUtil for this and other setup.
   */     
  WEBUTIL_HIDDEN_WINDOW   CONSTANT VARCHAR2(21) := 'WEBUTIL_HIDDEN_WINDOW';
  WEBUTIL_DUMMY_ITEM      CONSTANT VARCHAR2(13) := 'WEBUTIL.DUMMY';  
  WEBUTIL_ERROR_ALERT     CONSTANT VARCHAR2(13) := 'WEBUTIL_ERROR';
  WEBUTIL_JAVA_ROOT       CONSTANT VARCHAR2(21) := 'oracle.forms.webutil.'; 
  
  /**
   * Hold a list of the implementation class for each bean
   */
  m_implClasses arrImplClass; 
  
  /**
   * hold all the properties from the config file
   */
  m_propertyBundle arrPropertyBundle;
  m_config_error BOOLEAN := false;
  
  /**
   * logging Information cached here
   */
  m_loggingAllowed    BOOLEAN := null;
  m_loggingErrorsOnly BOOLEAN := null;
  m_loggingFile       VARCHAR2(1024 char);
  
  /**
   * Information about the client
   */
  m_clientIP          VARCHAR2(15 char);
  m_clientOS          VARCHAR2(40 char);
  m_clientOSFamily    PLS_INTEGER;
  m_clientOSArch      PLS_INTEGER := 0;
  m_clientUserName    VARCHAR2(80 char);
  m_clientPathSep     VARCHAR2(1 char);
  m_clientFileSep     VARCHAR2(1 char);
  m_serverFileSep     VARCHAR2(1 char);  
  m_clientLangCode    VARCHAR2(2 char);
  
  
  /**
   * If there is a mid tier error we'll need to 
   * display it in this alert.
   */
  m_errorAlert ALERT := FIND_ALERT(WEBUTIL_ERROR_ALERT);
  
  /**
   * If the Info Window is shown cache the field
   * we came from
   */
  m_infoFrom ITEM;
  
  
  /**
   * Can we call mid-teir java?
   */
  m_javaOK          BOOLEAN := null;  
       
    
  -- Private Program units -----------------------------------------
  /**
   * Register a new bean in the list of registered beans
   */
  PROCEDURE registerBean(clientInfo in VARCHAR2);

  /**
   * Populate up the property bundle that defines the properties 
   * for this bean
   * As a shortcut we can check for the key that was being looked for 
   * in the call that populated the bundle in the first place
   */
  FUNCTION PopulatePropertyBundle(propertyKey in VARCHAR2) return VARCHAR2;
  
  /**
   * Check the client side error condition and set the relevant variables
   * for in the package
   */
  PROCEDURE CheckLastError(bean ITEM); 
  
  /**
   * Instanciate the Beans used by WebUtil by navigating to the block
   * The block is on it's own window so can be hidden from the rest of 
   * the app once it's instanciated
   */
  PROCEDURE InitWebUtil;  
  
  /**
   * Get the registered handler bean for this particular package
   * The only twist here is that any bean can handle WUC (common) 
   * requests so just find the first one
   */
  FUNCTION getHandlerBean(packageID in PLS_INTEGER) return VARCHAR2;  
  
  /**
   * Carry out general and specialised downloads
   */  
  FUNCTION DownLoadFromURLInt(sourceURL          in VARCHAR2, 
                              clientDestination  in VARCHAR2,
                              specialDestination in PLS_INTEGER default 0,
                              fileSize           in PLS_INTEGER default 0, 
                              withProgress       in BOOLEAN default false,
                              progressTitle      in VARCHAR2 default null,
                              progressSubTitle   in VARCHAR2 default null,
                              progressMessage    in VARCHAR2 default null) return BOOLEAN;
                             
  /**
   * Check that any required libraries are available
   */  
  PROCEDURE CheckLibs(packageID in VARCHAR2);                             
    
  /**
   * Function to work out what OS family we are dealing
   * with.
   * Translates the value returned by 
   * System.getProperty("os.name");
   * into a constant value
   */  
  FUNCTION getOSFamily(osName in VARCHAR2) return PLS_INTEGER;
  
  
  -- Public Program Unit Implementations ----------------------------
  PROCEDURE CustomEventHandler(EventName       in VARCHAR2, 
                               EventParameters in VARCHAR2) is
    dataPayload   VARCHAR2(32000 char);   
    dataMultiPart VARCHAR2(61 char); /* should be enough! */ 
    chunkNumber   PLS_INTEGER;
    PayloadChunks PLS_INTEGER;
    dataType      PLS_INTEGER;
    unhandled     EXCEPTION;
  begin
    --Bug 2839033 - check for valid events only      
    if EventName not in ('WUC_LOG_EVENT',
                         'WUC_ERROR_EVENT', 
                         'WUC_REGISTER',
                         'WUH_CALLBACK_EVENT', 
                         'WUT_TRANSFER_EVENT') then  
      raise unhandled;
    end if;                        

    -- We're pretty much always going to need the data payload and 
    -- number of parts that make up that payload so get it now..
    get_parameter_attr(EventParameters,'WUC_DATA',dataType, dataPayload);
    get_parameter_attr(EventParameters,'WUC_DATA_MULTIPART',dataType, dataMultiPart);      
    -- split the MULTIPART info to work out how many messages from the 
    -- client are required to create the completed payload
    chunkNumber   := DelimStr.getNumber(dataMultiPart,1,true,'/');
    PayloadChunks := DelimStr.getNumber(dataMultiPart,2,true,'/');

    -- Now deal with the specific events that the client may dispatch
    -- This section will have to be extended for each new event that we 
    -- Add in order to hook the handler code for that message to the data 
    -- that is being sent - shame we can't subclass in PL/SQL :-)      
    if EventName = 'WUC_LOG_EVENT' then
        WebUtil_Core.log(dataPayload,false);
    elsif EventName = 'WUC_ERROR_EVENT' then
        WebUtil_Core.log(dataPayload,true);
    elsif EventName = 'WUC_REGISTER' then 
        registerBean(dataPayload);
    elsif EventName = 'WUH_CALLBACK_EVENT' then 
      begin 
        m_lastCallback := to_number(dataPayload);
      exception
          when INVALID_NUMBER then 
            error(WebUtil_Core.WUC_PACKAGE,408,'WEBUTIL_CORE.CustomEventHandler');
      end;
      if m_lastCallback is not null then 
          EXECUTE_TRIGGER(m_callbacks(m_lastCallback));
      else
            log('Callback trigger for host command not specified',true);
      end if;
    elsif EventName = 'WUT_TRANSFER_EVENT' then 
      WebUtil_File_Transfer.setData(dataPayload);
      WebUtil_Core.setProperty(WebUtil_Core.WUT_PACKAGE, 'WUT_TRANSFER_EVENT','RECEIVED');
    end if;
  exception
    when unhandled then
      null;
    when OTHERS then
      raise;
  end CustomEventHandler;
  
  
  PROCEDURE SetProperty(packageID       in PLS_INTEGER, 
                        propertyName     in VARCHAR2, 
                        propertyValue    in VARCHAR2,
                        bypassErrorCheck in BOOLEAN DEFAULT true) is
    bean ITEM;                       
  begin
    -- note that a call to the common package can be handled by
    -- any bean
    bean := find_item(getHandlerBean(packageID));
    if id_null(bean) then 
      raise WEBUTIL_CORE.BEAN_NOT_REGISTERED;
    end if;
    SET_CUSTOM_PROPERTY(bean,1,propertyName,propertyValue);
    if not FORM_SUCCESS then 
      raise WEBUTIL_CORE.PROPERTY_ERROR;
    end if;
    if not bypassErrorCheck then 
      CheckLastError(bean);
    end if;
  exception
    when NO_DATA_FOUND then 
      RAISE WEBUTIL_CORE.BEAN_NOT_REGISTERED;
    when OTHERS then 
      RAISE;
  end SetProperty;       

  PROCEDURE SetProperty(packageID     in PLS_INTEGER, 
                        propertyName  in VARCHAR2, 
                        propertyValue in BOOLEAN,
                        bypassErrorCheck in BOOLEAN DEFAULT true) is
  begin
    SetProperty(packageID, propertyName, WebUtil_Util.BoolToStr(propertyValue,'TRUE','FALSE'), bypassErrorCheck);
  end SetProperty;
                                   
  FUNCTION GetProperty(packageID in PLS_INTEGER, 
                       propertyName in VARCHAR2,
                       bypassErrorCheck in BOOLEAN DEFAULT true) return VARCHAR2 is
    bean ITEM;                       
    result VARCHAR2(32000);
  begin
    bean := find_item(getHandlerBean(packageID));
    if id_null(bean) then 
      raise WEBUTIL_CORE.BEAN_NOT_REGISTERED;
    end if;
    result := GET_CUSTOM_PROPERTY(bean,1,propertyName);
    if not FORM_SUCCESS then 
      raise WEBUTIL_CORE.PROPERTY_ERROR;
    end if;
    if not bypassErrorCheck then 
      CheckLastError(bean);
    end if;
    return result;
  exception
  when NO_DATA_FOUND then 
    RAISE WEBUTIL_CORE.BEAN_NOT_REGISTERED;
  when OTHERS then 
    RAISE;      
  end GetProperty;   
  
  FUNCTION GetClientSetting(propertyName in VARCHAR2) return VARCHAR2 is 
    result VARCHAR2(255 char);
  BEGIN
    if propertyName is not null then 
    WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_GET_LOCAL_PROPERTY', propertyName);
       result := WebUtil_Core.getProperty(WebUtil_Core.WUC_PACKAGE,'WUC_GET_LOCAL_PROPERTY');
    end if;
    return result;
  EXCEPTION  
  when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUC_PACKAGE)
                            ||' bean not found. WEBUTIL_CORE.GetClientSetting will not work');
    RAISE FORM_TRIGGER_FAILURE;  
  when WebUtil_Core.PROPERTY_ERROR then 
    RAISE FORM_TRIGGER_FAILURE;       
  END GetClientSetting;

  PROCEDURE SetClientSetting(propertyName  in VARCHAR2,
                             propertyValue in VARCHAR2) is
  BEGIN
    if propertyName is not null then 
      WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_SET_LOCAL_PROPERTY', propertyName||'='||propertyValue);
    end if;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUC_PACKAGE)
                              ||' bean not found. WEBUTIL_CORE.SetClientSetting will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;       
  END SetClientSetting;                              
  

  PROCEDURE Log(msg in VARCHAR2, isError BOOLEAN) is
    logFile       TEXT_IO.FILE_TYPE;
    logFileName   VARCHAR2(1024 char);
    errorOnlyMode BOOLEAN;
  begin
    -- check to see if we should do anything
    if m_loggingAllowed is null then 
      -- set up the logging info Cache
      m_loggingAllowed    := (lower(ReadFromPropertyBundle('logging.enabled')) = 'true');
      m_loggingErrorsOnly := (lower(ReadFromPropertyBundle('logging.errorsonly')) = 'true');
      m_loggingFile       := ReadFromPropertyBundle('logging.file');
      if m_loggingAllowed then 
        if m_loggingFile is null then 
          -- no file == no logging
          m_loggingAllowed := false;
          if m_registeredPackages.FIRST is null then
            -- There is no bean registered yet. Throw error in English using alert
            ErrorAlert('WUC-008: Server side logging was requested but no log file was specified'
                       ||' - logging is disabled');
          else
            WebUtil_Core.setProperty(WUC_PACKAGE,'WUC_SRV_LOGGING','0',true);
            WebUtil_Core.error(WUC_PACKAGE,8,'WebUtil_Core.Log');
          end if;
        end if;
      end if;
      if m_registeredPackages.FIRST is not null then
        -- At least one bean is registered. Can call setProperty(WUC_PACKAGE)
        if m_loggingAllowed and m_loggingErrorsOnly then
          WebUtil_Core.setProperty(WUC_PACKAGE,'WUC_SRV_LOGGING','1',true);
        elsif  m_loggingAllowed then
          WebUtil_Core.setProperty(WUC_PACKAGE,'WUC_SRV_LOGGING','2',true);
        else
          WebUtil_Core.setProperty(WUC_PACKAGE,'WUC_SRV_LOGGING','0',true);
        end if;
      end if;
    end if;
        
    -- now log if allowed to do so
    if m_loggingAllowed then
      if ((not m_loggingErrorsOnly) or (m_loggingErrorsOnly and isError)) then
        logFile := TEXT_IO.FOPEN(m_loggingFile,'A');
        if not TEXT_IO.IS_OPEN(logFile) then 
          raise NO_DATA_FOUND;
        end if;
        if m_clientIP is null then
        	TEXT_IO.PUT_LINE(logFile,msg);
        else
        	TEXT_IO.PUT_LINE(logFile,m_clientIP||':'||m_clientUserName||': '||msg);
        end if;
        TEXT_IO.FCLOSE(logFile);
      end if;    
    end if;
  EXCEPTION
    when others then 
      if SQLCODE = '-302000' then
        if m_registeredPackages.FIRST is null then
          -- There is no bean registered yet. Throw error in English using alert
          ErrorAlert('WUC-007: Unable to write to WebUtil Logging File '|| m_loggingFile);
        else

          WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_SRV_LOGGING','0',true);
          WebUtil_Core.error(WebUtil_Core.WUC_PACKAGE,7,'WebUtil_Core.Log',m_loggingFile);
        end if;
        m_loggingAllowed := false;
      else
        RAISE;
      end if;      
  end Log; 
  
  FUNCTION ReadFromPropertyBundle(propertyKey in VARCHAR2) return VARCHAR2 is   
    result       VARCHAR2(1000 char);
    propCount    PLS_INTEGER := m_propertyBundle.COUNT;
  begin
    if m_config_error then
      -- already encountered problem reading the config file.
      return null;
    elsif (propCount = 0) then
      result := populatePropertyBundle(propertyKey);
    else
      for i in 1..propCount LOOP
        if m_propertyBundle(i).propertyKey = lower(propertyKey) then 
          result := m_propertyBundle(i).propertyValue;
          EXIT;
        end if;
      end LOOP;
    end if;
    return result;
  end ReadFromPropertyBundle;  
  
  FUNCTION ReadTransFromMsgBundle(propertyKey in VARCHAR2, args in VARCHAR2 := null) return VARCHAR2 is
    -- currently called from checkLibs only for getting progress bar title.
  begin 
    Webutil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_TRANS_MSG', propertyKey||'|'||args);
    return Webutil_Core.getProperty(WebUtil_Core.WUC_PACKAGE,'WUC_TRANS_MSG');
  end ReadTransFromMsgBundle;
  
  PROCEDURE ErrorAlert(errText in VARCHAR2) is
    -- currently used for throwing a BEAN_NOT_REGISTERED or bean not found error.
    ignore integer;
  begin
    if not ID_NULL(m_errorAlert) then 
      --SET_ALERT_PROPERTY(m_errorAlert,TITLE,'WebUtil Error'); -- title already set in alert property
      SET_ALERT_PROPERTY(m_errorAlert,ALERT_MESSAGE_TEXT,errText);
      ignore := SHOW_ALERT(m_errorAlert);
    else
      message('WebUtil Error'||': '||errText);
    end if;
  end ErrorAlert;         

  FUNCTION getImplClass(packageID PLS_INTEGER) return VARCHAR2 is
  BEGIN 
    return WEBUTIL_JAVA_ROOT||m_implClasses(packageID);    
  END;
  
  -- Accessors for Error condition
  FUNCTION isError   return BOOLEAN is
  begin 
    return m_lastError <> 0;
  end;
  
  PROCEDURE Error(packageID in PLS_INTEGER,
                  code      in PLS_INTEGER,
                  pu_name   in VARCHAR2,
                  arg1      in VARCHAR2 :=null,
                  arg2      in VARCHAR2 := null,
                  arg3      in VARCHAR2 := null
                 ) is
    errText varchar2(1024);
  begin 
    errText := 'ERROR'||lpad(to_char(code),3,'0') || '|' || pu_name;
    if arg1 is not null then
      errText := errText || '|' || arg1;
    end if;
    if arg2 is not null then
      errText := errText || '|' || arg2;
    end if;
    if arg3 is not null then
      errText := errText || '|' || arg3;
    end if;
    Webutil_Core.setProperty(packageID, 'WUC_ERROR_MSG', errText);
  end Error;  
  
  -- Accessors for Client Information
  FUNCTION GetClientUsername return VARCHAR2 is
  begin 
    return m_clientUserName;
  end GetClientUsername; 

  FUNCTION GetClientIPAddress return VARCHAR2 is
  begin 
    return m_clientIP;
  end GetClientIPAddress; 

  FUNCTION GetClientOS return VARCHAR2 is
  begin 
    return m_clientOS;
  end GetClientOS; 

  FUNCTION GetClientOSFamily return PLS_INTEGER is 
  begin 
    return m_clientOSFamily;
  end GetClientOSFamily; 
  

  FUNCTION GetClientPathSep return VARCHAR2 is
  begin 
    return m_clientPathSep;
  end GetClientPathSep; 
  
  FUNCTION GetClientFileSep return VARCHAR2 is
  begin 
    return m_clientFileSep;
  end GetClientFileSep; 
  
  FUNCTION GetServerFileSep return VARCHAR2 is    
  begin 
    return m_serverFileSep;
  end GetServerFileSep; 
  
  FUNCTION GetClientLocale return VARCHAR2 is
  begin 
    return m_clientLangCode;
  end GetClientLocale;   
  
  PROCEDURE ShowBeans(show BOOLEAN) is
    hWin WINDOW := FIND_WINDOW(WEBUTIL_HIDDEN_WINDOW);
  begin
    -- Bug 2955789 - don't attempt to do this when in Enter Query Mode
    if name_in('SYSTEM.MODE') = 'NORMAL' then 
      if not ID_NULL(hWin) then 
        if show then 
          m_infoFrom := FIND_ITEM(name_in('SYSTEM.CURSOR_ITEM'));
          SET_WINDOW_PROPERTY(hWin,TITLE,'WebUtil '||WEBUTIL_VERSION);
          SHOW_WINDOW(hWin);
          go_item(WEBUTIL_DUMMY_ITEM);
        else
          if not id_null(m_infoFrom) then 
              go_item(m_infoFrom);
          end if;
          HIDE_WINDOW(hWin);
        end if;
      end if;
    end if;
  end ShowBeans;
  
  PROCEDURE SetCallbackTrigger(callbackKey in PLS_INTEGER, triggerName in VARCHAR2) is
  begin 
    m_callbacks(callbackKey) := triggerName;
  end SetCallbackTrigger;
  
  FUNCTION GetCallbackTrigger(callbackKey in PLS_INTEGER) return VARCHAR2 is 
  begin 
    return m_callbacks(callbackKey);
  end GetCallbackTrigger; 
  
  PROCEDURE ClearCallbackTrigger(callbackKey in PLS_INTEGER) is
  begin
    if m_callbacks.exists(callbackKey) then 
      m_callbacks.delete(callbackKey);  
    end if;
  end ClearCallbackTrigger;
  
  FUNCTION GetLastCallbackId return  PLS_INTEGER is
  begin
    return m_lastCallback;
  end GetLastCallbackId;  
  
  FUNCTION DownLoadFromURL(sourceURL         in VARCHAR2, 
                           clientDestination in VARCHAR2, 
                           fileSize          in PLS_INTEGER default 0) return BOOLEAN is
  BEGIN
    return DownLoadFromURLInt(sourceURL,
                              ClientDestination,
                              0,
                              fileSize,
                              false,
                              null,
                              null,
                              null);
  END DownLoadFromURL;    
  
  FUNCTION DownLoadFromURLWithProgress(
                           sourceURL         in VARCHAR2, 
                           clientDestination in VARCHAR2, 
                           fileSize          in PLS_INTEGER,
                           progressTitle     in VARCHAR2,
                           progressSubTitle  in VARCHAR2,
                           progressMessage   in VARCHAR2) return BOOLEAN is
  BEGIN
    return DownLoadFromURLInt(sourceURL,
                              ClientDestination,
                              0,
                              fileSize,
                              true,
                              progressTitle,
                              progressSubTitle,
                              progressMessage);
  END DownLoadFromURLWithProgress;   
  
  PROCEDURE PersistReference(packageID in PLS_INTEGER, objectHandle in PLS_INTEGER) is
  BEGIN
    if (objectHandle > 0 and objectHandle is not null) then 
    WebUtil_Core.setProperty(packageID,'WUC_GLOBAL_REFERENCE',to_char(objectHandle)||'|Y');              
    end if;
  END PersistReference; 
  
  PROCEDURE FreeReference(packageID in PLS_INTEGER, objectHandle in PLS_INTEGER) is  
  BEGIN
    if (objectHandle > 0 and objectHandle is not null) then 
    WebUtil_Core.setProperty(packageID,'WUC_GLOBAL_REFERENCE',to_char(objectHandle)||'|N');                        
    end if;      
  END FreeReference; 
  
  -- Private Program Unit Implementations ---------------------------

  /** 
   * registerBean is called when a WUC_REGISTER message is received 
   * from the client.  It maintains a list of the registered beans
   * (and hence the packages that can be used - WUI, WUF etc.
   *  Because it records the item that is hosting the bean, this 
   *  allows other Packages within the library to get an set 
   *  properties on that bean without having to know which item 
   *  it actually is - removing any name dependencies
   */
  PROCEDURE registerBean(clientInfo in VARCHAR2) is  
    packageID       PLS_INTEGER;
    beanShortName   VARCHAR2(3 char);
    newPackage      BOOLEAN := false;
    checkUserLibs   BOOLEAN := false;
    clientLibDir    VARCHAR2(1000 char);
    clientLibDirOld VARCHAR2(1000 char);
    serverHost      VARCHAR2(100 char);
    blockAllowHeartBeat VARCHAR2(10 char);
    clientOSArch    VARCHAR2(30 char);
  begin
    beanShortName := DelimStr.getString(clientInfo,1,true,'|');

    -- To speed access up we crossmatch the Bean Name string
    -- with a constant - this constant is used to access the 
    -- registered package array efficently
    -- need to update this IF statement as we add new packages
    if beanShortName = 'WUC' then
       packageID := WEBUTIL_CORE.WUC_PACKAGE; 
    elsif beanShortName = 'WUT' then     
       packageID := WEBUTIL_CORE.WUT_PACKAGE; 
    elsif beanShortName = 'WUF' then 
       packageID := WEBUTIL_CORE.WUF_PACKAGE; 
    elsif beanShortName = 'WUI' then
        packageID := WEBUTIL_CORE.WUI_PACKAGE; 
    elsif beanShortName = 'WUH' then            
       packageID := WEBUTIL_CORE.WUH_PACKAGE;
    elsif beanShortName = 'WUS' then     
       packageID := WEBUTIL_CORE.WUS_PACKAGE;
    elsif beanShortName = 'WUB' then 
       packageID := WEBUTIL_CORE.WUB_PACKAGE;
    elsif beanShortName = 'WUO' then     
       packageID := WEBUTIL_CORE.WUO_PACKAGE;
    elsif beanShortName = 'WUU' then     
       packageID := WEBUTIL_CORE.WUU_PACKAGE;
    elsif beanShortName = 'WUL' then     
       packageID := WEBUTIL_CORE.WUL_PACKAGE;           
    end if;
    -- For the very first bean we can get a bit of useful information
    -- Only do this once
    if m_clientIP is null then 
      checkUserLibs := true;
      -- Format of the clientinfo packet is
      -- BeanName|IP|OSName|UserName|pathSep|filesep
      m_clientIP       := DelimStr.getString(clientInfo,2,true,'|');
      m_clientOS       := DelimStr.getString(clientInfo,3,true,'|');
      m_clientOSFamily := getOSFamily(m_clientOS);
      clientOSArch     := DelimStr.getString(clientInfo,4,true,'|');
      if instr(clientOSArch, '64') > 0 then
        m_clientOSArch := 1;
      end if;
      m_clientUserName := DelimStr.getString(clientInfo,5,true,'|');      
      m_clientPathSep  := DelimStr.getString(clientInfo,6,true,'|');
      m_clientFileSep  := DelimStr.getString(clientInfo,7,true,'|');
      m_clientLangCode := DelimStr.getString(clientInfo,8,true,'|'); 
    end if;
      
    -- I'd only expect one instance of each bean per form
    -- but just in case we only register the first 
    -- so if multiple copies are used - e.g. it's 
    -- placed in a multi-row block we just use the 
    -- first instance.
    if not m_registeredPackages.EXISTS(packageID) then 
      m_registeredPackages(packageID) := name_in('SYSTEM.TRIGGER_ITEM');
      -- make sure all the required libraries are available
      -- on the client
      newPackage := true;
    end if;
      
    if checkUserLibs then
      -- checkUserLibs would be true if clientIP was null
      -- We can do whatever we want to do but not more than once
      REDOWNLOAD_SYSLIB := FALSE;
      -- We need to get the server host name using available built-ins. This looks lame,
      -- but it should work
      TOOL_ENV.GETVAR('COMPUTERNAME', serverHost);
      if serverHost is null then
        TOOL_ENV.GETVAR('HOST', serverHost);
      end if;
      clientLibDir := readFromPropertyBundle('install.syslib.location.client.'||to_char(m_clientOSFamily) ||
                                             '.' || to_char(m_clientOSArch));
      if clientLibDir is null then
        clientLibDir := readFromPropertyBundle('install.syslib.location.client.'||to_char(m_clientOSFamily));
      end if;
      if clientLibDir is null then
        -- client location when syslib download is not defined in webutil.cfg
        -- will be to client JRE. Send nothing and client will handle
        WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_SYSLIB_DIR',
                                 ':' || serverHost || ':' || GET_APPLICATION_PROPERTY(CONFIG),
                                 true);
      else
        -- webutil.cfg contains a specific client directory for syslib download
        -- Replace $(SERVERHOST), if exists, with server host name
        clientLibDir := replace(clientLibDir, '$(SERVERHOST)', serverHost);

        -- The following line makes a few things happen on client including
        -- client directory creation, when clientLibDir is not null
        WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_SYSLIB_DIR',
                                 clientLibDir || ':' || serverHost || ':' || GET_APPLICATION_PROPERTY(CONFIG),
                                 true);
        clientLibDirOld := GetClientSetting('install.syslib.dir');

        if clientLibDirOld <> clientLibDir then
    	  SetClientSetting('install.syslib.dir', clientLibDir);
          REDOWNLOAD_SYSLIB := TRUE;
    	end if;
      end if;
      Webutil_Core.WEBUTIL_VERSION := getProperty(WUC_PACKAGE,'WUC_BEAN_VERSION');
      -- We want to write the connection record if it's required.
      -- Any call to ReadFromPropertyBundle or log should be preferably made after
      -- registering at least one bean. That is the reason why the following log
      -- comes after m_registeredPackages(packageID) := name_in('SYSTEM.TRIGGER_ITEM'); above
      if lower(ReadFromPropertyBundle('logging.connections')) = 'true' then 
        log('Connection from Form='||GET_APPLICATION_PROPERTY(CURRENT_FORM)||' Client O/S='||m_clientOS||' locale='||m_clientLangCode,false);
      end if;
    end if;
    if newPackage then  
            checkLibs(to_char(packageID));
    end if;

    if checkUserLibs then
      -- Call a dummy log to initialize m_loggingAllowed and m_loggingErrorsOnly
      log(null,false);
    end if;

    -- 5950737 - Introduce new configuration variable BlockAllowHeartBeat. 
    -- Valid values are true, yes and 1.
    -- If this is set then send a message to the client to behave accordingly.    
    blockAllowHeartBeat := lower(ReadFromPropertyBundle('BlockAllowHeartBeat'));
    if blockAllowHeartBeat = 'true' or blockAllowHeartBeat = 'yes' or blockAllowHeartBeat = '1' then 
      WebUtil_Core.setProperty(packageID,'WUC_BLOCK_ALLOW_HEART_BEAT','1',true);
    else
      WebUtil_Core.setProperty(packageID,'WUC_BLOCK_ALLOW_HEART_BEAT','0',true);
    end if;

    -- Send server logging options to client bean so that the bean does not have
    -- to send message to server unnecessarily.
    if m_loggingAllowed and m_loggingErrorsOnly then
      WebUtil_Core.setProperty(packageID,'WUC_SRV_LOGGING','1',true);
    elsif m_loggingAllowed then
      WebUtil_Core.setProperty(packageID,'WUC_SRV_LOGGING','2',true);
    else
      WebUtil_Core.setProperty(packageID,'WUC_SRV_LOGGING','0',true);
    end if;
      
    -- 2836929 - move the user library check after the first package is registered 
    -- so that a handler bean exists to do the download.     
    if checkUserLibs then 
      --Check for and download any user libs
      checkLibs('user');  
    end if;     
  end registerBean;  
      
  FUNCTION PopulatePropertyBundle(propertyKey in VARCHAR2) return VARCHAR2 is
    configFile   VARCHAR2(512 char);
    buffer       VARCHAR2(1000 char);
    result       VARCHAR2(1000 char);          
    propertyFile TEXT_IO.FILE_TYPE;
    pos          PLS_INTEGER;
    propIndex    PLS_INTEGER := 0;
  begin
    -- First of get the name of the cfg file 
    -- This could come in a global  or from the Environment
    default_value('[NOTSET]',WEBUTIL_CONFIG_GLOBAL);
    configFile := name_in(WEBUTIL_CONFIG_GLOBAL);
    if configFile = '[NOTSET]' then
      configFile := null; 
      -- Try the environment
      TOOL_ENV.GETVAR(WEBUTIL_CONFIG_ENV, configFile); 
      if configFile is null then 
        -- Finally try the Forms parameters
        configFile := name_in(WEBUTIL_CONFIG_PARAM);
        -- if that fails then we have to raise an error
        if configFile is null then 
          raise NO_DATA_FOUND;
        end if;    
      end if;
    end if;
    
    copy(configFile, WEBUTIL_CONFIG_GLOBAL);
      
    propertyFile := Text_IO.FOpen(configFile,'R');
    LOOP
      begin
        Text_IO.Get_Line(propertyFile,buffer);
      exception
        when NO_DATA_FOUND then EXIT;
      end;
        
      -- ignore lines which start with '#'
      if substr(buffer,1,1) <> '#' then 
        pos := instr(buffer,'=');
        -- only process lines with a name value pair
        if pos > 0 then 
          propIndex := propIndex + 1;
          m_propertyBundle(propIndex).propertyKey   := lower(ltrim(rtrim(substr(buffer,1,pos-1))));    
          m_propertyBundle(propIndex).propertyValue := ltrim(rtrim(replace(substr(buffer,pos+1),chr(13),'')));
          -- Check to see if this is the key we are looking for
          if  m_propertyBundle(propIndex).propertyKey = lower(propertyKey) then
            result := m_propertyBundle(propIndex).propertyValue;
          end if;
        end if;
      end if;
    end LOOP;
    Text_IO.FClose(propertyFile);
    return result;
  EXCEPTION
    when NO_DATA_FOUND then 
      if m_registeredPackages.FIRST is null then
        -- There is no bean registered yet. Throw error in English using alert
        ErrorAlert('WUC-005: No WebUtil Configuration File specified');
      else
        Webutil_Core.Error(Webutil_Core.WUC_PACKAGE,5,'WebUtil_Core.PopulatePropertyBundle');
      end if;
      m_config_error := true;
      return null;
    when others then 
      if SQLCODE = '-302000' then
        if m_registeredPackages.FIRST is null then
          -- There is no bean registered yet. Throw error in English using alert
          ErrorAlert('WUC-006: Unable to read WebUtil Configuration File');
        else
          Webutil_Core.Error(Webutil_Core.WUC_PACKAGE,6,'WebUtil_Core.PopulatePropertyBundle', configFile);
        end if;
        m_config_error := true;
        return null;
      else
        RAISE;
      end if;      

  end PopulatePropertyBundle;    
  
  PROCEDURE CheckLastError(bean ITEM) is
    errorStr VARCHAR2(200 char);
  begin
    errorStr := GET_CUSTOM_PROPERTY(bean,1,'WUC_CHECK_ERROR');
    m_lastError := DelimStr.getNumber(errorStr,1,true);
    -- do not rause WebUtil_Core.PROPERTY_ERROR so that user can call
    -- isError to check if there was any error in setProperty or getProperty
  end;
  
  PROCEDURE InitWebUtil is
    startPoint VARCHAR2(61 char) := NAME_IN('SYSTEM.CURSOR_FIELD');
    hDummy     ITEM              := FIND_ITEM(WEBUTIL_DUMMY_ITEM);
  BEGIN
    -- Set up the various package we know about.
    m_implClasses(WUC_PACKAGE) := 'common.VBeanCommon'; 
    m_implClasses(WUT_PACKAGE) := 'fileTransfer.FileTransfer'; 
    m_implClasses(WUF_PACKAGE) := 'file.FileFunctions'; 
    m_implClasses(WUI_PACKAGE) := 'clientInfo.GetClientInfo'; 
    m_implClasses(WUH_PACKAGE) := 'host.Host'; 
    m_implClasses(WUS_PACKAGE) := 'session.SessionFunctions'; 
    m_implClasses(WUB_PACKAGE) := 'browser.BrowserFunctions'; 
    m_implClasses(WUO_PACKAGE) := 'ole.OleFunctions'; 
    m_implClasses(WUU_PACKAGE) := '';      
    m_implClasses(WUL_PACKAGE) := 'cApi.CApiFunctions';                     
    
    -- Now check for the Webutil Object group which 
    -- contains the Beans etc.
          
    if id_null(m_errorAlert) then 
      -- The Webutil error alert is not around
      -- so the Code cannot operate 
      message('The WEBUTIL object group is not available in this Form.  WebUtil cannot work');
      pause;
    else
      -- Bug 2955789 - this navigation causes problems if they are in Enter-Query mode 
      -- Plus it's not really needed, except as a belt and braces kind of setup.
      -- So put a check to prevent this in E-Q mode and set a top level flag to bypass it 
      -- it all together which we can switch on or off if required as a furture W/A    
      if FLAG_EXPICIT_INSTANCIATE and name_in('SYSTEM.MODE') = 'NORMAL' then 
        if not ID_NULL(hDummy) then 
          -- they are using the standard Object Group
          GO_ITEM(hDummy);
          if GET_ITEM_PROPERTY(startPoint,BLOCK_NAME) = GET_ITEM_PROPERTY(hDummy,BLOCK_NAME) then 
            NEXT_BLOCK;
          else
            GO_ITEM(startPoint);
          end if;
          ShowBeans(false);        
        else
          -- do nothing assume that the programmer is doing their own thing.
          -- with regards to setting up the bean areas and making sure they are drawn
           null;      
        end if;
      end if;
    end if;
        
    -- Work out the server o/s informtion that we need
    if instr(upper(GET_APPLICATION_PROPERTY(OPERATING_SYSTEM)),'WIN') > 0 then 
      m_serverFileSep := '\';
    else
      m_serverFileSep := '/';
    end if;
  END InitWebUtil;  
  
  FUNCTION getHandlerBean(packageID in PLS_INTEGER) return VARCHAR2 is
    handler PLS_INTEGER;
  BEGIN
    if packageID = WUC_PACKAGE then 
      handler := m_registeredPackages.FIRST;
    else
      handler := packageID;
    end if;
    return m_registeredPackages(handler);
  END getHandlerBean;  
  
  FUNCTION DownLoadFromURLInt(sourceURL          in VARCHAR2, 
                              clientDestination  in VARCHAR2, 
                              specialDestination in PLS_INTEGER default 0,                             
                              fileSize           in PLS_INTEGER default 0, 
                              withProgress       in BOOLEAN default false,
                              progressTitle      in VARCHAR2 default null,
                              progressSubTitle   in VARCHAR2 default null,
                              progressMessage    in VARCHAR2 default null) return BOOLEAN is
    result       VARCHAR2(6) := 'FALSE';
    submitString VARCHAR2(4000 char);
    sep          VARCHAR2(1) := '|';
  BEGIN
    if sourceURL is null then
      raise URL_NULL;
    end if;
    if clientDestination is null then
      raise CLIENT_FILE_NULL;
    end if;

    if specialDestination is null or specialDestination < 0 or specialDestination > 2 then 
      submitString := '0'||sep;
    else
      submitString := to_char(specialDestination)||sep;
    end if;
    if fileSize is null then 
      submitString := submitString||'0'||sep;
    else
      submitString := submitString||to_char(fileSize)||sep;
    end if;
    if withProgress is null or not withProgress then 
      submitString := submitString||'N'||sep;
    else
      submitString := submitString||'Y'||sep;
    end if;    

    submitString := submitString||sourceURL
                    ||sep||clientDestination
                    ||sep||nvl(progressTitle,' ')
                    ||sep||nvl(progressSubTitle,' ')
                    ||sep||nvl(progressMessage,' ');                         
  WebUtil_Core.setProperty(WebUtil_Core.WUC_PACKAGE,'WUC_URL_DOWNLOAD',submitString,true);
  result := WebUtil_Core.getProperty(WebUtil_Core.WUC_PACKAGE,'WUC_URL_DOWNLOAD');
  return (result='TRUE');
  EXCEPTION  
    when CLIENT_FILE_NULL then
      WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE, 130, 'WEBUTIL_CORE.DownloadFromURLInt');
      return false;
    when URL_NULL then
      WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE,25, 'WEBUTIL_CORE.DownloadFromURLInt');
      return false;

    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUC_PACKAGE)
                              ||' bean not found. WEBUTIL_CORE.DownloadFromURLInt will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;
  END DownLoadFromURLInt;   
  
  PROCEDURE CheckLibs(packageID in VARCHAR2 ) is
    lib          PLS_INTEGER := 1;
    libSpec      VARCHAR2(200 char);
    libName      VARCHAR2(100 char);
    libSize      PLS_INTEGER;
    libVer       VARCHAR2(20 char);
    installedVer VARCHAR2(20 char);
    libProg      BOOLEAN := false;
    downloadURL  VARCHAR2(1000);
  BEGIN
    -- Read through the property bundle for 
    -- any libraries for this package
    LOOP
      libSpec := readFromPropertyBundle('install.syslib.'||to_char(m_clientOSFamily)||'.'||
             to_char(m_clientOSArch)||'.'||packageID||'.'||to_char(lib));
      if libSpec is null then
        libSpec := readFromPropertyBundle('install.syslib.'||to_char(m_clientOSFamily)||'.'||
             packageID||'.'||to_char(lib));
      end if;
      if libSpec is null then 
        exit;
      end if;
      lib := lib + 1;
      libName := Delimstr.getString(libSpec,1,true,'|');
      libSize := Delimstr.getNumber(libSpec,2,true,'|');
      libVer  := Delimstr.getString(libSpec,3,true,'|');
      libProg := (upper(Delimstr.getString(libSpec,4,true,'|'))='TRUE');

      -- OK we now have the library information
      -- let's check if it's installed
      installedVer := GetClientSetting('syslib.'||libname);
      if installedVer is null or installedVer <> libVer or REDOWNLOAD_SYSLIB then 
        -- need to download
        downloadURL := readFromPropertyBundle('install.syslib.location' || '.' || to_char(m_clientOSFamily) ||
                             '.' || to_char(m_clientOSArch));
        if downloadURL is null then
          downloadURL := readFromPropertyBundle('install.syslib.location' || '.' || to_char(m_clientOSFamily));
        end if;
        if downloadURL is null then
          downloadURL := readFromPropertyBundle('install.syslib.location');
        end if;
        if DownLoadFromURLInt(downloadURL||'/'||libName, 
                              libName,
                              1, -- syslib install download, special location
                              libSize,
                              libProg,
                              ReadTransFromMsgBundle('INST_PGRS_TITLE'),
                              ReadTransFromMsgBundle('INST_PGRS_SUBTITLE'),     
                              libName) then 
          SetClientSetting('syslib.'||libname,libVer);
        else
          log('Download of system library '||libName||' failed',true);
        end if;                          
      end if;
    END LOOP;
  END CheckLibs;
 
  FUNCTION getOSFamily(osName in VARCHAR2) return PLS_INTEGER is
    l_osName VARCHAR2(30) := lower(osName);
    result   PLS_INTEGER  := CLIENT_PLATFORM_UNKNOWN;
  BEGIN
    if m_clientOSFamily  is null then 
      if (instr(l_osName,'windows') > 0) then 
           result := CLIENT_PLATFORM_WIN32;
      elsif instr(l_osName,'mac') > 0 then 
          result := CLIENT_PLATFORM_MAC;      
      elsif instr(l_osName,'linux') > 0 then 
          result := CLIENT_PLATFORM_LINUX;      
      elsif instr(l_osName,'solaris') > 0 OR instr(l_osName, 'sunos') > 0 then 
          result := CLIENT_PLATFORM_SOLARIS;       
      elsif instr(l_osName,'hp-ux') > 0 then 
          result := CLIENT_PLATFORM_HP; 
      elsif instr(l_osName,'aix') > 0 then 
          result := CLIENT_PLATFORM_AIX;                                                       
      end if;            
      m_clientOSFamily := result;
    end if;
    return m_clientOSFamily;
  END getOSFamily;

  FUNCTION checkJava return BOOLEAN is
    classpath   VARCHAR2(4096 char);
    jarpos      PLS_INTEGER := 0;
    iStart      PLS_INTEGER := 0;
    iEnd        PLS_INTEGER := 0;      
    pathSep     VARCHAR2(1 CHAR);
    webUtilPath VARCHAR2(1024);
    jFile       ORA_JAVA.JOBJECT;
  BEGIN
    if m_javaOK is null then       
      m_javaOK := false;
      classpath := JAVA_SYSTEM.getProperty('java.class.path');
      pathSep   := JAVA_SYSTEM.getProperty('path.separator');      
      if pathSep = ';' then /* win32 */ 
        classpath := lower(classpath);
      end if;

      jarpos := instr(classpath,'frmwebutil.jar');
   
      if jarpos = 0 then 
        WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE,134,'WEBUTIL_CORE.checkJava','frmwebutil.jar');
      else
        -- So we know that frmwebutil.jar is mentioned in the classpath let's check 
        -- to see if it actually is where the admin has said it is - this will 
        -- also check that Java can run at all. 
        iStart := instr(substr(classpath,1,jarPos),pathSep,-1,1);
        iEnd   := instr(classpath,pathSep,jarPos,1);          
        webUtilPath := substr(classpath,iStart+1,(iEnd-iStart)-1);
        jFile := JAVA_FILE.New(webUtilPath);
        if JAVA_FILE.Exists_(jFile) then
          m_javaOK := true;
        else
          -- frmwebutil.jar in classpath, but not physically found
          WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE,135,'WEBUTIL_CORE.checkJava',webUtilPath);
        end if;
      end if;
    end if;  
    return m_javaOK;
  EXCEPTION
    when ORA_JAVA.JAVA_ERROR then 
      WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE,122,'WEBUTIL_CORE.checkJava');
    when ORA_JAVA.EXCEPTION_THROWN then 
      WebUtil_Core.Error(Webutil_Core.WUC_PACKAGE,122,'WEBUTIL_CORE.checkJava');
  END checkJava;  
  
  PROCEDURE Init is
  begin 
    -- we don't need to do anything here - entering the package is enough to set it up.      
    null;
  end;      

BEGIN
  -- Initialise the Utility
  InitWebUtil;  
END WEBUTIL_CORE;


PACKAGE WEBUTIL_C_API IS
/*********************************************************************************\
 * WEBUTIL_C_API
 *   This Package provides a way of calling C functions in a shared library on the
 *   client PC. Currently only win32 is supported.
 *   The oracle.forms.webutil.cApi.CApiFunctions bean is needed in your Form to 
 *   use these functions
 *********************************************************************************
 * Version 1.0.5
 *********************************************************************************
 * Change History
 *   1.0.1 RVSUILIC 14/FEB/2003 - Creation 
 *   1.0.2 DRMILLS  27/FEB/2003 - Reset LONG to the same value as INT which is fine
 *                                for Windows & removed Tester proc
 *   1.0.3 DRMILLS  01/MAR/2003 - Re-worked the PL/SQL API
 *   1.0.4 DRMILLS  13/MAY/2003 - Added call to WebUtil_Core.Init
 *   1.0.5 RVSUILIC 21/MAY/2003 - Cleaned up some comments and formatting.
 *
\*********************************************************************************/


  /**
   *  Constants to represent PL/SQL IN, OUT and INOUT parameter qualifiers
   */
  PARAM_IN    CONSTANT PLS_INTEGER := 50;
  PARAM_INOUT CONSTANT PLS_INTEGER := 51;
  PARAM_OUT   CONSTANT PLS_INTEGER := 52;
  

  /**
   *  Constants to represent C atomic datatypes and pointers to atomic datatypes
   *  Note that to use OUT and INOUT qualifiers the C function in the DLL *must*
   *  use a pointer type to be able to pass information back.
   *
   *  The comments on the right indicate which types can be used for parameters
   *  and which for function return types.
   *
   *  c_ptr is used as a generic pointer. The onlys supported use for this is to
   *  save the pointer value from C into a PL/SQL variable, so that it may be 
   *  passed back later to C. No operations on the pointer are supported in PL/SQL.
   */
  c_void          CONSTANT PLS_INTEGER := 30;            /* - not used -   */
  c_char          CONSTANT PLS_INTEGER := 31;            /* param & return */
  c_short         CONSTANT PLS_INTEGER := 32;            /* param & return */
  c_int           CONSTANT PLS_INTEGER := 33;            /* param & return */
  c_long          CONSTANT PLS_INTEGER := 33;            /* param & return *//*DRM - same as INT */
  c_float         CONSTANT PLS_INTEGER := 35;            /* param & return */
  c_double        CONSTANT PLS_INTEGER := 36;            /* param & return */

  c_ptr           CONSTANT PLS_INTEGER := 64 + c_void;   /* param & return */
  c_char_ptr      CONSTANT PLS_INTEGER := 64 + c_char;   /* param          */
  c_short_ptr     CONSTANT PLS_INTEGER := 64 + c_short;  /* param          */
  c_int_ptr       CONSTANT PLS_INTEGER := 64 + c_int;    /* param          */
  c_long_ptr      CONSTANT PLS_INTEGER := 64 + c_long;   /* param          */
  c_float_ptr     CONSTANT PLS_INTEGER := 64 + c_float;  /* param          */
  c_double_ptr    CONSTANT PLS_INTEGER := 64 + c_double; /* param          */


  /**
   *  Abstracted types to be used for pointers and handles. The forms programmer
   *  should not attempt any manipulation on these types, but merely obtain them as
   *  a result of functions below, and pass them back in to other functions below.
   */
    SUBTYPE handleType   IS NUMBER;
    TYPE Pointer         IS RECORD (hnd handleType);   /* C pointer             */
    TYPE FunctionHandle  IS RECORD (hnd handleType);   /* function handle       */
    TYPE ParameterHandle IS RECORD (hnd handleType);   /* parameter handle      */
    TYPE ParameterList   IS RECORD (hnd handleType);   /* parameter list handle */


  /**
   *  IS_SUPPORTED - Check if the client is on a supported hardware platform.
   */
    FUNCTION IS_SUPPORTED RETURN BOOLEAN;

  /**
   *  CREATE_PARAMETER_LIST - Create an empty Parameter list
   */
    FUNCTION CREATE_PARAMETER_LIST RETURN ParameterList;

  /**
   *  ADD_PARAMETER - Add parameter to a parameter list, and bind its value.
   *  Use first one if you don't want to pass any value to the OUT only param.
   *  For OUT only strings, even though we can use prototype-1, we should still
   *  prefer to use prototype-3 so as to allow the jvm to allocate memory
   *  for the string judiciously. Otherwise it will allocate max (32768).
   */

  -- 1 --
  FUNCTION ADD_PARAMETER (paramList     IN ParameterList,           /* numeric */
                          parameterType IN PLS_INTEGER, 
                          inOut         IN PLS_INTEGER := PARAM_OUT) RETURN ParameterHandle;
  -- 2 --
  FUNCTION ADD_PARAMETER (paramList     IN ParameterList,           /* numeric */
                          parameterType IN PLS_INTEGER, 
                          inOut         IN PLS_INTEGER, 
                          num           IN NUMBER) RETURN ParameterHandle;
  -- 3 --
  FUNCTION ADD_PARAMETER (paramList     IN ParameterList,           /* string  */
                          parameterType IN PLS_INTEGER, 
                          inOut         IN PLS_INTEGER, 
                          str           IN VARCHAR2, 
                          strmaxlen     IN PLS_INTEGER) RETURN ParameterHandle;
  -- 4 --
  FUNCTION ADD_PARAMETER (paramList     IN ParameterList,           /* pointer */
                          parameterType IN PLS_INTEGER, 
                          inOut         IN PLS_INTEGER, 
                          ptr           IN Pointer) RETURN ParameterHandle;
                   
  /**
   *  REBIND_PARAMETER - Rebind a value to an existing parameter in a parameter list.
   *  Note that the C datatype should NOT change.
   *  use prototype-1 if OUT only parameter.
   */
  -- 1 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList,       /* numeric */
                              param     IN ParameterHandle);
  -- 2 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList,       /* numeric */
                              param     IN ParameterHandle, 
                              num       IN NUMBER);
  -- 3 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList,       /* string  */
                              param     IN ParameterHandle, 
                              str       IN VARCHAR2, 
                              strmaxlen IN PLS_INTEGER);
  -- 4 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList,       /* pointer */
                              param     IN ParameterHandle, 
                              ptr       IN Pointer);

  /**
   *  GET_PARAMETER_<type> - Fetch the value of the parameter (after calling the 
   *  C function). VARCHAR2 parameters are restricted to 32k length.
   */
  FUNCTION GET_PARAMETER_NUMBER (paramList IN ParameterList, 
                                 param     IN ParameterHandle) RETURN NUMBER;
  FUNCTION GET_PARAMETER_STRING (paramList IN ParameterList, 
                                 param     IN ParameterHandle) RETURN VARCHAR2;
  FUNCTION GET_PARAMETER_PTR    (paramList IN ParameterList, 
                                 param     IN ParameterHandle) RETURN Pointer;

  /**
   *  DESTROY_PARAMETERLIST - Destroy the parameter list, including all parameters
   *  on it.
   */
  PROCEDURE DESTROY_PARAMETER_LIST (paramList IN ParameterList);

  /**
   *  REGISTER_FUNCTION - Register the C function and create a handle to it for future 
   *  use. If a function will be called once only, rather pass the libName and funcName
   *  through the matching INVOKE_XXX function for better performance.
   */
  FUNCTION REGISTER_FUNCTION (libName  IN VARCHAR2, 
                              funcName IN VARCHAR2) RETURN FunctionHandle;

  /**
   *  DEREGISTER_FUNCTION - Deregister the function.
   */
  PROCEDURE DEREGISTER_FUNCTION (funcHandle IN FunctionHandle);

  /**
   * INVOKE_<returntype> - Invoke the C function in the DLL
   * <returntype> matches the C return type, or is left out for
   * void functions.
   * Each function comes in two flavours:
   *  with funchandle:
   *    Uses funchandle which has previously been created by REGISTER_FUNCTION.
   *    This is good to use in an iterative situation to avoid the overhead of
   *    REGISTER/DEREGISTER each time.
   *  with libName & funcName:
   *    Good for one-off use. If will implicitly do a REGISTER/DEREGISTER of the
   *    function. It also uses less network round trips.
   */
  FUNCTION INVOKE_SHORT   (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_SHORT   (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_INT     (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_INT     (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_LONG    (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_LONG    (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN PLS_INTEGER;
  FUNCTION INVOKE_CHAR    (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN CHAR;
  FUNCTION INVOKE_CHAR    (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN CHAR;
  FUNCTION INVOKE_FLOAT   (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN NUMBER;
  FUNCTION INVOKE_FLOAT   (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN NUMBER;
  FUNCTION INVOKE_DOUBLE  (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN NUMBER;
  FUNCTION INVOKE_DOUBLE  (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN NUMBER;
  FUNCTION INVOKE_STRING  (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN VARCHAR2;
  FUNCTION INVOKE_STRING  (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN VARCHAR2;
  FUNCTION INVOKE_PTR     (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList) RETURN Pointer;
  FUNCTION INVOKE_PTR     (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList) RETURN Pointer;
  PROCEDURE INVOKE        (funcHandle IN FunctionHandle, 
                           paramList  IN ParameterList);
  PROCEDURE INVOKE        (libName    IN VARCHAR2, 
                           funcName   IN VARCHAR2, 
                           paramList  IN ParameterList);

  /**
   *  FUNCTION_COUNT - Indicates how many function handles are created but
   *  not yet destroyed. If this value is >0 when the form exits, it indicates
   *  that the forms programmer has not called DEREGISTER_FUNCTION for each
   *  REGISTER_FUNCTION, and is therefore causing a memory leak.
   *  Available to the forms programmer for testing/debugging.
   */
  FUNCTION FUNCTION_COUNT RETURN PLS_INTEGER;

  /**
   *  PARAMETER_LIST_COUNT - Indicates how many parameter lists are created but
   *  not yet destroyed. If this value is >0 when the form exits, it indicates
   *  that the forms programmer has not called DESTROY_PARAMETERLIST for each
   *  CREATE_PARAMETERLIST, and is therefore causing a memory leak.
   *  Available to the forms programmer for testing/debugging.
   */
  FUNCTION PARAMETER_LIST_COUNT RETURN PLS_INTEGER;


    /**
     *  ID_NULL - Check whether a supplied handle has a NULL value.
     */
  FUNCTION ID_NULL(handle IN Pointer)        RETURN BOOLEAN;
  FUNCTION ID_NULL(handle IN FunctionHandle) RETURN BOOLEAN;
  FUNCTION ID_NULL(handle IN ParameterHandle)RETURN BOOLEAN;
  FUNCTION ID_NULL(handle IN ParameterList)  RETURN BOOLEAN;

END WEBUTIL_C_API;


PACKAGE BODY WEBUTIL_C_API IS

  INVALID_PARAM_EXCEPTION EXCEPTION;

  m_funcHandleCount PLS_INTEGER := 0;
  m_paramListCount PLS_INTEGER := 0;

  --
  -- PRIVATE FUNCTIONS
  --


  -- Validate if the parameter type supplied is supported
  FUNCTION ValidParameterType (paramType IN PLS_INTEGER) RETURN BOOLEAN IS
  BEGIN
    IF paramType IN (c_char,
                     c_short,
                     c_int,
                     c_long,
                     c_float,
                     c_double,
                     c_ptr,
                     c_char_ptr,
                     c_short_ptr,
                     c_int_ptr,
                     c_long_ptr,
                     c_float_ptr,
                     c_double_ptr
                     ) THEN
      RETURN TRUE;
    END IF;
    
    RETURN FALSE;
  END ValidParameterType;

  -- Validate the INOUT specifier
  FUNCTION ValidInOut (inOut IN PLS_INTEGER) RETURN BOOLEAN IS
  BEGIN
    IF inOut IN (param_IN, param_INOUT, param_OUT) THEN
      RETURN TRUE;
    END IF;
    
    RETURN FALSE;
  END ValidInOut;


  -- Interface between INVOKE_XXX and the bean
  FUNCTION INVOKE_WU (funcHandle IN FunctionHandle, paramList ParameterList, retType IN PLS_INTEGER) RETURN VARCHAR2 IS
    strResult VARCHAR2(32767);
  BEGIN
    IF id_null(paramList) THEN
      WebUtil_Core.setProperty (WebUtil_Core.WUL_PACKAGE, 'WUL_INVOKE_SPEC', TO_CHAR(funcHandle.hnd) || '|' 
                                                                             || '(null)'                || '|' 
                                                                             || TO_CHAR(retType),false);
    ELSE                                                                             
      WebUtil_Core.setProperty (WebUtil_Core.WUL_PACKAGE, 'WUL_INVOKE_SPEC', TO_CHAR(funcHandle.hnd) || '|' 
                                                                             || TO_CHAR(paramList.hnd)  || '|' 
                                                                             || TO_CHAR(retType), false);
    END IF;                                                                             
      strResult := WebUtil_Core.getProperty (WebUtil_Core.WUL_PACKAGE, 'WUL_INVOKE');
      RETURN strResult;

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.INVOKE_WU will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  

  END INVOKE_WU;


  FUNCTION INVOKE_WU (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList, retType IN PLS_INTEGER) RETURN VARCHAR2 IS
    strResult VARCHAR2(32767);
  BEGIN
    IF id_null(paramList) THEN
      WebUtil_Core.setProperty (WebUtil_Core.WUL_PACKAGE, 'WUL_INVOKEONCE_SPEC', libName                || '|' 
                                                                                 || funcName               || '|' 
                                                                                 || '(null)'               || '|' 
                                                                                 || TO_CHAR(retType),false);
    ELSE                                                                                 
      WebUtil_Core.setProperty (WebUtil_Core.WUL_PACKAGE, 'WUL_INVOKEONCE_SPEC', libName                || '|' 
                                                                                 || funcName               || '|' 
                                                                                 || TO_CHAR(paramList.hnd) || '|' 
                                                                                 || TO_CHAR(retType),false);
    END IF;                                                                                 
    strResult := WebUtil_Core.getProperty(WebUtil_Core.WUL_PACKAGE,'WUL_INVOKE');
    RETURN TO_NUMBER (strResult);

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.INVOKE_WU will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END INVOKE_WU;


  -- Template functions for INVOKE_SHORT/INT/LONG
  FUNCTION INVOKE_INTEGRAL (funcHandle IN FunctionHandle, paramList ParameterList, retType IN PLS_INTEGER) RETURN PLS_INTEGER IS
  BEGIN
    RETURN TO_NUMBER (INVOKE_WU (funcHandle, paramList, retType));
  END INVOKE_INTEGRAL;


  FUNCTION INVOKE_INTEGRAL (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList, retType IN PLS_INTEGER) RETURN PLS_INTEGER IS
  BEGIN
    RETURN TO_NUMBER (INVOKE_WU (libName, funcName, paramList, retType));
  END INVOKE_INTEGRAL;


  -- Template functions for INVOKE_FLOAT/DOUBLE
  FUNCTION INVOKE_REAL (funcHandle IN FunctionHandle, paramList ParameterList, retType IN PLS_INTEGER) RETURN NUMBER IS
  BEGIN
    RETURN TO_NUMBER (INVOKE_WU (funcHandle, paramList, retType));
  END INVOKE_REAL;


  FUNCTION INVOKE_REAL (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList, retType IN PLS_INTEGER) RETURN NUMBER IS
  BEGIN
    RETURN TO_NUMBER (INVOKE_WU (libName, funcName, paramList, retType));
  END INVOKE_REAL;


  FUNCTION ADD_PARAMETER_WU (paramList IN ParameterList, parameterType IN PLS_INTEGER, 
                             inOut IN PLS_INTEGER, str IN VARCHAR2, strmaxlen IN PLS_INTEGER) RETURN ParameterHandle IS
    paramHnd ParameterHandle;
  BEGIN
    IF str IS NULL THEN
      WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES', 'B|'                   -- indicate Bind
                                                                                 || TO_CHAR(paramList.hnd) || '|'
                                                                                 || TO_CHAR(parameterType) || '|'
                                                                                 || TO_CHAR(inOut)         || '|'
                                                                                 || TO_CHAR(strmaxlen)     || '|'
                                                                                 || '(null)',false);
      ELSE                                                                               
        WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES', 'B|'                   -- indicate Bind
                                                                                   || TO_CHAR(paramList.hnd) || '|'
                                                                                   || TO_CHAR(parameterType) || '|'
                                                                                   || TO_CHAR(inOut)         || '|'
                                                                                   || TO_CHAR(strmaxlen)     || '|'
                                                                                   || str,false);
      END IF;                                                                               

      paramHnd.hnd := TO_NUMBER(WebUtil_Core.GetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_ADD_PARAMETER'));
      RETURN paramHnd;

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.ADD_PARAMETER_WU will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END ADD_PARAMETER_WU;



  --
  -- PUBLIC FUNCTIONS
  --

  FUNCTION IS_SUPPORTED RETURN BOOLEAN IS
    ClientOS PLS_INTEGER;
  BEGIN
    ClientOS := WebUtil_Core.GetClientOSFamily;
    if ClientOS = WebUtil_Core.CLIENT_PLATFORM_WIN32 then
    /*if ClientOS in (WebUtil_Core.CLIENT_PLATFORM_WIN32, 
                     WebUtil_Core.CLIENT_PLATFORM_SOLARIS) then */
      return true;
    end if;

    return false;

  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.IS_SUPPORTED will not work');
      RAISE TOOL_ERR.TOOL_ERROR;                                 
      return null;
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE;
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
    when TOOL_ERR.TOOL_ERROR then 
      RAISE;
  END IS_SUPPORTED;    


  FUNCTION CREATE_PARAMETER_LIST RETURN ParameterList IS
    paramListHandle ParameterList;
    strHnd VARCHAR2(8);
  BEGIN
    strHnd := WebUtil_Core.getProperty(WebUtil_Core.WUL_PACKAGE,'WUL_CREATE_PARAMLIST');

    if (strHnd is null) or (strHnd = '') then
      raise TOOL_ERR.TOOL_ERROR;
    end if;
    
    paramListHandle.hnd := TO_NUMBER (strHnd);
    m_paramListCount := m_paramListCount + 1;
    
    RETURN paramListHandle;

EXCEPTION  
  when WebUtil_Core.BEAN_NOT_REGISTERED then 
    WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                            ||' bean not found. WEBUTIL_C_API.CREATE_PARAMETER_LIST will not work');
    RAISE FORM_TRIGGER_FAILURE;  
  when WebUtil_Core.PROPERTY_ERROR then 
    RAISE FORM_TRIGGER_FAILURE;  
  when VALUE_ERROR then
    RAISE TOOL_ERR.TOOL_ERROR; 
END CREATE_PARAMETER_LIST;


/*
** For Out only parameters, we don't need to pass any value. If we intend to pass
** a maximum length value for strings, we can call 3rd prototype by passing null for
** the string value and a desired length.
**/

  -- 1 --
  FUNCTION ADD_PARAMETER (paramList IN ParameterList, parameterType IN PLS_INTEGER, 
                         inOut IN PLS_INTEGER := PARAM_OUT) RETURN ParameterHandle IS
    paramHnd ParameterHandle;
  BEGIN
    if inOut = PARAM_OUT then
      WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES',
                               'B|'                   -- indicate Bind
                                || TO_CHAR(paramList.hnd) || '|'
                                || TO_CHAR(parameterType) || '|'
                                || TO_CHAR(inOut),
                               false);
      paramHnd.hnd := TO_NUMBER(WebUtil_Core.GetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_ADD_PARAMETER'));
      RETURN paramHnd;
    else
      raise INVALID_PARAM_EXCEPTION;
    end if;
  exception
    when INVALID_PARAM_EXCEPTION then
      WebUtil_Core.Error(Webutil_Core.WUL_PACKAGE,923, 'WEBUTIL_C_API.ADD_PARAMETER');
    RAISE FORM_TRIGGER_FAILURE;  
  END ADD_PARAMETER;

  -- 2 --
  FUNCTION ADD_PARAMETER (paramList IN ParameterList, parameterType IN PLS_INTEGER, 
                          inOut IN PLS_INTEGER, num IN NUMBER) RETURN ParameterHandle IS
  BEGIN
    if NOT inOut = PARAM_OUT AND num is null then
      raise INVALID_PARAM_EXCEPTION;
    elsif inOut = PARAM_OUT then
      return ADD_PARAMETER(paramList, parameterType); -- call prototype-1
    end if;

    RETURN ADD_PARAMETER_WU (paramList, parameterType, inOut, TO_CHAR (num), 0);
  exception
    when INVALID_PARAM_EXCEPTION then
      WebUtil_Core.Error(Webutil_Core.WUL_PACKAGE,923, 'WEBUTIL_C_API.ADD_PARAMETER');
      RAISE FORM_TRIGGER_FAILURE;  
  END ADD_PARAMETER;


  -- 3 --
  FUNCTION ADD_PARAMETER (paramList IN ParameterList, parameterType IN PLS_INTEGER, 
                          inOut IN PLS_INTEGER,
                          str IN VARCHAR2, -- can be null even for IN or INOUT 
                          strmaxlen IN PLS_INTEGER) RETURN ParameterHandle IS
  BEGIN
    if inOut = PARAM_OUT AND strmaxlen is null then
      return ADD_PARAMETER(paramList, parameterType); -- call prototype-1
    elsif strmaxlen is null then
       raise INVALID_PARAM_EXCEPTION;
    end if;

    IF strmaxlen < 1 OR strmaxlen > 32768 THEN
      RAISE TOOL_ERR.TOOL_ERROR;
    END IF;

    RETURN ADD_PARAMETER_WU (paramList, parameterType, inOut, str, strmaxlen);

  exception
    when INVALID_PARAM_EXCEPTION then
      WebUtil_Core.Error(Webutil_Core.WUL_PACKAGE,919, 'WEBUTIL_C_API.ADD_PARAMETER');
    RAISE FORM_TRIGGER_FAILURE;  
  END ADD_PARAMETER;

  -- 4 --
  FUNCTION ADD_PARAMETER (paramList IN ParameterList, parameterType IN PLS_INTEGER, 
                          inOut IN PLS_INTEGER, ptr IN Pointer) RETURN ParameterHandle IS
  BEGIN
    if NOT inOut = PARAM_OUT AND ID_NULL(ptr) then
        raise INVALID_PARAM_EXCEPTION;
    elsif inOut = PARAM_OUT then
        return ADD_PARAMETER(paramList, parameterType); -- call prototype-1
    end if;

    RETURN ADD_PARAMETER_WU (paramList, parameterType, inOut, TO_CHAR (ptr.hnd), 0);
  exception
    when INVALID_PARAM_EXCEPTION then
      WebUtil_Core.Error(Webutil_Core.WUL_PACKAGE,923, 'WEBUTIL_C_API.ADD_PARAMETER');
      RAISE FORM_TRIGGER_FAILURE;  
  END ADD_PARAMETER;


  -- 1 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList, param IN ParameterHandle) IS
  BEGIN
      WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES',
                               'R|'                   -- indicate Rebind
                                || TO_CHAR(paramList.hnd) || '|'
                                || TO_CHAR(param.hnd),
                               false);
    -- No need to WebUtil_Core.GetProperty anything to do the actual rebind; it is implicitly done
    -- by WebUtil_Core.SetProperty of WUL_PARAM_PROPERTIES to 'R|....' to save a network trip
    -- If parameter is not OUT only, then client java will raise error for not passing value
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REBIND_PARAMETER will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END REBIND_PARAMETER;

  -- 2 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList, param IN ParameterHandle, 
                              num IN NUMBER) IS
  BEGIN
    WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES', 'R|'                   -- indicate Rebind
                                                                           || TO_CHAR(paramList.hnd) || '|'
                                                                           || TO_CHAR(param.hnd)     || '|'
                                                                           || '0'                    || '|'
                                                                           || TO_CHAR(num), false);
    -- No need to WebUtil_Core.GetProperty anything to do the actual rebind; it is implicitly done
    -- by WebUtil_Core.SetProperty of WUL_PARAM_PROPERTIES to 'R|....' to save a network trip

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REBIND_PARAMETER will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END REBIND_PARAMETER;

  -- 3 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList, param IN ParameterHandle, 
                              str IN VARCHAR2, strmaxlen IN PLS_INTEGER) IS
  BEGIN
    IF strmaxlen < 1 OR LENGTH (str) > strmaxlen THEN
        RAISE TOOL_ERR.TOOL_ERROR;
    END IF;
    WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES', 'R|'                   -- indicate Rebind
                                                                              || TO_CHAR(paramList.hnd) || '|'
                                                                              || TO_CHAR(param.hnd)     || '|'
                                                                              || TO_CHAR(strmaxlen)     || '|'
                                                                              || str, false);
    -- No need to WebUtil_Core.GetProperty anything to do the actual rebind; it is implicitly done
    -- by WebUtil_Core.SetProperty of WUL_PARAM_PROPERTIES to 'R|....' to save a network trip

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REBIND_PARAMETER will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END REBIND_PARAMETER;

  -- 4 --
  PROCEDURE REBIND_PARAMETER (paramList IN ParameterList, param IN ParameterHandle, 
                              ptr IN Pointer) IS
  BEGIN
    REBIND_PARAMETER(paramList, param, ptr.hnd);
  END REBIND_PARAMETER;


  FUNCTION GET_PARAMETER_STRING (paramList IN ParameterList, param IN ParameterHandle) RETURN VARCHAR2 IS
    paramVal VARCHAR2(32767);
  BEGIN
    -- Note: It is up to the Java interface to guarantee sending back a string that is shorter than strmaxlen
    WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_PROPERTIES', 'F|'                   -- indicate Fetch
                                                                              || TO_CHAR(paramList.hnd) || '|'
                                                                              || TO_CHAR(param.hnd),false);
    paramVal := WebUtil_Core.GetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_PARAM_VALUE');
    
    RETURN paramVal;

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REBIND_PARAMETER will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END GET_PARAMETER_STRING;


  FUNCTION GET_PARAMETER_NUMBER (paramList IN ParameterList, param IN ParameterHandle) RETURN NUMBER IS
  BEGIN
    RETURN TO_NUMBER (GET_PARAMETER_STRING (paramList, param));

  EXCEPTION
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
  END GET_PARAMETER_NUMBER;


  FUNCTION GET_PARAMETER_PTR (paramList IN ParameterList, param IN ParameterHandle) RETURN Pointer IS
    ptr Pointer;
  BEGIN
    ptr.hnd := TO_NUMBER (GET_PARAMETER_STRING (paramList, param));

    RETURN ptr;

  EXCEPTION
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
  END GET_PARAMETER_PTR;


  PROCEDURE DESTROY_PARAMETER_LIST (paramList IN ParameterList) IS
  BEGIN
    WebUtil_Core.SetProperty(WebUtil_Core.WUL_PACKAGE,'WUL_DESTROY_PARAMLIST', TO_CHAR(paramList.hnd),false);
    m_paramListCount := m_paramListCount - 1;

  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.DESTROY_PARAMETER_LIST will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END DESTROY_PARAMETER_LIST;


  FUNCTION REGISTER_FUNCTION (libName IN VARCHAR2, funcName IN VARCHAR2) 
                              RETURN FunctionHandle IS
    strHnd  VARCHAR2(8);                            
    funcHnd FunctionHandle;
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUL_PACKAGE,'WUL_FUNCTION_SPEC', libName || '|' || funcName);
    strHnd := WebUtil_Core.getProperty(WebUtil_Core.WUL_PACKAGE,'WUL_REGISTER_FUNCTION');
    funcHnd.hnd := TO_NUMBER (strHnd);
    if NOT ID_NULL(funcHnd) then
      m_funcHandleCount := m_funcHandleCount + 1;
    end if;

    RETURN funcHnd;
    
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.REGISTER_FUNCTION will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
    when VALUE_ERROR then
        RAISE TOOL_ERR.TOOL_ERROR; 
  END REGISTER_FUNCTION;


  PROCEDURE DEREGISTER_FUNCTION (funcHandle IN FunctionHandle) IS
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUL_PACKAGE,'WUL_DEREGISTER_FUNCTION', TO_CHAR(funcHandle.hnd),false);
    m_funcHandleCount := m_funcHandleCount - 1;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUL_PACKAGE)
                              ||' bean not found. WEBUTIL_C_API.DEREGISTER_FUNCTION will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END DEREGISTER_FUNCTION;


  FUNCTION INVOKE_SHORT (funcHandle IN FunctionHandle, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (funcHandle, paramList, c_short);
  END INVOKE_SHORT;


  FUNCTION INVOKE_SHORT (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (libName, funcName, paramList, c_short);
  END INVOKE_SHORT;


  FUNCTION INVOKE_INT (funcHandle IN FunctionHandle, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (funcHandle, paramList, c_int);
  END INVOKE_INT;


  FUNCTION INVOKE_INT (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (libName, funcName, paramList, c_int);
  END INVOKE_INT;


  FUNCTION INVOKE_LONG (funcHandle IN FunctionHandle, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (funcHandle, paramList, c_long);
  END INVOKE_LONG;


  FUNCTION INVOKE_LONG (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN PLS_INTEGER IS
  BEGIN
    RETURN INVOKE_INTEGRAL (libName, funcName, paramList, c_long);
  END INVOKE_LONG;


  FUNCTION INVOKE_FLOAT (funcHandle IN FunctionHandle, paramList ParameterList) RETURN NUMBER IS
  BEGIN
    RETURN INVOKE_REAL (funcHandle, paramList, c_float);
  END INVOKE_FLOAT;


  FUNCTION INVOKE_FLOAT (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN NUMBER IS
  BEGIN
    RETURN INVOKE_REAL (libName, funcName, paramList, c_float);
  END INVOKE_FLOAT;


  FUNCTION INVOKE_DOUBLE (funcHandle IN FunctionHandle, paramList ParameterList) RETURN NUMBER IS
  BEGIN
    RETURN INVOKE_REAL (funcHandle, paramList, c_double);
  END INVOKE_DOUBLE;


  FUNCTION INVOKE_DOUBLE (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN NUMBER IS
  BEGIN
    RETURN INVOKE_REAL (libName, funcName, paramList, c_double);
  END INVOKE_DOUBLE;


  FUNCTION INVOKE_CHAR (funcHandle IN FunctionHandle, paramList ParameterList) RETURN CHAR IS
    charResult CHAR;
  BEGIN
    charResult := INVOKE_WU (funcHandle, paramList, c_char);
    RETURN charResult;
  END INVOKE_CHAR;


  FUNCTION INVOKE_CHAR (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN CHAR IS
    charResult  CHAR;
  BEGIN
    charResult := INVOKE_WU (libName, funcName, paramList, c_char);

    RETURN charResult;
  END INVOKE_CHAR;


  FUNCTION INVOKE_STRING (funcHandle IN FunctionHandle, paramList ParameterList) RETURN VARCHAR2 IS
    strResult  VARCHAR2(32767);
  BEGIN
    strResult := INVOKE_WU (funcHandle, paramList, c_char_ptr); 

    return strResult;
  END INVOKE_STRING;


  FUNCTION INVOKE_STRING (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN VARCHAR2 IS
    strResult  VARCHAR2(32767);
  BEGIN
    strResult := INVOKE_WU (libName, funcName, paramList, c_char_ptr);

    RETURN strResult;
  END INVOKE_STRING;


  FUNCTION INVOKE_PTR (funcHandle IN FunctionHandle, paramList ParameterList) RETURN Pointer IS
    strResult VARCHAR2(40);
    ptrResult Pointer;
  BEGIN
    strResult := INVOKE_WU (funcHandle, paramList, c_ptr);
    ptrResult.hnd := TO_NUMBER (strResult);

    RETURN ptrResult;

  EXCEPTION
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
  END INVOKE_PTR;


  FUNCTION INVOKE_PTR (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) RETURN Pointer IS
    strResult VARCHAR2(40);
    ptrResult Pointer;
  BEGIN
    strResult := INVOKE_WU (libName, funcName, paramList, c_ptr);
    ptrResult.hnd := TO_NUMBER (strResult);

    RETURN ptrResult;

  EXCEPTION
    when VALUE_ERROR then
      RAISE TOOL_ERR.TOOL_ERROR; 
  END INVOKE_PTR;


  PROCEDURE INVOKE (funcHandle IN FunctionHandle, paramList ParameterList) IS
    dummy VARCHAR2(20);
  BEGIN
    dummy := INVOKE_WU (funcHandle, paramList, c_void);
  END INVOKE;


  PROCEDURE INVOKE (libName IN VARCHAR2, funcName IN VARCHAR2, paramList ParameterList) IS
    dummy VARCHAR2(20);
  BEGIN
    dummy := INVOKE_WU (libName, funcName, paramList, c_void);
  END INVOKE;


  FUNCTION FUNCTION_COUNT RETURN PLS_INTEGER IS
  BEGIN
    RETURN m_funcHandleCount;
  END FUNCTION_COUNT;


  FUNCTION PARAMETER_LIST_COUNT RETURN PLS_INTEGER IS
  BEGIN
    RETURN m_paramListCount;
  END PARAMETER_LIST_COUNT;


  FUNCTION ID_NULL(handle IN Pointer)        RETURN BOOLEAN is
  BEGIN
    if handle.hnd is null then 
      return TRUE;
    else
      return FALSE;
    end if;
  END ID_NULL;


  FUNCTION ID_NULL(handle IN FunctionHandle) RETURN BOOLEAN is
  BEGIN
    if handle.hnd is null then 
      return TRUE;
    else
      return FALSE;
    end if;
  END ID_NULL;


  FUNCTION ID_NULL(handle IN ParameterHandle) RETURN BOOLEAN is
  BEGIN
    if handle.hnd is null then 
      return TRUE;
    else
      return FALSE;
    end if;
  END ID_NULL;


  FUNCTION ID_NULL(handle IN ParameterList) RETURN BOOLEAN is
  BEGIN
    if handle.hnd is null then 
      return TRUE;
    else
      return FALSE;
    end if;
  END ID_NULL;


/*
 * PACKAGE INITIALISATION
 */
BEGIN 
  -- Ensure all is initialised
  WebUtil_Core.Init;
END WEBUTIL_C_API;


PACKAGE WEBUTIL_DB_LOCAL IS

/*********************************************************************************\
 * WebUtil_DB_Local - Acts as a wrapper / Abstraction for the Database functions
 *  used by the WebUtil_File_Transfer Package.  
 *  The functions should not be called externally from WebUtil
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   DRMILLS 13/MAY/2003 - Creation
 *
\*********************************************************************************/

  FUNCTION  OpenBlob(blobTable  in VARCHAR2,
                     blobColumn in VARCHAR2,
                     blobWhere  in VARCHAR2,
                     openMode   in VARCHAR2,
                     chunkSize  in PLS_INTEGER default null) return BOOLEAN;

  FUNCTION  CloseBlob(checksum in PLS_INTEGER) return BOOLEAN;

  PROCEDURE WriteData(data in VARCHAR2);

  FUNCTION ReadData return VARCHAR;

  FUNCTION GetLastError return PLS_INTEGER;

  FUNCTION GetSourceLength  return PLS_INTEGER;

  FUNCTION GetSourceChunks  return PLS_INTEGER;

END WEBUTIL_DB_LOCAL;


PACKAGE BODY WEBUTIL_DB_LOCAL IS

  FUNCTION  OpenBlob(blobTable  in VARCHAR2,
                     blobColumn in VARCHAR2,
                     blobWhere  in VARCHAR2,
                     openMode   in VARCHAR2,
                     chunkSize  in PLS_INTEGER default null) return BOOLEAN is
  BEGIN
    return WebUtil_DB.OpenBlob(blobTable,
                             blobColumn,
                             blobWhere,
                             openMode,
                             chunkSize);
  END OpenBlob;                     

  FUNCTION  CloseBlob(checksum in PLS_INTEGER) return BOOLEAN is
  BEGIN
    return WebUtil_DB.CloseBlob(checksum);
  END CloseBlob;                     
  

  PROCEDURE WriteData(data in VARCHAR2) is
  BEGIN
    WebUtil_DB.WriteData(data);
  END WriteData;                     
  
  FUNCTION ReadData return VARCHAR is
  BEGIN
    return WebUtil_DB.ReadData;
  END ReadData;                     
  

  FUNCTION GetLastError return PLS_INTEGER is
  BEGIN
    return WebUtil_DB.GetLastError;
  END GetLastError;                     
      
  FUNCTION GetSourceLength  return PLS_INTEGER is 
  BEGIN
    return WebUtil_DB.GetSourceLength;
  END GetSourceLength;                     

  FUNCTION GetSourceChunks  return PLS_INTEGER is
  BEGIN
    return WebUtil_DB.GetSourceChunks;
  END GetSourceChunks;                     
  
END WEBUTIL_DB_LOCAL;


PACKAGE WEBUTIL_FILE IS
/*********************************************************************************\
 * WEBUTIL_FILE
 *   This Package contains routines to do basic File handling on the client
 *   machine - this includes reading and writing, deleting etc.
 *   This Package also provides the implementation for the Client Version of 
 *   GET_FILE_NAME for File selection dialogs
 *   The functions in this package will work with any client type - not just 
 *   Windows clients.
 *   The oracle.forms.webutil.file.FileFunctions bean is needed in your 
 *   Form to use these functions
 *********************************************************************************
 * Version 1.0.3
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 23/DEC/2002 - Creation
 *   1.0.1 DRMILLS 20/JAN/2003 - Added Copy File functionality 
 *   1.0.2 DRMILLS 12/MAR/2003 - Fix for 2846355 - Value error after cancelling
 *                               FILE_MULTI_SELECTION_DIALOG()
 *   1.0.3 DRMILLS 13/MAY/2003 - Added call for WebUtil_Core.Init;
 *   1.0.3 OSINGH  06/NOV/2003 - Corrected the spelling of SEPARATOR and WRITABLE
 *
\*********************************************************************************/
  /** 
   * A Type to hold the Array of file names returned by FILE_MULTI_SELECTION_DIALOG
   * and directory listing functions 
   */
  TYPE FILE_LIST is TABLE of VARCHAR2(1000) index by BINARY_INTEGER;


  /** 
   * Basic Implementation of a file / directory selection dialog
   * Maps onto the GET_FILE_NAME built-in usage
   */
  FUNCTION FILE_SELECTION_DIALOG(       directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL,
                                        dialog_type    Number   := OPEN_FILE,
                                        select_file    Boolean  := TRUE) return Varchar2;
                                        
  /** 
   * File / Directory selection dialog which allows the selection
   * of multiple files. 
   * The selection is returned in a PL/SQL table of type FILE_LIST
   */
  FUNCTION FILE_MULTI_SELECTION_DIALOG( directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL,
                                        dialog_type    Number   := OPEN_FILE,
                                        select_file    Boolean  := TRUE) return WEBUTIL_FILE.FILE_LIST;                                          
                                        
  /** 
   * Convenience Function for Creating a File Open dialog
   */  
  FUNCTION FILE_OPEN_DIALOG(            directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2;
                                        
  /** 
   * Convenience Function for Creating a File Save dialog
   */  
  FUNCTION FILE_SAVE_DIALOG(            directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2;
                                        
  /** 
   * Convenience Function for Creating a Directory Selection dialog
   */    
  FUNCTION DIRECTORY_SELECTION_DIALOG(  directory_name Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2;
                                        
  /** 
   * Function to check if a File was actually Selected by one of the dialog
   * functions or if the user actually pressed cancel
   */  
  FUNCTION FILE_DIALOG_SELECTION_MADE return BOOLEAN;                                       
                                        
  /** 
   * Function to check if a client side file or directory exists or not
   */  
  FUNCTION FILE_EXISTS(                 file_name      Varchar2) return BOOLEAN;

  /** 
   * Function to check if a client side file is readable
   */  
  FUNCTION FILE_IS_READABLE(            file_name      Varchar2) return BOOLEAN;  

  /** 
   * Function to check if a client side file is writable
   */  
  FUNCTION FILE_IS_WRITABLE(           file_name      Varchar2) return BOOLEAN;  

  /** 
   * Function to check if a client side file is actually a directory
   */  
  FUNCTION FILE_IS_DIRECTORY(           file_name      Varchar2) return BOOLEAN;  

  /** 
   * Function to check if a client side file is hidden
   */  
  FUNCTION FILE_IS_HIDDEN(              file_name      Varchar2) return BOOLEAN;  

  /** 
   * Function to get the size of the specified file in bytes
   */  
  FUNCTION FILE_SIZE(                   file_name      Varchar2) return NUMBER;  

  -- Create, rename and Delete functions
  /** 
   * Function to create a directory on the client
   * The directory name should be the full path to
   * the directory to be created. 
   * WebUtil will create any intermediate directories 
   * as well as the final one if required
   * Returns TRUE if the create was successful
   * If the directory already exists the call will fail.
   * You can use the FILE_IS_DIRECTORY function to check 
   * to see if the directory already exists before creating
   * it.
   */  
  FUNCTION CREATE_DIRECTORY(            directory_name      Varchar2) return BOOLEAN;  
  
  /**
   * Function to return a list of all the files in a directory
   * The Return_Files_Only argument indicates if the list returned 
   * should not include the names of any subdirectories.
   */
  FUNCTION DIRECTORY_LIST(             directory_name      Varchar2,
                                       return_files_only   Boolean := FALSE) return WEBUTIL_FILE.FILE_LIST;
  /**
   * Function to return a list of all the files in a directory
   * The Return_Files_Only argument indicates if the list returned 
   * should not include the names of any subdirectories   
   * This version allows you to specify a specific filter to restrict
   * the list of files that is returned.  If Return_Files_Only is set to 
   * false, then directory names will be returned even though they do not
   * match the filter.
   * The filter format is simply the acceptable extension e.g. "t*.fmb"
   * case is ignored.
   */
  FUNCTION DIRECTORY_FILTERED_LIST(    directory_name      Varchar2,
                                       file_filter         Varchar2,
                                       return_files_only   Boolean := FALSE) return WEBUTIL_FILE.FILE_LIST; 

  /**
   * Function to return a list of all the directory Roots
   * on the client.
   * On Unix Clients this will only ever return "/" but 
   * on Windows Platforms it will return a list of Drives
   */
  FUNCTION DIRECTORY_ROOT_LIST return WEBUTIL_FILE.FILE_LIST; 

  /** 
   * Function to rename a file or directory
   * Returns TRUE if the rename was successful
   */  
  FUNCTION RENAME_FILE(                 file_name      Varchar2,
                                        new_name       Varchar2) return BOOLEAN;   
  /** 
   * Function to copy a file (not a directory)
   * Returns TRUE if the copy was successful
   */  
  FUNCTION COPY_FILE(                   file_name      Varchar2,
                                        new_name       Varchar2) return BOOLEAN;                                           

  /** 
   * Function to delete a specified client side file or empty Directory
   * Returns TRUE if the delete was successful
   */  
  FUNCTION DELETE_FILE(                 file_name      Varchar2) return BOOLEAN;  
   
  
  -- Various Information Functions - simply overloaded from WebUtil_Core.
  -- and duplicated in WebUtil_ClientInfo
  /**
   * GET_PATH_SEPARATOR - returns the path separator used by the client OS
   * e.g. ";" on a Windows Client, ":" on Unix/Linux
   */ 
  FUNCTION GET_PATH_SEPARATOR return VARCHAR2;
  
  /**
   * GET_FILE_SEPARATOR - returns the file separator used by the client OS
   * e.g. "\" on a Windows Client, "/" on Unix/Linux   
   */ 
  FUNCTION GET_FILE_SEPARATOR return VARCHAR2;

  /**
   * Function to return the last modified date (EPOCH) for given file
   */
  FUNCTION FILE_MODIFIED_EPOCH(          file_name      Varchar2) return NUMBER;

  /**
   * Default format is set to "dd-MMM-yyyy HH:mm:ss" for this method. If no configuration
   * provided by user, this function will return date in above mentioned format.If user want
   * this function to return date in any specific format, please assign following
   * applet parameter with desired format: WebUtilDateFormat. In absence of WebUtilDateFormat
   * parameter, this function will return value using the default format.
   */
  FUNCTION FILE_MODIFIED_DATE(          file_name      Varchar2) return Varchar2;
   
END WEBUTIL_FILE;


PACKAGE BODY WEBUTIL_FILE IS
  INVALID_CLIENT_FILE_DIR  EXCEPTION;
  NULL_CLIENT_DIRECTORY    EXCEPTION;
  -- Private Variables
  ATTR_EXISTS       CONSTANT PLS_INTEGER := 1;
  ATTR_READABLE     CONSTANT PLS_INTEGER := 2;
  ATTR_WRITABLE     CONSTANT PLS_INTEGER := 3;
  ATTR_IS_DIRECTORY CONSTANT PLS_INTEGER := 4;
  ATTR_IS_HIDDEN    CONSTANT PLS_INTEGER := 5;
  ATTR_SIZE         CONSTANT PLS_INTEGER := 6;  
  ATTR_MOD_EPOCH    CONSTANT PLS_INTEGER := 7;
  ATTR_MOD_DATE     CONSTANT PLS_INTEGER := 8;    
  
  
  
  -- Private method declarations --------------------------------------
  FUNCTION FILE_SELECTION_DIALOG_INT(   directory_name Varchar2,
                                        file_name      Varchar2,
                                        file_filter    Varchar2,
                                        title          Varchar2,
                                        dialog_type    Number,
                                        select_file    Boolean,
                                        multiselect    Boolean) return Varchar2;
                                        
  FUNCTION GET_ATTRIBUTE_INT(           file_name      Varchar2,
                                        attributeID    Pls_Integer) return Varchar2;    


  
  -- Private method implementations -----------------------------------
  FUNCTION FILE_SELECTION_DIALOG_INT(   directory_name Varchar2,
                                        file_name      Varchar2,
                                        file_filter    Varchar2,
                                        title          Varchar2,
                                        dialog_type    Number,
                                        select_file    Boolean,
                                        multiselect    Boolean) return Varchar2 is
    result varchar2(4000);     
    pos Number;
  BEGIN  
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_DIRNAME', directory_name);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',file_name, true);     
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILTER',  file_filter); 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_MESSAGE', title); 
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_MULTISELECT', multiselect,true);     
  
    if (dialog_type = SAVE_FILE) then 
        result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_SAVEFILE');
    elsif (not select_file) then
        result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_OPENDIR');
    else
        result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_OPENFILE');
    end if;
  
    -- handle the situation which we can get with JFileChooser with escaped "\"

    -- if string starts with '\\', replace it with '\\\\', 
    -- before running the original replace statement.
    pos := instr(result, '\\');

    -- concat '\\' in the begining of the string before calling the replace.
    if (pos = 1) then
        result := concat('\\', result);
    end if;

    result := replace(result,'\\','\');
    return result;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.FILE_SELECTION_DIALOG_INT will not work');
      RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END FILE_SELECTION_DIALOG_INT;                                         

  FUNCTION GET_ATTRIBUTE_INT(           file_name      Varchar2,
                                        attributeID    Pls_Integer) return Varchar2 is
    result Varchar2(50);   
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',file_name, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILE_ATTRIBUTE',to_char(attributeID), true);
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILE_ATTRIBUTE');
    
    RETURN result;                      
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.GET_ATTRIBUTE_INT will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END GET_ATTRIBUTE_INT;                                         
                                        
  -- Public method implementations ------------------------------------
  FUNCTION FILE_SELECTION_DIALOG(       directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL,
                                        dialog_type    Number   := OPEN_FILE,
                                        select_file    Boolean  := TRUE) return Varchar2 is
  BEGIN
    RETURN FILE_SELECTION_DIALOG_INT(   directory_name,
                                        file_name,
                                        file_filter,
                                        title,
                                        dialog_type,
                                        select_file,
                                        FALSE); 
  END FILE_SELECTION_DIALOG;                                       
                                        
  FUNCTION FILE_MULTI_SELECTION_DIALOG( directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL,
                                        dialog_type    Number   := OPEN_FILE,
                                        select_file    Boolean  := TRUE) return WEBUTIL_FILE.FILE_LIST is
    buffer         varchar2(32000);
    dirName        varchar2(1000);
    selectionCount PLS_INTEGER;
    fileList       WEBUTIL_FILE.FILE_LIST;
  BEGIN
    buffer :=  FILE_SELECTION_DIALOG_INT(   directory_name,
                                            file_name,
                                            file_filter,
                                            title,
                                            dialog_type,
                                            select_file,
                                            TRUE); 
    -- Bug 2846355                                            
    if buffer is not null then                                             
      -- Multi-select returns a String delimited with newlines
      -- with the first element being the directory
      -- This is an efficient way of doing it as we only 
      -- need one routrip to get the full selection
      -- but we could hit a problem if the total length of
      -- the directory & filenames exceeds the buffer size                                         
      selectionCount := DelimStr.Counter(buffer,false,chr(10));
      dirName := DelimStr.GetString(buffer,1,false,chr(10));
      for i in 2..selectionCount LOOP
        fileList(i-1) := dirName||DelimStr.GetString(buffer,i,false,chr(10));       
      end LOOP;                                               
    end if;
    RETURN fileList;                                            
  END FILE_MULTI_SELECTION_DIALOG;                                       
                                                                              
  FUNCTION FILE_OPEN_DIALOG(            directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2 is
  BEGIN
    RETURN FILE_SELECTION_DIALOG_INT(   directory_name,
                                        file_name,
                                        file_filter,
                                        title,
                                        OPEN_FILE,
                                        TRUE,
                                        FALSE); 
  END FILE_OPEN_DIALOG;                                                                               
                                        
  FUNCTION FILE_SAVE_DIALOG(            directory_name Varchar2 := NULL,
                                        file_name      Varchar2 := NULL,
                                        file_filter    Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2 is
  BEGIN
    RETURN FILE_SELECTION_DIALOG_INT(   directory_name,
                                        file_name,
                                        file_filter,
                                        title,
                                        SAVE_FILE,
                                        TRUE,
                                        FALSE); 
  END FILE_SAVE_DIALOG;                                                                 
                                        
  FUNCTION DIRECTORY_SELECTION_DIALOG(  directory_name Varchar2 := NULL,
                                        title          Varchar2 := NULL) return Varchar2 is
  BEGIN
    RETURN FILE_SELECTION_DIALOG_INT(   directory_name,
                                        NULL,
                                        NULL,
                                        title,
                                        OPEN_FILE,
                                        FALSE,
                                        FALSE); 
  END DIRECTORY_SELECTION_DIALOG;  
  
  FUNCTION FILE_DIALOG_SELECTION_MADE return BOOLEAN is
    result varchar2(6);
  BEGIN
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_GFN_SELECTION_MADE');
    RETURN (result='TRUE');                       
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.FILE_DIALOG_SELECTION_MADE will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE; 
  END FILE_DIALOG_SELECTION_MADE;
                                                                                
  FUNCTION FILE_EXISTS(                 file_name      Varchar2) return BOOLEAN is
  BEGIN
    return (GET_ATTRIBUTE_INT(file_name,ATTR_EXISTS)='TRUE');
  END FILE_EXISTS; 
  
  FUNCTION FILE_IS_READABLE(            file_name      Varchar2) return BOOLEAN is
  BEGIN
    return (GET_ATTRIBUTE_INT(file_name,ATTR_READABLE)='TRUE');
  END FILE_IS_READABLE; 

  FUNCTION FILE_IS_WRITABLE(           file_name      Varchar2) return BOOLEAN is
  BEGIN
    return (GET_ATTRIBUTE_INT(file_name,ATTR_WRITABLE)='TRUE');
  END FILE_IS_WRITABLE; 
  
  FUNCTION FILE_IS_DIRECTORY(           file_name      Varchar2) return BOOLEAN is
  BEGIN
    return (GET_ATTRIBUTE_INT(file_name,ATTR_IS_DIRECTORY)='TRUE');
  END FILE_IS_DIRECTORY; 
  
  FUNCTION FILE_IS_HIDDEN(              file_name      Varchar2) return BOOLEAN is
  BEGIN
    return (GET_ATTRIBUTE_INT(file_name,ATTR_IS_HIDDEN)='TRUE');
  END FILE_IS_HIDDEN;  
  
  FUNCTION FILE_SIZE(                   file_name      Varchar2) return NUMBER is
  BEGIN
    return to_number(GET_ATTRIBUTE_INT(file_name,ATTR_SIZE)); 
  END FILE_SIZE;  
    
  
  FUNCTION CREATE_DIRECTORY(            directory_name Varchar2) return BOOLEAN is
    result Varchar2(6);   
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',directory_name, true);
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_CREATE_DIRECTORY');   
    RETURN (result='TRUE');                       
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.CREATE_DIRECTORY will not work');
      RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END CREATE_DIRECTORY; 
  
  FUNCTION DIRECTORY_LIST(             directory_name      Varchar2,
                                       return_files_only   Boolean := FALSE) return WEBUTIL_FILE.FILE_LIST is
  BEGIN
    return DIRECTORY_FILTERED_LIST(directory_name, null, return_files_only);                                 
  END DIRECTORY_LIST;      
  
  FUNCTION DIRECTORY_FILTERED_LIST(    directory_name      Varchar2,
                                       file_filter         Varchar2,
                                       return_files_only   Boolean := FALSE) return WEBUTIL_FILE.FILE_LIST is
    buffer         varchar2(32000);
    dirInd         varchar2(1) := 'Y';
    selectionCount PLS_INTEGER;
    fileList       WEBUTIL_FILE.FILE_LIST;                                   
  BEGIN
    if directory_name is null then
      raise NULL_CLIENT_DIRECTORY;
    elsif directory_name is not null and NOT WEBUTIL_FILE.FILE_IS_DIRECTORY(directory_name) then
      raise INVALID_CLIENT_FILE_DIR;
    end if;
      
    if return_files_only then 
      dirInd := 'N';
    end if;
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',directory_name, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILTER',file_filter, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_NO_DIRECTORIES',dirInd, true);    
    buffer := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_DIRECTORY_LIST');  
    if buffer is not null then 
      selectionCount := DelimStr.Counter(buffer,false,chr(10));
      for i in 1..selectionCount LOOP
        fileList(i) := DelimStr.GetString(buffer,i,false,chr(10));       
      end LOOP;    
    end if;
    return fileList;
  EXCEPTION  
    when INVALID_CLIENT_FILE_DIR then
      WebUtil_Core.Error(Webutil_Core.WUF_PACKAGE,210, 'WEBUTIL_FILE.DIRECTORY_FILTERED_LIST',directory_name);
      raise FORM_TRIGGER_FAILURE;
    when NULL_CLIENT_DIRECTORY then
      WebUtil_Core.Error(Webutil_Core.WUF_PACKAGE,212, 'WEBUTIL_FILE.DIRECTORY_FILTERED_LIST');
      raise FORM_TRIGGER_FAILURE;
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.DIRECTORY_FILTERED_LIST will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;    
  END DIRECTORY_FILTERED_LIST;
  
  FUNCTION DIRECTORY_ROOT_LIST return WEBUTIL_FILE.FILE_LIST is
    buffer         varchar2(1024);
    selectionCount PLS_INTEGER;
    fileList       WEBUTIL_FILE.FILE_LIST;                                   
  BEGIN
    buffer := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_DIRECTORY_ROOT_LIST'); 
    if buffer is not null then 
      selectionCount := DelimStr.Counter(buffer,false,chr(10));
      for i in 1..selectionCount LOOP
          fileList(i) := DelimStr.GetString(buffer,i,false,chr(10));       
      end LOOP;    
    end if;
    return fileList;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.DIRECTORY_ROOT_LIST will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;    
  END DIRECTORY_ROOT_LIST;

  FUNCTION RENAME_FILE(                 file_name      Varchar2,
                                        new_name       Varchar2) return BOOLEAN is
    result Varchar2(6);   
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',file_name, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_RENAME_FILE',new_name, true);    
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_RENAME_FILE');   
    RETURN (result='TRUE');                       
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.RENAME_FILE will not work');
      RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END RENAME_FILE;
  
  FUNCTION COPY_FILE(                   file_name      Varchar2,
                                        new_name       Varchar2) return BOOLEAN is
    result Varchar2(6);   
  BEGIN
    if file_name = new_name then
      WebUtil_Core.Error(Webutil_Core.WUF_PACKAGE,211, 'WEBUTIL_FILE.COPY_FILE',file_name);
      return false;
    end if;
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',file_name, true);
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_COPY_FILE',new_name, true);    
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_COPY_FILE');   
    RETURN (result='TRUE');                       
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.COPY_FILE will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END COPY_FILE;                                        
  
  
  FUNCTION DELETE_FILE(                 file_name      Varchar2) return BOOLEAN is
    result Varchar2(6);   
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUF_PACKAGE,'WUF_FILENAME',file_name, true); 
    result := WebUtil_Core.getProperty(WebUtil_Core.WUF_PACKAGE,'WUF_DELETE_FILE');   
    RETURN (result='TRUE');                       
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUF_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE.DELETE_FILE will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END DELETE_FILE;  

  FUNCTION GET_PATH_SEPARATOR return VARCHAR2 is
  begin
    return WebUtil_Core.getClientPathSep;
  end GET_PATH_SEPARATOR;
  
  FUNCTION GET_FILE_SEPARATOR return VARCHAR2 is
  begin
    return WebUtil_Core.getClientFileSep;
  end GET_FILE_SEPARATOR;

  FUNCTION FILE_MODIFIED_EPOCH(          file_name      Varchar2) return NUMBER is
  BEGIN
    return to_number(GET_ATTRIBUTE_INT(file_name,ATTR_MOD_EPOCH));
  END FILE_MODIFIED_EPOCH;


  -- Default format is set to "dd-MMM-yyyy HH:mm:ss" for this method. If no configuration
  -- provided by user, this function will return date in above mentioned format.If user want
  -- this function to return date in any specific format, please assign following
  -- applet parameter with desired format: WebUtilDateFormat. In absence of WebUtilDateFormat
  -- parameter, this function will return value using the default format.
  FUNCTION FILE_MODIFIED_DATE(          file_name      Varchar2) return Varchar2 is
  BEGIN
    return GET_ATTRIBUTE_INT(file_name, ATTR_MOD_DATE);
  END FILE_MODIFIED_DATE;

BEGIN 
    -- Ensure Core is instanciated
    WebUtil_Core.Init; 
END WEBUTIL_FILE;


PACKAGE WEBUTIL_FILE_TRANSFER IS
/*********************************************************************************\
 * WEBUTIL_FILE_TRANSFER
 *   This Package contains routines Upload and download files from/to the
 *   browser client machine
 *   The oracle.forms.webutil.fileTransfer.FileTransfer bean is needed in your 
 *   Form to use these functions
 *********************************************************************************
 * Version 1.0.1
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 03/FEB/2003 - Creation
 *   1.0.1 DRMILLS 13/MAY/2003 - Added a call to Webutil_Core.Init to enforce 
 *                               correct instanciation.
 *                               Added abstraction layer to the DB Package so that 
 *                               lack of that package does not invalidate this package 
 *                               body
 *
 *********************************************************************************
 * TODO:
 *       1) Improve handling of unexpected database error situations
 *       2) Add functionality to Upload / Download from App Server Filesystem to / 
 *          from the Database
 *       
\*********************************************************************************/
      
  /**
   * URL_To_Client - pulls a file from the specified URL on any server and 
   * sends it via http to the specified destination on the client
   * If you specify file size we can do a comparison after download to ensure 
   * that the sizes match
   * Additionally if you specify withProgress and size you will get a progress
   * bar.
   * If you don't specify any size or if you specify default size, then webutil
   * will try to get the size of the url on its own for the purpose of showing
   * the progress bar.
   * Note that the Title, subtitle and message strings cannot contain the '|'
   * character
   */
  FUNCTION URL_To_Client(    sourceURL         in VARCHAR2, 
                             clientDestination in VARCHAR2, 
                             fileSize          in PLS_INTEGER default 0) return BOOLEAN;
                           
  FUNCTION URL_To_Client_With_Progress(
                             sourceURL         in VARCHAR2, 
                             clientDestination in VARCHAR2, 
                             fileSize          in PLS_INTEGER default 0,
                             progressTitle     in VARCHAR2,
                             progressSubTitle  in VARCHAR2,
                             progressMessage   in VARCHAR2) return BOOLEAN;     


  /**
   * Client_To_DB - uploads a named client side file into the specified 
   * column in the database.
   * The combination of tableName and columnName should identify a BLOB
   * Column in the database.  The whereClause should narrow the selection
   * down so that one and only one row is identified.
   * The file transfer is carried out using the normal Forms connection and 
   * will be committed by the Form in the normal way.
   *
   * The currently connected user #must# have execute priviledges on 
   * the WEBUTIL_DB package.
   *
   * The transfer can be flagged as Asynchronous.  This will not really allow
   * the end user to carry out work whilst the upload is going on but it will 
   * ensure that Forms can re-draw it's screen.
   * If you pass a user defined trigger as callbackTrigger, then the trigger
   * will be fired/executed when the upload is complete. This will become useful
   * particularly when the upload is asynchronous.
   * WebUtil_File_Transfer.Asynchronous_Upload_Success will indicate if the 
   * Upload worked or not.
   * 
   * Additionally of you specify withProgress you will get a progress
   * bar as the upload takes place
   * Note that the title and subtitle cannot contain the '|'
   * character
   */
  FUNCTION Client_To_DB( clientFile       in VARCHAR2, 
                         tableName        in VARCHAR2, 
                         columnName       in VARCHAR2,
                         whereClause      in VARCHAR2,
                         asynchronous     in BOOLEAN default FALSE,
                         callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN;

  FUNCTION Client_To_DB_With_Progress
                     (   clientFile       in VARCHAR2, 
                         tableName        in VARCHAR2, 
                         columnName       in VARCHAR2,
                         whereClause      in VARCHAR2,
                         progressTitle    in VARCHAR2,
                         progressSubTitle in VARCHAR2,
                         asynchronous     in BOOLEAN default FALSE,
                         callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN;


  /**
   * DB_To_Client - downloads the contents of a database BLOB into the 
   * specified client side file.
   * The combination of tableName and columnName should identify a BLOB
   * Column in the database.  The whereClause should narrow the selection
   * down so that one and only one row is identified.
   * The file transfer is carried out using the normal Forms connection.
   *
   * The currently connected user #must# have execute priviledges on 
   * the WEBUTIL_DB package.
   *
   * If you specify withProgress you will get a progress
   * bar as the download takes place
   * Note that the title and subtitle cannot contain the '|'
   * character
   */
  FUNCTION DB_To_Client
                     ( clientFile       in VARCHAR2, 
                       tableName        in VARCHAR2, 
                       columnName       in VARCHAR2,
                       whereClause      in VARCHAR2) return BOOLEAN;

  FUNCTION DB_To_Client_With_Progress
                     ( clientFile       in VARCHAR2, 
                       tableName        in VARCHAR2, 
                       columnName       in VARCHAR2,
                       whereClause      in VARCHAR2,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN;
                       
                       
  /**
   * Client_To_AS - uploads a named client side file into the specified 
   * file name on the application server.
   *
   * The transfer can be flagged as Asynchronous.  This will not really allow
   * the end user to carry out work whilst the upload is going on but it will 
   * ensure that Forms can re-draw it's screen.
   * If you pass a user defined trigger as callbackTrigger, then the trigger
   * will be fired/executed when the upload is complete. This will become useful
   * particularly when the upload is asynchronous.
   * WebUtil_File_Transfer.Asynchronous_Upload_Success will indicate if the 
   * Upload worked or not.
   * 
   * Additionally of you specify withProgress you will get a progress
   * bar as the upload takes place
   * Note that the title and subtitle cannot contain the '|'
   * character
   */
  FUNCTION Client_To_AS( clientFile       in VARCHAR2, 
                         serverFile       in VARCHAR2, 
                         asynchronous     in BOOLEAN default FALSE,
                         callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN;

  FUNCTION Client_To_AS_With_Progress
                       ( clientFile       in VARCHAR2, 
                         serverFile       in VARCHAR2, 
                         progressTitle    in VARCHAR2,
                         progressSubTitle in VARCHAR2,
                         asynchronous     in BOOLEAN default FALSE,
                         callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN;                         
  
  /**
   * AS_To_Client - downloads the contents of file on the applciation 
   * server to a specified client side file.
   *
   * If you specify withProgress you will get a progress
   * bar as the download takes place
   * Note that the title and subtitle cannot contain the '|'
   * character
   */
  FUNCTION AS_To_Client
                     ( clientFile       in VARCHAR2, 
                       serverFile       in VARCHAR2) return BOOLEAN;

  FUNCTION AS_To_Client_With_Progress
                     ( clientFile       in VARCHAR2, 
                       serverFile       in VARCHAR2, 
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN;
                        

  /**
   * InProgress - indicates if a file transfer using Client_To_DB 
   * or Client_To_AS is currently operating (this will be for Asynchronous calls)
   */
  FUNCTION In_Progress return BOOLEAN;      

  /**
   * Asynchronous_Upload_Success - indicates if an Asynchronous  
   * upload succeeded or not.
   * Should only be called from within the Asynchronous callback
   * trigger.
   */
  FUNCTION Asynchronous_Upload_Success return BOOLEAN;      
  
  /**
   * Get_Work_Area - The WebUtil administrator can define a 
   * directory root on the application server for use for 
   * temporary files.  This workarea returned will be based
   * on this directory root and a subdirectory name constructed 
   * from the IP address and username of the client machine
   * The autoCreate switch will ensure that the directory 
   * exists on the file system and will create it if it does 
   * not.
   */
  FUNCTION Get_Work_Area(autoCreate BOOLEAN := true) return VARCHAR2;
  
  /**
   * is_AS_Writable - The WebUtil administrator can define a 
   * set of directories that uploading is allowed to on the 
   * application server.  This function checks if a 
   * file specification points to a writable location
   * You should call this before attempting to upload to the 
   * application server *if* you are using Access Control 
   * If you are not using Access Control the function will
   * return TRUE. 
   */
  FUNCTION is_AS_Writable(fileName in VARCHAR2) return BOOLEAN;
  
  /**
   * is_AS_Readable - The WebUtil administrator can define a 
   * set of directories that downloading is allowed from
   *  on the application server.  This function checks if a 
   * file specification points to a readable location
   * You should call this before attempting to download from 
   * the application server *if* you are using Access Control 
   * If you are not using Access Control the function will
   * return TRUE. 
   */
  FUNCTION is_AS_Readable(fileName in VARCHAR2) return BOOLEAN;
  
                         
  /**
   * SetData - Procedure used internally during Async Upload
   * Do not call this procedure manually 
   */
  PROCEDURE SetData(uploadData in VARCHAR2);
  
END;


PACKAGE BODY WEBUTIL_FILE_TRANSFER IS
  -- internal exceptions
  CLIENT_FILE_EMPTY  EXCEPTION;
  CLIENT_FILE_NULL   EXCEPTION;
  AS_FILE_NULL       EXCEPTION;
  INVALID_CLIENT_FILE_DIR   EXCEPTION;
  FILE_NOT_FOUND     EXCEPTION;
  AGENT_BUSY         EXCEPTION;
  READWRITE_ERROR    EXCEPTION;
  CLIENT_ERROR       EXCEPTION;
  TRANSFER_FORBIDDEN EXCEPTION;      
  NO_JAVA            EXCEPTION;
      
  -- internal types      
  Type aclType is table of varchar2(1024 char) index by binary_integer;
      
  -- Internal Varibles
  m_chunks          PLS_INTEGER := 0;
  m_maxTransferSize PLS_INTEGER := 16384;
  m_fileSize        PLS_INTEGER := 0;
  m_uploadSucceeded BOOLEAN;
  m_toDB            BOOLEAN;
  m_workarea        VARCHAR2(512);
  m_DBEnabled       BOOLEAN := false;
  m_ASEnabled       BOOLEAN := false;  
  m_ASUseACL        BOOLEAN := false;       
  m_readACL         aclType;
  m_writeACL        aclType; 
  m_windows         BOOLEAN := false;  
  m_persistObj      ORA_JAVA.JOBJECT;
  m_workAreaCreated BOOLEAN := false;
  
  -- Internal Procs
  FUNCTION UploadInt
                     ( clientFile       in VARCHAR2, 
                       spec1            in VARCHAR2, 
                       spec2            in VARCHAR2,
                       spec3            in VARCHAR2,
                       toDB             in BOOLEAN,
                       withProgress     in BOOLEAN,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2,                       
                       asynchronous     in BOOLEAN default FALSE,
                       callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN;

  FUNCTION DownloadInt
                     ( clientFile       in VARCHAR2, 
                       spec1            in VARCHAR2, 
                       spec2            in VARCHAR2,
                       spec3            in VARCHAR2,
                       fromDB           in BOOLEAN,
                       withProgress     in BOOLEAN,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN;


  FUNCTION getMaxTransfer return PLS_INTEGER;
  
  PROCEDURE init;
  
  FUNCTION checkASACL(ASFile          in     VARCHAR2,
                      acl           in out aclType) return BOOLEAN;
                      
  -- Public Functions
  FUNCTION URL_To_Client(sourceURL         in VARCHAR2, 
                         clientDestination in VARCHAR2, 
                         fileSize          in PLS_INTEGER default 0) return BOOLEAN is
  BEGIN
      return WebUtil_Core.DownLoadFromURL(sourceURL, 
                                        clientDestination, 
                                        fileSize);
  END URL_To_Client;
                           
  FUNCTION URL_To_Client_With_Progress(sourceURL         in VARCHAR2, 
                                       clientDestination in VARCHAR2, 
                                       fileSize          in PLS_INTEGER default 0,
                                       progressTitle     in VARCHAR2,
                                       progressSubTitle  in VARCHAR2,
                                       progressMessage   in VARCHAR2) return BOOLEAN is
  BEGIN
    return WebUtil_Core.DownLoadFromURLWithProgress
                                       (sourceURL, 
                                        clientDestination, 
                                        fileSize,
                                        progressTitle,
                                        progressSubTitle,
                                        progressMessage);
  END URL_To_Client_With_Progress;       
  
  
  FUNCTION Client_To_DB( clientFile      in VARCHAR2, 
                         tableName       in VARCHAR2, 
                         columnName      in VARCHAR2,
                         whereClause     in VARCHAR2,
                         asynchronous    in BOOLEAN default FALSE,
                         callbackTrigger in VARCHAR2 default NULL) return BOOLEAN is
  BEGIN
    return UploadInt(
                       clientFile,
                       tableName,
                       columnName,
                       whereClause,
                       true,
                       false,
                       null,
                       null,
                       asynchronous,
                       callbackTrigger);
  END Client_To_DB;                                           

  FUNCTION Client_To_DB_With_Progress
                     ( clientFile       in VARCHAR2, 
                       tableName        in VARCHAR2, 
                       columnName       in VARCHAR2,
                       whereClause      in VARCHAR2,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2,
                       asynchronous     in BOOLEAN default FALSE,
                       callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN is
  BEGIN
    return UploadInt
                     ( clientFile,
                       tableName,
                       columnName,
                       whereClause,
                       true,
                       true,
                       progressTitle,
                       progressSubTitle,                       
                       asynchronous,
                       callbackTrigger);
  END Client_To_DB_With_Progress;                                           

  FUNCTION DB_To_Client
                     ( clientFile      in VARCHAR2, 
                       tableName       in VARCHAR2, 
                       columnName      in VARCHAR2,
                       whereClause     in VARCHAR2) return BOOLEAN is
  BEGIN
    return DownloadInt
                     ( clientFile,
                       tableName,
                       columnName,
                       whereClause,
                       true,
                       false,
                       null,
                       null);
  END DB_To_Client;                                           

  FUNCTION DB_To_Client_With_Progress
                     ( clientFile       in VARCHAR2, 
                       tableName        in VARCHAR2, 
                       columnName       in VARCHAR2,
                       whereClause      in VARCHAR2,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN is
  BEGIN
    return DownloadInt
                     ( clientFile,
                       tableName,
                       columnName,
                       whereClause,
                       true,
                       true,
                       progressTitle,
                       progressSubTitle);
  END DB_To_Client_With_Progress; 
  
  FUNCTION Client_To_AS( clientFile       in VARCHAR2, 
                         serverFile       in VARCHAR2, 
                         asynchronous     in BOOLEAN default FALSE,
                         callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN is
  BEGIN
    return UploadInt(
                       clientFile,
                       serverFile,
                       null,
                       null,
                       false,
                       false,
                       null,
                       null,
                       asynchronous,
                       callbackTrigger);
  END Client_To_AS;                        

  FUNCTION Client_To_AS_With_Progress
                     ( clientFile       in VARCHAR2, 
                       serverFile       in VARCHAR2, 
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2,
                       asynchronous     in BOOLEAN default FALSE,
                       callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN is
 BEGIN
    return UploadInt
                     ( clientFile,
                       serverFile,
                       null,
                       null,
                       false,
                       true,
                       progressTitle,
                       progressSubTitle,                       
                       asynchronous,
                       callbackTrigger);
  END Client_To_AS_With_Progress;                            
  
  FUNCTION AS_To_Client
                     ( clientFile       in VARCHAR2, 
                       serverFile       in VARCHAR2) return BOOLEAN is
  BEGIN
    return DownloadInt
                     ( clientFile,
                       serverFile,
                       null,
                       null,
                       false,
                       false,
                       null,
                       null);
  END AS_To_Client;                          

  FUNCTION AS_To_Client_With_Progress
                     ( clientFile       in VARCHAR2, 
                       serverFile       in VARCHAR2, 
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN is
  BEGIN
    return DownloadInt
                     ( clientFile,
                       serverFile,
                       null,
                       null,
                       false,
                       true,
                       progressTitle,
                       progressSubTitle);
  END AS_To_Client_With_Progress;                       
  
  FUNCTION In_Progress return BOOLEAN is
    status VARCHAR2(5);
  BEGIN 
    status := WebUtil_Core.getProperty(WebUtil_Core.WUT_PACKAGE,'WUT_STATUS');
    return (status='BUSY');
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUT_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE_TRANSFER.In_Progress will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END In_Progress;
   
  FUNCTION Get_Work_Area(autoCreate BOOLEAN := true) return VARCHAR2 is 
    jfile ORA_JAVA.JOBJECT;
  BEGIN
    if (autoCreate and not m_workAreaCreated) then 
      jfile := JAVA_FILE.new(m_workarea);
      if not JAVA_FILE.exists_(jfile) then 
        if not JAVA_FILE.mkdirs(jfile) then
          WebUtil_Core.error(WebUtil_Core.WUT_PACKAGE,127,'WEBUTIL_FILE_TRANSFER.GetWork_Area');
        else
          m_workAreaCreated := true;
        end if; --mkdirs
      elsif not JAVA_FILE.isDirectory(jfile) then 
        WebUtil_Core.error(Webutil_Core.WUT_PACKAGE,127,'WEBUTIL_FILE_TRANSFER.GetWork_Area');
      else
        m_workAreaCreated := true;
      end if; -- exists
    end if;    
    return m_workarea;
  EXCEPTION
    when ORA_JAVA.EXCEPTION_THROWN then
      WebUtil_Core.error(Webutil_Core.WUT_PACKAGE,128,'WEBUTIL_FILE_TRANSFER.GetWork_Area');
      return null;
  END Get_Work_Area;   
  
  FUNCTION is_AS_Writable(fileName in VARCHAR2) return BOOLEAN is
  BEGIN
    return checkASACL(fileName, m_writeACL);
  END is_AS_Writable;
  
  FUNCTION is_AS_Readable(fileName in VARCHAR2) return BOOLEAN is
  BEGIN
    return checkASACL(fileName, m_readACL);
  END is_AS_Readable;
   
  PROCEDURE SetData(uploadData in VARCHAR2) is 
    lastErrorCode    PLS_INTEGER;
    lastErrorArgs    VARCHAR2(1000);   
  BEGIN
    if uploadData is null or uploadData = '' then 
      -- error condition!
      m_uploadSucceeded := false;
    else
      -- Write to the correct place    
      if m_toDB then 
        WebUtil_DB_LOCAL.WriteData(uploadData);
      else
        if not JAVA_APPSERV_WRITER.WriteData(m_persistObj,uploadData) then
          lastErrorCode := JAVA_APPSERV_WRITER.getLastError(m_persistObj);
          lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(m_persistObj) ;
          WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                             'WEBUTIL_FILE_TRANSFER.SetData',lastErrorArgs);
          raise READWRITE_ERROR;
        end if;
      end if;
      m_chunks := m_chunks - 1;
      if m_chunks = 0 then 
        if m_toDB then 
          if WebUtil_DB_Local.CloseBlob(m_fileSize) then 
            m_uploadSucceeded := true;
          else
            WebUtil_core.Error(Webutil_Core.WUT_PACKAGE, WebUtil_DB_Local.getLastError,
                               'WEBUTIL_FILE_TRANSFER.SetData');
          end if; -- close
        else
          if JAVA_APPSERV_WRITER.CloseFile(m_persistObj,m_fileSize) then
            m_uploadSucceeded := true;
          else
            lastErrorCode := JAVA_APPSERV_WRITER.getLastError(m_persistObj);
            lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(m_persistObj) ;
            WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                               'WEBUTIL_FILE_TRANSFER.SetData',lastErrorArgs);
            ORA_JAVA.DELETE_GLOBAL_REF(m_persistObj);
            raise READWRITE_ERROR;
          end if;    
        end if; -- toDB

        if WebUtil_Core.GetCallbackTrigger(-1) is not null then
          EXECUTE_TRIGGER(WebUtil_Core.GetCallbackTrigger(-1));
        end if;
        WebUtil_Core.ClearCallbackTrigger(-1);
      end if; -- chunks
    end if;
  end SetData;   
  
  FUNCTION Asynchronous_Upload_Success return BOOLEAN is
  begin
    return m_uploadSucceeded;
  end Asynchronous_Upload_Success;   
  
  -- Internal implementations ----
  FUNCTION UploadInt ( clientFile       in VARCHAR2, 
                       spec1            in VARCHAR2, 
                       spec2            in VARCHAR2,
                       spec3            in VARCHAR2,
                       toDB             in BOOLEAN,
                       withProgress     in BOOLEAN,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2,                       
                       asynchronous     in BOOLEAN default FALSE,
                       callbackTrigger  in VARCHAR2 default NULL) return BOOLEAN is
    clientFileSize   PLS_INTEGER := 0;   
    clientFileChunks PLS_INTEGER := 0;                       
    clientFileInfo   VARCHAR2(1000 char);
    result           BOOLEAN     := FALSE;
    dataBuffer       VARCHAR2(32767);
    ignore           VARCHAR2(2);
    jobj             ORA_JAVA.JOBJECT;
    lastErrorCode    PLS_INTEGER;
    lastErrorArgs    VARCHAR2(1000);
    encodedFile      ORA_JAVA.JOBJECT;
    ftemp            TEXT_IO.FILE_TYPE;
    tempFileName     VARCHAR2(512);
    bool_ignore      boolean;
  BEGIN
    -- Client file cannot be null
    if clientFile is null then
        raise CLIENT_FILE_NULL;
    end if;

    -- Application server file cannot be null. AppsServerFileWriter also handles this.
    -- Better to handle here.
    if NOT toDB AND spec1 is null then
        raise AS_FILE_NULL;
    end if;
 
          

    -- Make sure the client file to be uploaded exists and readable
    -- If we don't raise exception here, we end up creating an empty file on
    -- database or application server
    if NOT webutil_file.file_is_readable(clientFile)
       OR webutil_file.file_is_directory (clientFile) then
      raise FILE_NOT_FOUND;
    end if;
      
    -- First check to see if a transfer is not currently happening
    if In_Progress then
        raise AGENT_BUSY;
    end if;

    -- reset the target
    m_toDB := toDB;

    -- Set up the file info
    clientFileInfo := clientFile||'|0|'||
                      WEBUTIL_UTIL.BoolToStr(asynchronous,'A|','S|')||
                      WEBUTIL_UTIL.BoolToStr(withProgress,'Y|','N|')||
                      progressTitle||'|'||
                      progressSubTitle;
    WebUtil_Core.setProperty(WebUtil_Core.WUT_PACKAGE,'WUT_FILE_INFO', clientFileInfo);
    
    -- get the size and chunk info of the client side file
    clientFileInfo   := WebUtil_Core.getProperty(WebUtil_Core.WUT_PACKAGE,'WUT_FILE_INFO');
    clientFileSize   := DelimStr.getNumber(clientFileInfo,1,true,'|');
    if clientFileSize = 0 then
      raise CLIENT_FILE_EMPTY;
      -- no need to close application server file since it is not yet opened.
    end if;
    clientFileChunks := DelimStr.getNumber(clientFileInfo,2,true,'|');
    
    -- Set up the Open command
    if toDB then 
      if not m_DBEnabled then 
        raise TRANSFER_FORBIDDEN;
      end if;
      if  not WebUtil_DB_Local.openblob(spec1, spec2, spec3,'W', m_maxTransferSize) then 
        WebUtil_core.Error(WebUtil_Core.WUT_PACKAGE,WebUtil_DB_Local.getLastError,
                           'WEBUTIL_FILE_TRANSFER.uploadInt');
        raise READWRITE_ERROR;
      end if;
    else
      if not WebUtil_Core.checkJava then 
        raise NO_JAVA;
      end if;        
      if not checkASACL(spec1,m_writeACL) then 
        raise TRANSFER_FORBIDDEN;
      end if;        
      jobj := JAVA_APPSERV_WRITER.NEW;
      if not JAVA_APPSERV_WRITER.openFile(jobj,spec1) then 
        lastErrorCode := JAVA_APPSERV_WRITER.getLastError(jobj);
        lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(jobj) ;
        WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                           'WEBUTIL_FILE_TRANSFER.uploadInt',lastErrorArgs);
        raise READWRITE_ERROR;
      end if;
    end if;
 
    -- Is this Async? if So we do nothing more here just set the callback and kick it off
    if asynchronous then 
      -- set callbackTrigger even if it is null. we will take care
      -- before calling
      WebUtil_Core.SetCallbackTrigger(-1,callbackTrigger);
      ignore   := WebUtil_Core.getProperty(WebUtil_Core.WUT_PACKAGE,'WUT_TRANSFER');
      m_chunks := clientFileChunks;
      m_fileSize := clientFileSize;        
      m_uploadSucceeded := NULL;
      if not toDB then
          m_persistObj := ORA_JAVA.NEW_GLOBAL_REF(jobj);
      end if;
      result := true;
    else
      if NOT toDB then
        encodedFile := JAVA_FILE.createTempFile('WUAS','.enc');
        tempFileName := JAVA_FILE.getPath(encodedFile);
      end if;

      -- loop through each chunk 
      for i in 1..clientFileChunks LOOP
        dataBuffer := WebUtil_Core.getProperty(WebUtil_Core.WUT_PACKAGE,'WUT_TRANSFER',false);
        if (WebUtil_Core.isError) or (dataBuffer is null) then
          raise AGENT_BUSY;
        end if;
            
        -- Write to the correct place    
        if toDB then 
          WebUtil_DB_Local.WriteData(dataBuffer);
        else
          ftemp := TEXT_IO.FOPEN(tempFileName, 'W');
          TEXT_IO.PUT(ftemp, dataBuffer);
          TEXT_IO.FCLOSE(ftemp);
          -- if not JAVA_APPSERV_WRITER.WriteData(jobj,dataBuffer) then
          if not JAVA_APPSERV_WRITER.decodeBASE64File(jobj,tempFileName) then
            lastErrorCode := JAVA_APPSERV_WRITER.getLastError(jobj);
            lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(jobj) ;
            WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                               'WEBUTIL_FILE_TRANSFER.UploadInt',lastErrorArgs);
            raise READWRITE_ERROR;
          end if;
        end if;
      end LOOP;
      if toDB then
        if WebUtil_DB_Local.CloseBlob(clientFileSize) then 
          result := true;
        else
          WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,WebUtil_DB_Local.getLastError,
                             'WEBUTIL_FILE_TRANSFER.UploadInt');
        end if;  -- close        
      else
        bool_ignore := JAVA_FILE.DELETE_(encodedFile);
        if JAVA_APPSERV_WRITER.CloseFile(jobj,clientFileSize) then
          result := true;
        else
          lastErrorCode := JAVA_APPSERV_WRITER.getLastError(jobj);
          lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(jobj) ;
          WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                            'WEBUTIL_FILE_TRANSFER.UploadInt',lastErrorArgs);
          raise READWRITE_ERROR;
        end if;
      end if;      
    end if; -- async
    return result;
  EXCEPTION
    when CLIENT_FILE_EMPTY then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,133,'WEBUTIL_FILE_TRANSFER.UploadInt', clientFile);
      return false;
    when CLIENT_FILE_NULL then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,130,'WEBUTIL_FILE_TRANSFER.UploadInt');
      return false;
    when AS_FILE_NULL then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,117,'WEBUTIL_FILE_TRANSFER.UploadInt');
      return false;
    when FILE_NOT_FOUND then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,129,'WEBUTIL_FILE_TRANSFER.UploadInt', clientFile);
      return false;
    when TRANSFER_FORBIDDEN then 
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,121,'WEBUTIL_FILE_TRANSFER.UploadInt');
      return false;                
    when AGENT_BUSY then 
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,116,'WEBUTIL_FILE_TRANSFER.UploadInt');
      return false;    
    when READWRITE_ERROR then 
      return false;          
    when NO_JAVA then 
      return false;
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUT_PACKAGE)
                             ||' bean not found. WEBUTIL_FILE_TRANSFER.UploadInt will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;  
  END UploadInt;                       

  FUNCTION DownloadInt
                     ( clientFile       in VARCHAR2, 
                       spec1            in VARCHAR2, 
                       spec2            in VARCHAR2,
                       spec3            in VARCHAR2,
                       fromDB           in BOOLEAN,
                       withProgress     in BOOLEAN,
                       progressTitle    in VARCHAR2,
                       progressSubTitle in VARCHAR2) return BOOLEAN is
    result           BOOLEAN := false;
    dummybool        BOOLEAN;                      
    fileSize         PLS_INTEGER := 0; 
    fileChunks       PLS_INTEGER := 0;     
    buffer           VARCHAR2(32767);
    subBuffer        VARCHAR2(32767);
    clientFileInfo   VARCHAR2(1000 char);
    jobj             ORA_JAVA.JOBJECT;
    lastErrorCode    PLS_INTEGER;
    lastErrorArgs    VARCHAR2(1000);    
    parent_dir       VARCHAR2(1000);
    encodedFile      ORA_JAVA.JOBJECT;
    ftemp            TEXT_IO.FILE_TYPE;
    tempFileName     VARCHAR2(512);
    
  BEGIN
    -- Client file cannot be null.
    if clientFile is NULL then
        raise CLIENT_FILE_NULL;
    end if;

    -- Application server file cannot be null. AppServerFileReader.java also handles this.
    -- Handling here is better.
    if NOT fromDB AND spec1 is null then
        raise AS_FILE_NULL;
    end if;

    -- Make sure that the given client file path is not a directory and parent directory exists
    parent_dir := substr(clientFile, 1, instr(clientFile, WebUtil_Core.getClientFileSep, -1));
    if WEBUTIL_FILE.file_is_directory(clientFile)
         OR NOT WEBUTIL_FILE.file_is_directory (parent_dir) then
        raise INVALID_CLIENT_FILE_DIR;
    end if;

    -- First check to see if a transfer is not currently happening
    if In_Progress then 
        raise AGENT_BUSY;
    end if;

    -- Open the correct source & get the file size
    if fromDB then
      if not m_DBEnabled then 
        raise TRANSFER_FORBIDDEN;
      end if;
      if  not WebUtil_DB_Local.openblob(spec1, spec2, spec3,'R', m_maxTransferSize) then 
        lastErrorCode := WebUtil_DB_Local.getLastError;
        WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                           'WEBUTIL_FILE_TRANSFER.DownloadInt',spec1||'.'||spec2||' - Where '||spec3);
        raise READWRITE_ERROR;
      end if;
      fileSize   := WebUtil_DB_Local.getSourceLength;
      fileChunks := WebUtil_DB_Local.getSourceChunks; 
    else
      if not WebUtil_Core.checkJava then 
        raise NO_JAVA;
      end if;        
      if not checkASACL(spec1,m_readACL) then 
        raise TRANSFER_FORBIDDEN;
      end if;    
      jobj := JAVA_APPSERV_READER.NEW;
      if not JAVA_APPSERV_READER.openFile(jobj,spec1,m_maxTransferSize) then 
        lastErrorCode := JAVA_APPSERV_READER.getLastError(jobj);
        lastErrorArgs := JAVA_APPSERV_READER.getLastErrorArgs(jobj) ;
        WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                           'WEBUTIL_FILE_TRANSFER.DownloadInt',lastErrorArgs);
        raise READWRITE_ERROR;
      end if;   
      fileSize   := JAVA_APPSERV_READER.getSourceLength(jobj);
      fileChunks := JAVA_APPSERV_READER.getSourceChunks(jobj);       
    end if; -- fromDB
      
    -- construct and send the fileinfo string to the client
    clientFileInfo := clientFile||'|'||to_char(fileSize)||'|N'||
                      WebUtil_Util.BoolToStr(withProgress,'|Y|','|N|')||
                      progressTitle||'|'||progressSubTitle;
    WebUtil_Core.setProperty(WebUtil_Core.WUT_PACKAGE,'WUT_FILE_INFO',clientFileInfo,false);
    if WebUtil_Core.IsError then
      if not fromDB then
        -- close the application server file.
        dummybool := JAVA_APPSERV_READER.CLOSEFILE(jobj);
      end if;
      raise CLIENT_ERROR;
    end if;
      
    if NOT fromDB then
       encodedFile := JAVA_FILE.createTempFile('WUAS','.enc');
       tempFileName := JAVA_FILE.getPath(encodedFile);
    end if;

    -- Now loop through and get each buffer full of data
    for i in 1..fileChunks LOOP
      if fromDB then 
        buffer := WebUtil_DB_Local.ReadData;
      else
        --buffer := JAVA_APPSERV_READER.ReadData(jobj);
        if not JAVA_APPSERV_READER.encodeBASE64File(jobj,tempFileName) then
          lastErrorCode := JAVA_APPSERV_WRITER.getLastError(jobj);
          lastErrorArgs := JAVA_APPSERV_WRITER.getLastErrorArgs(jobj) ;
          WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,lastErrorCode,
                             'WEBUTIL_FILE_TRANSFER.UploadInt',lastErrorArgs);
          raise READWRITE_ERROR;
        end if;
        ftemp := TEXT_IO.FOPEN(tempFileName, 'R');
        buffer := '';
        begin  -- SUB LOOP
          loop
            TEXT_IO.GET_LINE(ftemp, subBuffer);
            buffer := buffer || chr(10) || subBuffer;
          end loop;
        exception
          when NO_DATA_FOUND then
            null; -- no need to do anything
        end; -- SUB LOOP
        TEXT_IO.FCLOSE(ftemp);
      end if; -- fromDB

      -- push the data to the client
      WebUtil_Core.setProperty(WebUtil_Core.WUT_PACKAGE,'WUT_TRANSFER',buffer, false);
      if WebUtil_Core.isError then
        if not fromDB then
           -- close the application server file.
           dummybool := JAVA_APPSERV_READER.CLOSEFILE(jobj);
           dummyBool := JAVA_FILE.DELETE_(encodedFile);
        end if;
        raise CLIENT_ERROR;
      end if;
    end LOOP;
    result := true;
      
    if not fromDB then 
    result := JAVA_APPSERV_READER.CloseFile(jobj);
    dummyBool := JAVA_FILE.DELETE_(encodedFile);
    end if;
      
    return result;
  EXCEPTION
    when INVALID_CLIENT_FILE_DIR then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,131,'WEBUTIL_FILE_TRANSFER.DownloadInt', clientFile);
      return false;
    when CLIENT_FILE_NULL then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,130,'WEBUTIL_FILE_TRANSFER.DownloadInt');
      return false;
    when AS_FILE_NULL then
      WebUtil_Core.Error(Webutil_Core.WUT_PACKAGE,117,'WEBUTIL_FILE_TRANSFER.DownloadInt');
      return false;
    when TRANSFER_FORBIDDEN then 
      WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,121,'WEBUTIL_FILE_TRANSFER.DownloadInt');
      return false;                
    when AGENT_BUSY then 
      WebUtil_core.Error(Webutil_Core.WUT_PACKAGE,116,'WEBUTIL_FILE_TRANSFER.DownloadInt');
      return false;    
    when READWRITE_ERROR then 
      return false;          
    when CLIENT_ERROR then 
      return false;          
    when NO_JAVA then 
      return false;
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUT_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE_TRANSFER.DownloadInt will not work');
      RAISE FORM_TRIGGER_FAILURE;  
  END DownloadInt;  
  
  FUNCTION getMaxTransfer return PLS_INTEGER is 
  BEGIN 
    return to_number(WebUtil_Core.getProperty(WebUtil_Core.WUT_PACKAGE,'WUT_MAX_BYTES'));
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUT_PACKAGE)
                              ||' bean not found. WEBUTIL_FILE_TRANSFER.getMaxTransfer will not work');
      RAISE FORM_TRIGGER_FAILURE;        
  END getMaxTransfer;        
  
  PROCEDURE init is
    readCount  PLS_INTEGER := 0;
    writeCount PLS_INTEGER := 0;  
    dir        VARCHAR2(1024 char);  
    sep        VARCHAR2(1 char) := WebUtil_Core.getServerFileSep;
  BEGIN
    m_maxTransferSize := getMaxTransfer;
    m_windows         := (sep = '\');
    m_workarea        := WebUtil_Core.ReadFromPropertyBundle('transfer.appsrv.workAreaRoot');
    if m_workarea is null then
      m_workarea := JAVA_SYSTEM.getProperty('user.home') || sep || 'temp' || sep;
    elsif substr(m_workarea,-1,1) <> sep then 
      m_workarea := m_workarea||sep;
    end if; 
    m_workarea        := m_workarea||replace(WebUtil_Core.getClientIPAddress,'.','_')||sep||WebUtil_Core.getClientUserName||sep;
    m_DBEnabled       := (upper(WebUtil_Core.ReadFromPropertyBundle('transfer.database.enabled')) = 'TRUE');
    m_ASEnabled       := (upper(WebUtil_Core.ReadFromPropertyBundle('transfer.appsrv.enabled')) = 'TRUE');  
    m_ASUseACL        := (upper(WebUtil_Core.ReadFromPropertyBundle('transfer.appsrv.accessControl')) = 'TRUE'); 
    
    if m_ASEnabled and m_ASUseACL then 
      -- 1. Workarea is both read and write
      if m_workarea is not null then 
        readCount  := 1;
        writeCount := 1;
        m_readACL(1) := m_workArea;
        m_writeACL(1) := m_workArea;
      end if;
            
      -- 2. Read directories (up to 50 locations seems reasonable max)
      for i in 1..50 LOOP
        dir := WebUtil_Core.ReadFromPropertyBundle('transfer.appsrv.read.'||to_char(i));
        if dir is null then 
          EXIT;
        else
          -- Append the file separator to plug any loopholes
          -- that would result if another directory 
          -- existed with the same prefix
          if substr(dir,-1,1) <> sep then 
            dir := dir||sep;
          end if; 
          readCount := readCount + 1;
          m_readACL(readCount) := dir;
        end if;
      end LOOP;
  
      -- 3. Write directories
      for j in 1..50 LOOP
        dir := WebUtil_Core.ReadFromPropertyBundle('transfer.appsrv.write.'||to_char(j));
        if dir is null then 
          EXIT;
        else
          -- Append the file separator to plug any loopholes
          -- that would result if another directory 
          -- existed with the same prefix
          if substr(dir,-1,1) <> sep then 
            dir := dir||sep;
          end if;                 

          writeCount := writeCount + 1;
          m_writeACL(writeCount) := dir;
        end if;
      end LOOP;
    end if;
    
  END init;

  FUNCTION checkASACL(ASFile          in     VARCHAR2,
                      acl           in out aclType) return BOOLEAN is
    result        BOOLEAN := FALSE;                    
    allowedDir    VARCHAR2(1024);
    allowedDirLen PLS_INTEGER;
    fname         VARCHAR2(1024);
    sep           VARCHAR2(1);
  BEGIN
    if ASFile is null then
      -- There is no default application server file name. Null cannot be used.
      return false;
    end if;
    if m_ASEnabled then 
      if m_ASUseACL then 
        -- add a trailing separator so that c:\temp will also match
        -- with c:\temp\. Earlier trailing separator was added to acl
        -- so that c:\temp1 does not become a subdirectory of c:\temp
        -- or c:\temp1 does not match with c:\temp. Note: file need
        -- not be directory. It could be c:\temp\test.txt.
        -- There is no harm in appending a separator since we are going
        -- to substr before comparing.
        sep := WebUtil_Core.getServerFileSep;
        fname := ASFile || sep;
        for i in 1..acl.COUNT LOOP
          allowedDir    := acl(i);
          allowedDirLen := length(allowedDir);
          if m_windows then -- case insensitive
            if lower(substr(fname,1,allowedDirLen)) = lower(allowedDir) then 
              result := true;
              EXIT;
            end if;
          else
            if substr(fname,1,allowedDirLen) = allowedDir then 
              result := true;
              EXIT;
            end if;
          end if;
        end LOOP;
      else
        result := true;
      end if;      
    end if;
      
    return result;
  end checkASACL;           
      
  
BEGIN
  -- Core initialisation
  WebUtil_Core.Init;
  -- Initialisation of ACL etc for this package        
  init;
END WEBUTIL_FILE_TRANSFER;


PACKAGE WEBUTIL_HOST IS
/*********************************************************************************\
 * WEBUTIL_HOST
 *   This Package contains routines to execute "host" commands on the client
 *   Calls may be blocking or asynchronous and if aysnchronous may have a 
 *   callback mode e.g. You fire off the process on the client and when it 
 *   has finished a user named trigger will execute
 *********************************************************************************
 * Version 1.0.2
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 27/JAN/2003 - Creation
 *   1.0.1 DRMILLS 01/MAR/2003 - Slight API changes
 *   1.0.2 DRMILLS 17/MAY/2003 - Added call to WebUtil_Core.Init
 *
\*********************************************************************************/

  /*
   * Types
   */
   
  /**
   * PROCESS_ID is a type to represent a process so that you can do 
   * things like get the return code and error output and also kill it
   */    
  type PROCESS_ID is record (handle PLS_INTEGER);

  /**
   * OUTPUT_ARRAY is used to return the Standard Out and Standard Error output 
   * from a host command - each line of the output will appear as a member of this array
   */    
  type OUTPUT_ARRAY is table of VARCHAR2(256 char) index by binary_integer;

  /*
   * Functions 
   */

  /**
   * HOST function is closest to the old client/server Host.
   * It blocks the Forms client until the host call is finished.
   * This version returns with the return code from the client
   */    
  FUNCTION  Host(cmd in VARCHAR2) return PLS_INTEGER;
  
  /**
   * HOST procedure is closest to the old client/server Host.
   * It blocks the Forms client until the host call is finished.
   * This version returns nothing
   */      
  PROCEDURE Host(cmd in VARCHAR2);     
  
  /**
   * Blocking like the Host function blocks the client until 
   * it is finished.  However it returns the process id rather 
   * than the return code.
   */  
  FUNCTION  Blocking(cmd in VARCHAR2) return PROCESS_ID;  

  /**
   * This version of Blocking is identical to the HOST Procedure
   */  
  PROCEDURE Blocking(cmd in VARCHAR2);   
  
  /**
   * NonBlocking executes a Host command and returns 
   * to the Form, allowing PL/SQL to continue at the same time that
   * the command is running on the client. 
   * The process id is returned so that you can:
   * 1) Get the Return code from the Process once it's finished 
   * 2) Get the console output and error output
   * 3) Kill the Process you started
   * NOTE: It is important to call Release_Process(processId) when 
   * You have finished with this process ID - this will release 
   * resources in the client (but will not kill the program that 
   * you started - use Terminate_Process() for that)
   */ 
  FUNCTION  NonBlocking(cmd in VARCHAR2)return PROCESS_ID;

  /**
   * The Procedure version of NonBlocking executes a Host command 
   * and returns to the Form, allowing PL/SQL to continue at the 
   * same time that the command is running on the client. 
   * In this case the process id is not returned and the client 
   * side objects are automatically cleaned up for you.
   */  
  PROCEDURE NonBlocking(cmd in VARCHAR2);
    
  /**
   * NonBlocking_With_Callback executes a Host command and returns 
   * to the Form, allowing PL/SQL to continue at the same time that
   * the command is running on the client. 
   * The difference between this call and NonBlocking is that you 
   * can supply the name of a User Defined trigger which WebUtil 
   * will automatically call as soon as the process you've started 
   * has ended.
   * The process id is returned so that you can:
   * 1) Get the Return code from the Process once it's finished 
   * 2) Get the console output and error output
   * 3) Kill the Process you started
   * NOTE: It is important to call Release_Process(processId) when 
   * You have finished with this process ID - this will release 
   * resources in the client (but will not kill the program that 
   * you started - use Terminate_Process() for that)
   * Only call ReleaseProcess in this case *After* the callback 
   * trigger has been called. 
   */ 
  FUNCTION  NonBlocking_With_Callback(cmd in VARCHAR2, callbackTrigger in VARCHAR2)return PROCESS_ID;

  /**
   * Given a Valid process id that you've gotten from 
   * NonBlocking() or NonBlockingWithCallback() you can terminate
   * the client program that you are running. 
   */  
  PROCEDURE Terminate_Process(process in PROCESS_ID);

  /**
   * Get the return code from a given process
   */  
  FUNCTION  Get_Return_Code(process in PROCESS_ID) return PLS_INTEGER;
  
  /**
   * Get the console output from a given process
   */  
  FUNCTION  Get_Standard_Output(process in PROCESS_ID) return OUTPUT_ARRAY;

  /**
   * Get the error output from a given process
   */  
  FUNCTION  Get_Standard_Error(process in PROCESS_ID) return OUTPUT_ARRAY;
  
  /**
   * Clean up the resources allocated to a particular Process
   * on the client
   */  
  PROCEDURE Release_Process(process in out PROCESS_ID);  
  
  /**
   * Get the ID of the process that has just finished.
   * This call is only valid for use in a callback trigger 
   * that has been set up and called through NonBlockingWithCallback()
   */  
  FUNCTION  Get_Callback_Process return PROCESS_ID;  
  
  /**
   * Test to see if this Process ID is null
   */  
  FUNCTION  ID_NULL(process PROCESS_ID) return BOOLEAN;
  
  /**
   * Test to see if two Process IDs represent the same process
   */  
  FUNCTION  EQUALS(process_1 PROCESS_ID, process_2 PROCESS_ID) return BOOLEAN;  
  
END WEBUTIL_HOST;


PACKAGE BODY WEBUTIL_HOST IS
  /* 
   * Constants
   */
  BLOCKING_MODE     CONSTANT PLS_INTEGER := 0;
  NON_BLOCKING_MODE CONSTANT PLS_INTEGER := 1;
  CALLBACK_MODE     CONSTANT PLS_INTEGER := 2;  

  /* 
   * Internal Types
   */ 
  type CALLBACK_LIST is table of varchar2(30) index by binary_integer;
  
  /*
   * Private Variables
   */
   m_callbackList CALLBACK_LIST; 

  /*
   * Internal Program units
   */
  FUNCTION Execute (cmd in VARCHAR2, exemode in PLS_INTEGER) return PROCESS_ID;
  FUNCTION GetOutput(process in PROCESS_ID, prop in VARCHAR2) return OUTPUT_ARRAY;   
   
  /*
   * Implementation of Public Program units
   */   
  FUNCTION  Host(cmd in VARCHAR2) return PLS_INTEGER is
    procId PROCESS_ID;
    RC     PLS_INTEGER := -1;
  begin
    procId := Blocking(cmd);
    if not ID_NULL(procId) then
      RC := Get_Return_Code(procId);
      -- release the client side object
      Release_Process(procId);
    end if;
    return RC;
  end Host;
  
  PROCEDURE Host(cmd in VARCHAR2) is
  begin
    Blocking(cmd);
  end Host;  
  
  FUNCTION  Blocking(cmd in VARCHAR2) return PROCESS_ID is
  begin
    return Execute(cmd,BLOCKING_MODE);
  end Blocking;
  
  PROCEDURE Blocking(cmd in VARCHAR2) is
    procId PROCESS_ID;
  begin
    procId := Execute(cmd,BLOCKING_MODE);
    if not ID_NULL(procId) then 
       -- release the client side object
       Release_Process(procId);
     end if;      
  end Blocking;  

  FUNCTION  NonBlocking(cmd in VARCHAR2) return PROCESS_ID is
  begin
    return Execute(cmd,NON_BLOCKING_MODE);
  end NonBlocking;

  PROCEDURE NonBlocking(cmd in VARCHAR2) is
    procId PROCESS_ID;  
  begin
    procId := Execute(cmd,NON_BLOCKING_MODE);
    if not ID_NULL(procId) then 
      -- release the client side object
      Release_Process(procId);
    end if;       
  end NonBlocking;
  
  FUNCTION  NonBlocking_With_Callback(cmd in VARCHAR2, callbackTrigger in VARCHAR2)return PROCESS_ID is
    procId PROCESS_ID;   
  begin
    procId := Execute(cmd,CALLBACK_MODE);
    WebUtil_Core.SetCallbackTrigger(procId.handle, callbackTrigger);
    return procId;
  end NonBlocking_With_Callback;

  PROCEDURE Terminate_Process(process in PROCESS_ID) is
  begin
    WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_TERMINATE_PROC',process.handle);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
       WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUH_PACKAGE)
                               ||' bean not found. WEBUTIL_HOST.Terminate_Process will not work');
  end Terminate_Process;      
  
  
  FUNCTION Get_Return_Code(process in PROCESS_ID) return PLS_INTEGER is
  begin 
    WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_PROC_ID',process.handle);
    return to_number(WebUtil_Core.getProperty(WebUtil_Core.WUH_PACKAGE,'WUH_RC'));
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
       WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUH_PACKAGE)
                               ||' bean not found. WEBUTIL_HOST.Get_Return_Code will not work');
  end Get_Return_Code;
    
  FUNCTION Get_Standard_Output(process in PROCESS_ID) return OUTPUT_ARRAY is  
  begin 
    return GetOutput(process,'WUH_STDOUT');
  end Get_Standard_Output;

  FUNCTION Get_Standard_Error(process in PROCESS_ID) return OUTPUT_ARRAY is  
  begin 
    return GetOutput(process,'WUH_STDERR');
  end Get_Standard_Error;
  
  PROCEDURE Release_Process(process in out PROCESS_ID) is  
  begin
    WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_CLEAR_PROC',process.handle);
    WebUtil_Core.ClearCallbackTrigger(process.handle);
    process.handle := null;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUH_PACKAGE)
                              ||' bean not found. WEBUTIL_HOST.Release_Process will not work');
  end Release_Process;
  
  FUNCTION  Get_Callback_Process return PROCESS_ID is
    process PROCESS_ID;
  begin 
    process.handle := WebUtil_Core.GetLastCallbackId;
    return process;
  end Get_Callback_Process;
  
  FUNCTION  ID_NULL(process PROCESS_ID) return BOOLEAN is
  begin
    if process.handle is null then 
      return TRUE;
    else
      return FALSE;
    end if;
  end ID_NULL;
  
  FUNCTION  EQUALS(process_1 PROCESS_ID, process_2 PROCESS_ID) return BOOLEAN is
  begin
    if process_1.handle = process_2.handle then 
      return TRUE;
    else
      return FALSE;
    end if;
  end EQUALS;
  
    
  /*
   * Implementation of Internal Program units
   */   
  FUNCTION Execute (cmd in VARCHAR2, exemode in PLS_INTEGER) return PROCESS_ID is
    procId PROCESS_ID;
  begin 
    if cmd is not null then 
      WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_EXECUTION_MODE',exemode);            
      WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_EXECUTE',cmd);      
      procId.handle := to_number(WebUtil_Core.getProperty(WebUtil_Core.WUH_PACKAGE,'WUH_EXECUTE'));
    end if;
    return procId;
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUH_PACKAGE)
                              ||' bean not found. WEBUTIL_HOST.Execute will not work');
  end Execute;
  
  FUNCTION GetOutput(process in PROCESS_ID, prop in VARCHAR2) return OUTPUT_ARRAY is   
    lines  OUTPUT_ARRAY;
    i      PLS_INTEGER := 1;
    buffer VARCHAR2(257 char);
    status VARCHAR2(1) := 'X';
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUH_PACKAGE,'WUH_PROC_ID',process.handle);
    LOOP
      buffer := WebUtil_Core.getProperty(WebUtil_Core.WUH_PACKAGE,prop);
      status := substr(buffer,1,1);
      -- Status can be Y: indicating more lines to follow,
      --               N: indicating that this is the last line
      --               X: indicating that the buffer was empty
      if status <> 'X' then 
        lines(i) := substr(buffer,2);
        i := i + 1;
      end if;
      exit when status <> 'Y';
    END LOOP;
    return lines;    
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUH_PACKAGE)
                              ||' bean not found. WEBUTIL_HOST.GetOutput will not work');
  END GetOutput;  
  
BEGIN
    -- Ensure that Core is instanciated.
    Webutil_Core.Init;
END;


PACKAGE WEBUTIL_SEPARATEFRAME IS

/*********************************************************************************\
 * WEBUTIL_SEPARATEFRAME
 *   This Package contains routines to interact with the MDI frame when Forms
 *   is running with the parameter separateFrame=true
 *   The functions in this package will work with any client type - not just 
 *   Windows clients.
 *   The oracle.forms.webutil.browser.BrowserFunctions bean is needed in your 
 *   Form to use these functions
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 25/MAY/2003 - Creation
 *   1.0.1 DRMILLS 27/MAY/2003 - Added call to get frame size 
 *
\*********************************************************************************/

  /**
   *  IsSeparateFrame - Allows you to check if the form 
   *                is running in separateFrame mode or not
   */ 
  FUNCTION IsSeparateFrame RETURN BOOLEAN;
   
  /**
   *  GetSeparateFrameSize - returns a width,height pair showing the 
   *                frame size in Pixels
   */ 
  FUNCTION GetSeparateFrameSize RETURN VARCHAR2;   

  /**
   *  ShowMenuBar - Hide or show the Forms menu Bar
   *                Note this only works when the Menu property in the Form 
   *                is set to null - e.g only the "Window" menu shows.
   *                As such this call allows you to create a menuless form
   *                For best effect also set logo=no in the FormsWeb.cfg or
   *                you'll still have the space at the top of the screen allocated
   *                for that
   */ 
   
   PROCEDURE ShowMenuBar(showBar BOOLEAN);
   
  /**
   *  ShowStatusBar - Hide or show the Forms status Bar
   *                This is just like setting the console window property
   *                but can be done dynamically rather than at design time
   */ 
   
   PROCEDURE ShowStatusBar(showBar BOOLEAN);
   
  /**
   *  SetTitle -    Set the title on the separateFrame
   */ 
   PROCEDURE SetTitle(title VARCHAR2); 
   
  /**
   *  SetIcon -     Change the icon used on the separateFrame
   *                This should be a GIF or JPG image
   *                The location of the icon is relative to the value defined
   *                in your IMAGEBASE.  e.g. if you are already using IMAGEBASE=CODEBASE
   *                to read icons from a JAR file, then SetIcon will look there as well
   *                Otherwise it will look relative to the DOCUMENTBASE.
   */ 
   PROCEDURE SetIcon(icon VARCHAR2); 

  /**
   *  AllowResize - Enable or disable the ability to resize the Forms MDI frame 
   */ 
   PROCEDURE AllowResize(allow BOOLEAN); 

  /**
   *  CenterMDI -  Centers the Forms frame in the display 
   *               There are two versions of this the second allows you
   *               to nudge the frame up or down on the Y axis to allow
   *               for the task bar etc. 
   *               Positive adjust Values shift that number of pixels *down* from 
   *               the centered position and negative values shift up.
   */ 
   PROCEDURE CenterMDI; 
   PROCEDURE CenterMDI(adjustY PLS_INTEGER);    
     
   
  
END WEBUTIL_SEPARATEFRAME;


PACKAGE BODY WEBUTIL_SEPARATEFRAME IS

  FUNCTION IsSeparateFrame RETURN BOOLEAN is
  BEGIN
    if WebUtil_Core.getProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SEPARATEFRAME_MODE') = 'TRUE' then
      return TRUE;
    else
      return FALSE;
    end if;
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.IsSeparateFrame will not work');
      return null;  
  END IsSeparateFrame;
   
  FUNCTION GetSeparateFrameSize RETURN VARCHAR2 is 
  BEGIN
      return WebUtil_Core.getProperty(WebUtil_Core.WUB_PACKAGE,'WUB_APPLET_SIZE');
  EXCEPTION
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.GetSeparateFrameSize will not work');
      return null;  
  END GetSeparateFrameSize;  
  
  PROCEDURE ShowMenuBar(showBar BOOLEAN) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SHOWMENUBAR',WebUtil_Util.BoolToStr(showBar), true);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.ShowMenuBar will not work');
     RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
     RAISE FORM_TRIGGER_FAILURE;   
  END ShowMenuBar;
  
  
  PROCEDURE ShowStatusBar(showBar BOOLEAN) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SHOWSTATUSBAR',WebUtil_Util.BoolToStr(showBar), true);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.ShowStatusBar will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;   
  END ShowStatusBar;
  
  PROCEDURE SetTitle(title VARCHAR2) is 
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SEPARATEFRAME_TITLE',title, true);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.SetTitle will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;   
  END SetTitle;


  PROCEDURE SetIcon(icon VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SEPARATEFRAME_ICON',icon, false);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.SetIcon will not work');
      RAISE FORM_TRIGGER_FAILURE;  
    when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;   
  END SetIcon;
  
  PROCEDURE AllowResize(allow BOOLEAN) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SEPARATEFRAME_RESIZABLE',WebUtil_Util.BoolToStr(allow), true);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.AllowResize will not work');
      RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;   
  END AllowResize;
  
  PROCEDURE CenterMDI is 
  BEGIN
    CenterMDI(0);
  END CenterMDI;
  
  PROCEDURE CenterMDI(adjustY PLS_INTEGER) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUB_PACKAGE,'WUB_SEPARATEFRAME_CENTER',to_char(adjustY), true);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
      WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUB_PACKAGE)
                              ||' bean not found. WEBUTIL_SEPARATEFRAME.CenterMDI will not work');
      RAISE FORM_TRIGGER_FAILURE;  
   when WebUtil_Core.PROPERTY_ERROR then 
      RAISE FORM_TRIGGER_FAILURE;   
  END CenterMDI;
       
BEGIN 
    -- Explicitly instanciate CORE
    WebUtil_Core.Init;  
END WEBUTIL_SEPARATEFRAME;


PACKAGE WEBUTIL_SESSION IS
/*********************************************************************************\
 * WEBUTIL_SESSION
 *   This Package contains routines to monitor the session and react to 
 *   specifically timeout events such as the frmweb being killed
 *********************************************************************************
 * Version 1.0.1
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 03/FEB/2003 - Creation
 *   1.0.1 DRMILLS 17/MAY/2003 - Added call to WebUtil_Core.Init
 *
\*********************************************************************************/  

  /**
   * Enable_Redirect_On_TimeOut switches on the timeout functionality
   * If the Forms engine goes away this will be detected by WebUtil and then 
   * the browser will be re-directed to the nominated URL
   * Notes:
   * 1) You must supply a URL. It can be absolute or relative
   * 2) If you do not call Disable_Redirect_On_TimeOut() before exiting the 
   *    last form in the session that has the WebUtil Beans then you will 
   *    be automatically re-directed as soon as that Form closes
   *    This may be desirable but be aware of the behavior
   * 3) You can enable or disable the Timeout monitor from any WebUtil 
   *    capable Form that is open - you can disable it from a different
   *    Form from the one that started it.
   * 4) The monitor does not actively monitor the application server
   *    so a failure will not be detected until the user tries to carry 
   *    out an action in the Form
   * 5) The default monitor interval is every 5 seconds.  To change this 
   *    interval use the WebUtilDispatchMonitorInterval parameter in the 
   *    formsweb.cfg.  Set this to the number of seconds required
   * 6) Using this facility does not cause any extra network traffic between
   *    the Forms client and the application server except for the actual 
   *    calls to switch the monitoring on or off   
   */
  PROCEDURE Enable_Redirect_On_TimeOut(redirectURL in VARCHAR2);

  /**
   * Disable_Redirect_On_TimeOut switches off the timeout functionality
   */
  PROCEDURE Disable_Redirect_On_TimeOut;  
  
END WEBUTIL_SESSION;


PACKAGE BODY WEBUTIL_SESSION IS
  -- Private functions
  PROCEDURE RedirectOnTimeOut(redirectURL in VARCHAR2);
  

  -- Implementations of public functions
  PROCEDURE Enable_Redirect_On_TimeOut(redirectURL in VARCHAR2) is
  BEGIN
    RedirectOnTimeOut(redirectURL);
  END Enable_Redirect_On_TimeOut;

  PROCEDURE Disable_Redirect_On_TimeOut is
  BEGIN
    RedirectOnTimeOut(null);
  END Disable_Redirect_On_TimeOut;
  
  -- Implementations of private functions   
  PROCEDURE RedirectOnTimeOut(redirectURL in VARCHAR2) is
  BEGIN
    WebUtil_Core.setProperty(WebUtil_Core.WUS_PACKAGE,'WUS_MONITOR_DISPATCHER',redirectURL);
  EXCEPTION  
    when WebUtil_Core.BEAN_NOT_REGISTERED then 
       WebUtil_Core.ErrorAlert(WebUtil_Core.getImplClass(WebUtil_Core.WUS_PACKAGE)
                               ||' bean not found. WEBUTIL_SESSION.RedirectOnTimeOut will not work');
  END RedirectOnTimeOut;
  
BEGIN
  -- Ensure that Core is instanciated.
  Webutil_Core.Init;
END WEBUTIL_SESSION;


PACKAGE WEBUTIL_UTIL IS
/*********************************************************************************\
 * WEBUTIL_UTIL
 *   Utility Functions
 *********************************************************************************
 * Version 1.0.0
 *********************************************************************************
 * Change History
 *   1.0.0 DRMILLS 03/JAN/2003 - Creation
 *
\*********************************************************************************/ 

  /** 
   * Converts a boolean value to a string 
   * Null values are treated as false
   */
  FUNCTION BoolToStr (boolValue  in BOOLEAN, 
                      trueValue  in VARCHAR2 default 'true', 
                      falseValue in VARCHAR2 default 'false') return VARCHAR2;
  
END WEBUTIL_UTIL;


PACKAGE BODY WEBUTIL_UTIL IS

  FUNCTION BoolToStr (boolValue  in BOOLEAN, 
                      trueValue  in VARCHAR2 default 'true', 
                      falseValue in VARCHAR2 default 'false') return VARCHAR2 is
  BEGIN
    if boolValue is null or not boolValue then 
        return falseValue;
    else
        return trueValue;
    end if;
  END BoolToStr;     
  
END WEBUTIL_UTIL;


